<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>underworld3.meshing API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.meshing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional, Tuple
from enum import Enum

import tempfile
import numpy as np
from petsc4py import PETSc

from underworld3.discretisation import Mesh, MeshVariable
from underworld3 import VarType
from underworld3.coordinates import CoordinateSystemType
import sympy


def UnstructuredSimplexBox(
    minCoords: Tuple = (0.0, 0.0),
    maxCoords: Tuple = (1.0, 1.0),
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    regular: bool = False,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    minCoord:
        Tuple specifying minimum mesh location.
    maxCoord:
        Tuple specifying maximum mesh location.

    regular option works in 2D but not (currently) in 3D
    &#34;&#34;&#34;

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(1, [tag], tag)
            gmsh.model.set_physical_name(1, tag, name)

        gmsh.model.addPhysicalGroup(2, [surface], surface)
        gmsh.model.setPhysicalName(2, surface, &#34;Elements&#34;)

        if regular:
            gmsh.model.mesh.set_transfinite_surface(
                surface, cornerTags=[p1, p2, p3, p4]
            )

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin, meshSize=cellSize)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax, meshSize=cellSize)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax, meshSize=cellSize)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax, meshSize=cellSize)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], volume)
        gmsh.model.setPhysicalName(3, volume, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )


def StructuredQuadBox(
    elementRes: Optional[Tuple[int, int, int]] = (16, 16),
    minCoords: Optional[Tuple[float, float, float]] = None,
    maxCoords: Optional[Tuple[float, float, float]] = None,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    elementRes:
        Tuple specifying number of elements in each axis direction.
    minCoord:
        Optional. Tuple specifying minimum mesh location.
    maxCoord:
        Optional. Tuple specifying maximum mesh location.
    &#34;&#34;&#34;
    if minCoords == None:
        minCoords = len(elementRes) * (0.0,)
    if maxCoords == None:
        maxCoords = len(elementRes) * (1.0,)

    import gmsh

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, tag=1)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, tag=2)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, tag=3)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, tag=4)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        gmsh.model.add_physical_group(1, [l1], l1)
        gmsh.model.set_physical_name(1, l1, &#34;Bottom&#34;)
        gmsh.model.add_physical_group(1, [l2], l2)
        gmsh.model.set_physical_name(1, l2, &#34;Right&#34;)
        gmsh.model.add_physical_group(1, [l3], l3)
        gmsh.model.set_physical_name(1, l3, &#34;Top&#34;)
        gmsh.model.add_physical_group(1, [l4], l4)
        gmsh.model.set_physical_name(1, l4, &#34;Left&#34;)

        gmsh.model.add_physical_group(2, [surface], surface)
        gmsh.model.set_physical_name(2, surface, &#34;Elements&#34;)

        nx, ny = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            tag=l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=surface, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p3, p4]
        )
        gmsh.model.mesh.set_recombine(2, surface)

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        nx, ny, nz = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l5, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l6, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l7, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l8, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l9, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l10, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l11, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l12, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )

        gmsh.model.mesh.set_transfinite_surface(
            tag=bottom, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p4, p3]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=top, arrangement=&#34;Left&#34;, cornerTags=[p5, p6, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=front, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p6, p5]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=back, arrangement=&#34;Left&#34;, cornerTags=[p3, p4, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=right, arrangement=&#34;Left&#34;, cornerTags=[p2, p6, p8, p4]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=left, arrangement=&#34;Left&#34;, cornerTags=[p5, p1, p3, p7]
        )

        gmsh.model.mesh.set_recombine(2, front)
        gmsh.model.mesh.set_recombine(2, back)
        gmsh.model.mesh.set_recombine(2, bottom)
        gmsh.model.mesh.set_recombine(2, top)
        gmsh.model.mesh.set_recombine(2, right)
        gmsh.model.mesh.set_recombine(2, left)

        gmsh.model.mesh.set_transfinite_volume(
            volume, cornerTags=[p1, p2, p4, p3, p5, p6, p8, p7]
        )

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], volume)
        gmsh.model.setPhysicalName(3, volume, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )


def SphericalShell(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.1,
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 1}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Sphere&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    ball1_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusOuter)

    if radiusInner &gt; 0.0:
        ball2_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusInner)
        gmsh.model.occ.cut(
            [(3, ball1_tag)], [(3, ball2_tag)], removeObject=True, removeTool=True
        )

    gmsh.option.setNumber(&#34;Mesh.CharacteristicLengthMax&#34;, cellSize)
    gmsh.model.occ.synchronize()

    surfaces = gmsh.model.getEntities(2)
    volume = gmsh.model.getEntities(3)[0]

    if radiusInner &gt; 0.0:
        outerSurface, innerSurface = surfaces
        gmsh.model.addPhysicalGroup(
            innerSurface[0], [innerSurface[1]], boundaries[&#34;Lower&#34;]
        )
        gmsh.model.setPhysicalName(innerSurface[1], boundaries[&#34;Lower&#34;], &#34;Lower&#34;)
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], volume[1])
        gmsh.model.setPhysicalName(volume[1], volume[1], &#34;Elements&#34;)

    else:
        outerSurface = surfaces[0]
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], volume[1])
        gmsh.model.setPhysicalName(volume[1], volume[1], &#34;Elements&#34;)
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;])
        gmsh.model.setPhysicalName(0, vertices[&#34;Centre&#34;], &#34;Centre&#34;)

    gmsh.model.occ.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    # This seems not to work any longer ?? 3.17.4
    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )


def Annulus(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.1,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Annulus&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # l1 = gmsh.model.geo.add_line(p5, p4)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])

    loops = [cl2] + loops

    s = gmsh.model.geo.add_plane_surface(loops)
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(0, [p1], 2, s)
    # gmsh.model.mesh.embed(1, [l1], 2, s)

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(1, [c3, c4], boundaries[&#34;Upper&#34;], name=&#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )


def CubedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    numElements: int = 5,
    degree: int = 1,
    qdegree: int = 2,
    simplex: bool = False,
    filename=None,
):

    &#34;&#34;&#34;Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
    The number of elements is the edge of each cube&#34;&#34;&#34;

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    r1 = radiusInner / np.sqrt(3)
    r2 = radiusOuter / np.sqrt(3)

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Cubed Sphere&#34;)

    center_point = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=1)

    gmsh.model.geo.addPoint(r2, r2, -r2, tag=2)
    gmsh.model.geo.addPoint(-r2, r2, -r2, tag=3)
    gmsh.model.geo.addPoint(-r2, -r2, -r2, tag=4)
    gmsh.model.geo.addPoint(r2, -r2, -r2, tag=5)

    gmsh.model.geo.addCircleArc(3, 1, 2, tag=1)
    gmsh.model.geo.addCircleArc(2, 1, 5, tag=2)
    gmsh.model.geo.addCircleArc(5, 1, 4, tag=3)
    gmsh.model.geo.addCircleArc(4, 1, 3, tag=4)

    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], tag=1)
    gmsh.model.geo.addSurfaceFilling([1], tag=1, sphereCenterTag=1)

    gmsh.model.geo.addPoint(r1, r1, -r1, tag=6)
    gmsh.model.geo.addPoint(-r1, r1, -r1, tag=7)
    gmsh.model.geo.addPoint(-r1, -r1, -r1, tag=8)
    gmsh.model.geo.addPoint(r1, -r1, -r1, tag=9)

    gmsh.model.geo.addCircleArc(7, 1, 6, tag=5)
    gmsh.model.geo.addCircleArc(6, 1, 9, tag=6)
    gmsh.model.geo.addCircleArc(9, 1, 8, tag=7)
    gmsh.model.geo.addCircleArc(8, 1, 7, tag=8)

    gmsh.model.geo.addCurveLoop([5, 6, 7, 8], tag=2)
    gmsh.model.geo.addSurfaceFilling([2], tag=2, sphereCenterTag=1)

    gmsh.model.geo.addLine(2, 6, tag=9)
    gmsh.model.geo.addLine(3, 7, tag=10)
    gmsh.model.geo.addLine(5, 9, tag=11)
    gmsh.model.geo.addLine(4, 8, tag=12)

    gmsh.model.geo.addCurveLoop([3, 12, -7, -11], tag=3)
    gmsh.model.geo.addSurfaceFilling([3], tag=3)

    gmsh.model.geo.addCurveLoop([10, 5, -9, -1], tag=4)
    gmsh.model.geo.addSurfaceFilling([4], tag=4)

    gmsh.model.geo.addCurveLoop([9, 6, -11, -2], tag=5)
    gmsh.model.geo.addSurfaceFilling([5], tag=5)

    gmsh.model.geo.addCurveLoop([12, 8, -10, -4], tag=6)
    gmsh.model.geo.addSurfaceFilling([6], tag=6)

    gmsh.model.geo.addSurfaceLoop([2, 4, 6, 3, 1, 5], tag=1)
    gmsh.model.geo.addVolume([1], tag=1)

    # Make copies
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 3.0 * np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -np.pi / 2.0
    )

    gmsh.model.geo.synchronize()

    gmsh.model.addPhysicalGroup(2, [1, 34, 61, 88, 115, 137], boundaries[&#34;Upper&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
    gmsh.model.addPhysicalGroup(2, [2, 14, 41, 68, 95, 117], boundaries[&#34;Lower&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Lower&#34;], &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, [1, 13, 40, 67, 94, 116], 1)
    gmsh.model.setPhysicalName(3, 1, &#34;Elements&#34;)

    for _, line in gmsh.model.get_entities(1):
        gmsh.model.mesh.setTransfiniteCurve(line, numNodes=numElements + 1)

    for _, surface in gmsh.model.get_entities(2):
        gmsh.model.mesh.setTransfiniteSurface(surface)
        if not simplex:
            gmsh.model.mesh.set_recombine(2, surface)

    if not simplex:
        for _, volume in gmsh.model.get_entities(3):
            gmsh.model.mesh.set_transfinite_volume(volume)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="underworld3.meshing.Annulus"><code class="name flex">
<span>def <span class="ident">Annulus</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.3, cellSize: float = 0.1, centre: bool = False, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Annulus(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.1,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Annulus&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # l1 = gmsh.model.geo.add_line(p5, p4)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])

    loops = [cl2] + loops

    s = gmsh.model.geo.add_plane_surface(loops)
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(0, [p1], 2, s)
    # gmsh.model.mesh.embed(1, [l1], 2, s)

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(1, [c3, c4], boundaries[&#34;Upper&#34;], name=&#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.CubedSphere"><code class="name flex">
<span>def <span class="ident">CubedSphere</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.3, numElements: int = 5, degree: int = 1, qdegree: int = 2, simplex: bool = False, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
The number of elements is the edge of each cube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CubedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    numElements: int = 5,
    degree: int = 1,
    qdegree: int = 2,
    simplex: bool = False,
    filename=None,
):

    &#34;&#34;&#34;Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
    The number of elements is the edge of each cube&#34;&#34;&#34;

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    r1 = radiusInner / np.sqrt(3)
    r2 = radiusOuter / np.sqrt(3)

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Cubed Sphere&#34;)

    center_point = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=1)

    gmsh.model.geo.addPoint(r2, r2, -r2, tag=2)
    gmsh.model.geo.addPoint(-r2, r2, -r2, tag=3)
    gmsh.model.geo.addPoint(-r2, -r2, -r2, tag=4)
    gmsh.model.geo.addPoint(r2, -r2, -r2, tag=5)

    gmsh.model.geo.addCircleArc(3, 1, 2, tag=1)
    gmsh.model.geo.addCircleArc(2, 1, 5, tag=2)
    gmsh.model.geo.addCircleArc(5, 1, 4, tag=3)
    gmsh.model.geo.addCircleArc(4, 1, 3, tag=4)

    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], tag=1)
    gmsh.model.geo.addSurfaceFilling([1], tag=1, sphereCenterTag=1)

    gmsh.model.geo.addPoint(r1, r1, -r1, tag=6)
    gmsh.model.geo.addPoint(-r1, r1, -r1, tag=7)
    gmsh.model.geo.addPoint(-r1, -r1, -r1, tag=8)
    gmsh.model.geo.addPoint(r1, -r1, -r1, tag=9)

    gmsh.model.geo.addCircleArc(7, 1, 6, tag=5)
    gmsh.model.geo.addCircleArc(6, 1, 9, tag=6)
    gmsh.model.geo.addCircleArc(9, 1, 8, tag=7)
    gmsh.model.geo.addCircleArc(8, 1, 7, tag=8)

    gmsh.model.geo.addCurveLoop([5, 6, 7, 8], tag=2)
    gmsh.model.geo.addSurfaceFilling([2], tag=2, sphereCenterTag=1)

    gmsh.model.geo.addLine(2, 6, tag=9)
    gmsh.model.geo.addLine(3, 7, tag=10)
    gmsh.model.geo.addLine(5, 9, tag=11)
    gmsh.model.geo.addLine(4, 8, tag=12)

    gmsh.model.geo.addCurveLoop([3, 12, -7, -11], tag=3)
    gmsh.model.geo.addSurfaceFilling([3], tag=3)

    gmsh.model.geo.addCurveLoop([10, 5, -9, -1], tag=4)
    gmsh.model.geo.addSurfaceFilling([4], tag=4)

    gmsh.model.geo.addCurveLoop([9, 6, -11, -2], tag=5)
    gmsh.model.geo.addSurfaceFilling([5], tag=5)

    gmsh.model.geo.addCurveLoop([12, 8, -10, -4], tag=6)
    gmsh.model.geo.addSurfaceFilling([6], tag=6)

    gmsh.model.geo.addSurfaceLoop([2, 4, 6, 3, 1, 5], tag=1)
    gmsh.model.geo.addVolume([1], tag=1)

    # Make copies
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 3.0 * np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -np.pi / 2.0
    )

    gmsh.model.geo.synchronize()

    gmsh.model.addPhysicalGroup(2, [1, 34, 61, 88, 115, 137], boundaries[&#34;Upper&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
    gmsh.model.addPhysicalGroup(2, [2, 14, 41, 68, 95, 117], boundaries[&#34;Lower&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Lower&#34;], &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, [1, 13, 40, 67, 94, 116], 1)
    gmsh.model.setPhysicalName(3, 1, &#34;Elements&#34;)

    for _, line in gmsh.model.get_entities(1):
        gmsh.model.mesh.setTransfiniteCurve(line, numNodes=numElements + 1)

    for _, surface in gmsh.model.get_entities(2):
        gmsh.model.mesh.setTransfiniteSurface(surface)
        if not simplex:
            gmsh.model.mesh.set_recombine(2, surface)

    if not simplex:
        for _, volume in gmsh.model.get_entities(3):
            gmsh.model.mesh.set_transfinite_volume(volume)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.SphericalShell"><code class="name flex">
<span>def <span class="ident">SphericalShell</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.1, cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SphericalShell(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.1,
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 1}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Sphere&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    ball1_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusOuter)

    if radiusInner &gt; 0.0:
        ball2_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusInner)
        gmsh.model.occ.cut(
            [(3, ball1_tag)], [(3, ball2_tag)], removeObject=True, removeTool=True
        )

    gmsh.option.setNumber(&#34;Mesh.CharacteristicLengthMax&#34;, cellSize)
    gmsh.model.occ.synchronize()

    surfaces = gmsh.model.getEntities(2)
    volume = gmsh.model.getEntities(3)[0]

    if radiusInner &gt; 0.0:
        outerSurface, innerSurface = surfaces
        gmsh.model.addPhysicalGroup(
            innerSurface[0], [innerSurface[1]], boundaries[&#34;Lower&#34;]
        )
        gmsh.model.setPhysicalName(innerSurface[1], boundaries[&#34;Lower&#34;], &#34;Lower&#34;)
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], volume[1])
        gmsh.model.setPhysicalName(volume[1], volume[1], &#34;Elements&#34;)

    else:
        outerSurface = surfaces[0]
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], volume[1])
        gmsh.model.setPhysicalName(volume[1], volume[1], &#34;Elements&#34;)
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;])
        gmsh.model.setPhysicalName(0, vertices[&#34;Centre&#34;], &#34;Centre&#34;)

    gmsh.model.occ.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    # This seems not to work any longer ?? 3.17.4
    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.StructuredQuadBox"><code class="name flex">
<span>def <span class="ident">StructuredQuadBox</span></span>(<span>elementRes: Optional[Tuple[int, int, int]] = (16, 16), minCoords: Optional[Tuple[float, float, float]] = None, maxCoords: Optional[Tuple[float, float, float]] = None, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a 2 or 3-dimensional box mesh.</p>
<h2 id="parameters">Parameters</h2>
<p>elementRes:
Tuple specifying number of elements in each axis direction.
minCoord:
Optional. Tuple specifying minimum mesh location.
maxCoord:
Optional. Tuple specifying maximum mesh location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StructuredQuadBox(
    elementRes: Optional[Tuple[int, int, int]] = (16, 16),
    minCoords: Optional[Tuple[float, float, float]] = None,
    maxCoords: Optional[Tuple[float, float, float]] = None,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    elementRes:
        Tuple specifying number of elements in each axis direction.
    minCoord:
        Optional. Tuple specifying minimum mesh location.
    maxCoord:
        Optional. Tuple specifying maximum mesh location.
    &#34;&#34;&#34;
    if minCoords == None:
        minCoords = len(elementRes) * (0.0,)
    if maxCoords == None:
        maxCoords = len(elementRes) * (1.0,)

    import gmsh

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, tag=1)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, tag=2)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, tag=3)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, tag=4)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        gmsh.model.add_physical_group(1, [l1], l1)
        gmsh.model.set_physical_name(1, l1, &#34;Bottom&#34;)
        gmsh.model.add_physical_group(1, [l2], l2)
        gmsh.model.set_physical_name(1, l2, &#34;Right&#34;)
        gmsh.model.add_physical_group(1, [l3], l3)
        gmsh.model.set_physical_name(1, l3, &#34;Top&#34;)
        gmsh.model.add_physical_group(1, [l4], l4)
        gmsh.model.set_physical_name(1, l4, &#34;Left&#34;)

        gmsh.model.add_physical_group(2, [surface], surface)
        gmsh.model.set_physical_name(2, surface, &#34;Elements&#34;)

        nx, ny = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            tag=l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=surface, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p3, p4]
        )
        gmsh.model.mesh.set_recombine(2, surface)

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        nx, ny, nz = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l5, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l6, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l7, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l8, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l9, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l10, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l11, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l12, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )

        gmsh.model.mesh.set_transfinite_surface(
            tag=bottom, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p4, p3]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=top, arrangement=&#34;Left&#34;, cornerTags=[p5, p6, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=front, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p6, p5]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=back, arrangement=&#34;Left&#34;, cornerTags=[p3, p4, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=right, arrangement=&#34;Left&#34;, cornerTags=[p2, p6, p8, p4]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=left, arrangement=&#34;Left&#34;, cornerTags=[p5, p1, p3, p7]
        )

        gmsh.model.mesh.set_recombine(2, front)
        gmsh.model.mesh.set_recombine(2, back)
        gmsh.model.mesh.set_recombine(2, bottom)
        gmsh.model.mesh.set_recombine(2, top)
        gmsh.model.mesh.set_recombine(2, right)
        gmsh.model.mesh.set_recombine(2, left)

        gmsh.model.mesh.set_transfinite_volume(
            volume, cornerTags=[p1, p2, p4, p3, p5, p6, p8, p7]
        )

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], volume)
        gmsh.model.setPhysicalName(3, volume, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.UnstructuredSimplexBox"><code class="name flex">
<span>def <span class="ident">UnstructuredSimplexBox</span></span>(<span>minCoords: Tuple = (0.0, 0.0), maxCoords: Tuple = (1.0, 1.0), cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, regular: bool = False, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a 2 or 3-dimensional box mesh.</p>
<h2 id="parameters">Parameters</h2>
<p>minCoord:
Tuple specifying minimum mesh location.
maxCoord:
Tuple specifying maximum mesh location.</p>
<p>regular option works in 2D but not (currently) in 3D</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnstructuredSimplexBox(
    minCoords: Tuple = (0.0, 0.0),
    maxCoords: Tuple = (1.0, 1.0),
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    regular: bool = False,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    minCoord:
        Tuple specifying minimum mesh location.
    maxCoord:
        Tuple specifying maximum mesh location.

    regular option works in 2D but not (currently) in 3D
    &#34;&#34;&#34;

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(1, [tag], tag)
            gmsh.model.set_physical_name(1, tag, name)

        gmsh.model.addPhysicalGroup(2, [surface], surface)
        gmsh.model.setPhysicalName(2, surface, &#34;Elements&#34;)

        if regular:
            gmsh.model.mesh.set_transfinite_surface(
                surface, cornerTags=[p1, p2, p3, p4]
            )

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin, meshSize=cellSize)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax, meshSize=cellSize)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax, meshSize=cellSize)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax, meshSize=cellSize)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], volume)
        gmsh.model.setPhysicalName(3, volume, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3" href="index.html">underworld3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="underworld3.meshing.Annulus" href="#underworld3.meshing.Annulus">Annulus</a></code></li>
<li><code><a title="underworld3.meshing.CubedSphere" href="#underworld3.meshing.CubedSphere">CubedSphere</a></code></li>
<li><code><a title="underworld3.meshing.SphericalShell" href="#underworld3.meshing.SphericalShell">SphericalShell</a></code></li>
<li><code><a title="underworld3.meshing.StructuredQuadBox" href="#underworld3.meshing.StructuredQuadBox">StructuredQuadBox</a></code></li>
<li><code><a title="underworld3.meshing.UnstructuredSimplexBox" href="#underworld3.meshing.UnstructuredSimplexBox">UnstructuredSimplexBox</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>