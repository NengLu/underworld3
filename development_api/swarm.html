<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>underworld3.swarm API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.swarm</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional, Tuple
import contextlib

import numpy as np
import petsc4py.PETSc as PETSc
from mpi4py import MPI

import underworld3 as uw
from underworld3.utilities import _api_tools
import underworld3.timing as timing

comm = MPI.COMM_WORLD

from enum import Enum


class SwarmType(Enum):
    DMSWARM_PIC = 1


class SwarmPICLayout(Enum):
    &#34;&#34;&#34;
    Particle population fill type:

    SwarmPICLayout.REGULAR     defines points on a regular ijk mesh. Supported by simplex cell types only.
    SwarmPICLayout.GAUSS       defines points using an npoint Gauss-Legendre tensor product quadrature rule.
    SwarmPICLayout.SUBDIVISION defines points on the centroid of a sub-divided reference cell.
    &#34;&#34;&#34;

    REGULAR = 0
    GAUSS = 1
    SUBDIVISION = 2


class SwarmVariable(_api_tools.Stateful):
    @timing.routine_timer_decorator
    def __init__(
        self,
        name,
        swarm,
        num_components,
        vtype=None,
        dtype=float,
        proxy_degree=1,
        proxy_continuous=True,
        _register=True,
        _proxy=True,
        _nn_proxy=False,
    ):

        if name in swarm.vars.keys():
            raise ValueError(&#34;Variable with name {} already exists on swarm.&#34;.format(name))

        self.name = name
        self.swarm = swarm
        self.num_components = num_components

        if (dtype == float) or (dtype == &#34;float&#34;) or (dtype == np.float64):
            self.dtype = float
            petsc_type = PETSc.ScalarType
        elif (dtype == int) or (dtype == &#34;int&#34;) or (dtype == np.int32) or (dtype == np.int64):
            self.dtype = int
            petsc_type = PETSc.IntType
        else:
            raise TypeError(f&#34;Provided dtype={dtype} is not supported. Supported types are &#39;int&#39; and &#39;float&#39;.&#34;)

        if _register:
            self.swarm.dm.registerField(self.name, self.num_components, dtype=petsc_type)

        self._data = None
        # add to swarms dict
        swarm.vars[name] = self
        self._is_accessed = False

        # create proxy variable
        self._meshVar = None
        if _proxy:
            self.proxy_degree = proxy_degree
            self.proxy_continuous = proxy_continuous
            self._meshVar = uw.discretisation.MeshVariable(
                name, self.swarm.mesh, num_components, vtype, degree=proxy_degree, continuous=proxy_continuous
            )

        self._register = _register
        self._proxy = _proxy
        self._nn_proxy = _nn_proxy

        super().__init__()

    def _update(self):
        &#34;&#34;&#34;
        This method updates the proxy mesh variable for the current
        swarm &amp; particle variable state.

        Here is how it works:

            1) for each particle, create a distance-weighted average on the node data
            2) check to see which nodes have zero weight / zero contribution and replace with nearest particle value

        Todo: caching the k-d trees etc for the proxy-mesh-variable nodal points
        Todo: some form of global fall-back for when there are no particles on a processor

        &#34;&#34;&#34;

        # if not proxied, nothing to do. return.
        if not self._meshVar:
            return

        # 1 - Average particles to nodes with distance weighted average

        kd = uw.kdtree.KDTree(self._meshVar.coords)
        kd.build_index()

        with self.swarm.access():
            n, d, b = kd.find_closest_point(self.swarm.data)

            node_values = np.zeros((self._meshVar.coords.shape[0], self.num_components))
            w = np.zeros(self._meshVar.coords.shape[0])

            if not self._nn_proxy:
                for i in range(self.data.shape[0]):
                    if b[i]:
                        node_values[n[i], :] += self.data[i, :] / (1.0e-16 + d[i])
                        w[n[i]] += 1.0 / (1.0e-16 + d[i])

                node_values[np.where(w &gt; 0.0)[0], :] /= w[np.where(w &gt; 0.0)[0]].reshape(-1, 1)

        # 2 - set NN vals on mesh var where w == 0.0

        p_nnmap = self.swarm._get_map(self)

        with self.swarm.mesh.access(self._meshVar), self.swarm.access():
            self._meshVar.data[...] = node_values[...]
            self._meshVar.data[np.where(w == 0.0), :] = self.data[p_nnmap[np.where(w == 0.0)], :]

        return

    @timing.routine_timer_decorator
    def project_from(self, meshvar):
        # use method found in
        # /tmp/petsc-build/petsc/src/dm/impls/swarm/tests/ex2.c
        # to project from fields to particles

        self.swarm.mesh.dm.clearDS()
        self.swarm.mesh.dm.createDS()

        meshdm = meshvar.mesh.dm
        fields = meshvar.field_id
        _, meshvardm = meshdm.createSubDM(fields)

        ksp = PETSc.KSP().create()
        ksp.setOptionsPrefix(&#34;swarm_project_from_&#34;)
        options = PETSc.Options()
        options.setValue(&#34;swarm_project_from_ksp_type&#34;, &#34;lsqr&#34;)
        options.setValue(&#34;swarm_project_from_ksp_rtol&#34;, 1e-17)
        options.setValue(&#34;swarm_project_from_pc_type&#34;, &#34;none&#34;)
        ksp.setFromOptions()

        rhs = meshvardm.getGlobalVec()

        M_p = self.swarm.dm.createMassMatrix(meshvardm)

        # make particle weight vector
        f = self.swarm.createGlobalVectorFromField(self.name)

        # create matrix RHS vector, in this case the FEM field fhat with the coefficients vector #alpha
        M = meshvardm.createMassMatrix(meshvardm)
        with meshvar.mesh.access():
            M.multTranspose(meshvar.vec_global, rhs)

        ksp.setOperators(M_p, M_p)
        ksp.solveTranspose(rhs, f)

        self.swarm.dm.destroyGlobalVectorFromField(self.name)
        meshvardm.restoreGlobalVec(rhs)
        meshvardm.destroy()
        ksp.destroy()
        M.destroy()
        M_p.destroy()

    @property
    def data(self):
        if self._data is None:
            raise RuntimeError(&#34;Data must be accessed via the swarm `access()` context manager.&#34;)
        return self._data

    # @property
    # def fn(self):
    #     return self._meshVar.fn

    @property
    def sym(self):
        return self._meshVar.sym

    @timing.routine_timer_decorator
    def save(self, filename: str, name: Optional[str] = None, index: Optional[int] = None):
        &#34;&#34;&#34;
        Append variable data to the specified mesh
        checkpoint file. The file must already exist.

        For swarm data, we currently save the proxy
        variable (so this will fail if the variable has
        no proxy value). This allows some form of
        reconstruction of the information on a swarm
        even if it is not an exact mapping.

        This is not ideal for discontinuous fields.

        Parameters
        ----------
        filename :
            The filename of the mesh checkpoint file. It
            must already exist.
        name :
            Textual name for dataset. In particular, this
            will be used for XDMF generation. If not
            provided, the variable name will be used.
        index :
            Not currently supported. An optional index which
            might correspond to the timestep (for example).
        &#34;&#34;&#34;

        # if not proxied, nothing to do. return.
        if not self._meshVar:
            print(&#34;No proxy mesh variable that can be saved&#34;)
            return

        self._meshVar.save(filename, name, index)

        return


class IndexSwarmVariable(SwarmVariable):
    &#34;&#34;&#34;
    The IndexSwarmVariable is a class for managing material point
    behaviour. The material index variable is rendered into a
    collection of masks each representing the extent of one material
    &#34;&#34;&#34;

    @timing.routine_timer_decorator
    def __init__(
        self,
        name,
        swarm,
        indices=1,
        proxy_degree=1,
        proxy_continuous=True,
    ):

        self.indices = indices

        # These are the things we require of the generic swarm variable type
        super().__init__(
            name,
            swarm,
            num_components=1,
            vtype=None,
            dtype=int,
            _proxy=False,
        )

        # The indices variable defines how many level set maps we create as components in the proxy variable

        import sympy

        self._MaskArray = sympy.Matrix.zeros(1, self.indices)
        self._meshLevelSetVars = [None] * self.indices

        for i in range(indices):
            self._meshLevelSetVars[i] = uw.discretisation.MeshVariable(
                name + R&#34;^{[&#34; + str(i) + R&#34;]}&#34;,
                self.swarm.mesh,
                num_components=1,
                degree=proxy_degree,
                continuous=proxy_continuous,
            )
            self._MaskArray[0, i] = self._meshLevelSetVars[i].sym[0, 0]

        return

    # This is the sympy vector interface - it&#39;s meaningless if these are not spatial arrays
    @property
    def sym(self):
        return self._MaskArray

    def _update(self):
        &#34;&#34;&#34;
        This method updates the proxy mesh (vector) variable for the index variable on the current swarm locations

        Here is how it works:

            1) for each particle, create a distance-weighted average on the node data
            2) for each index in the set, we create a mask mesh variable by mapping 1.0 wherever the
               index matches and 0.0 where it does not.

        NOTE: If no material is identified with a given nodal value, the default is to material zero

        &#34;&#34;&#34;

        kd = uw.kdtree.KDTree(self._meshLevelSetVars[0].coords)
        kd.build_index()

        for ii in range(self.indices):
            meshVar = self._meshLevelSetVars[ii]

            # 1 - Average particles to nodes with distance weighted average
            with self.swarm.mesh.access(meshVar), self.swarm.access():
                n, d, b = kd.find_closest_point(self.swarm.data)

                node_values = np.zeros((meshVar.data.shape[0],))
                w = np.zeros((meshVar.data.shape[0],))

                for i in range(self.data.shape[0]):
                    if b[i]:
                        node_values[n[i]] += np.isclose(self.data[i], ii) / (1.0e-16 + d[i])
                        w[n[i]] += 1.0 / (1.0e-16 + d[i])

                node_values[np.where(w &gt; 0.0)[0]] /= w[np.where(w &gt; 0.0)[0]]

            # 2 - set NN vals on mesh var where w == 0.0

            with self.swarm.mesh.access(meshVar), self.swarm.access():
                meshVar.data[...] = node_values[...].reshape(-1, 1)

                # Need to document this assumption, if there is no material found,
                # assume the default material (0). An alternative would be to impose
                # a near-neighbour hunt for a valid material and set that one.

                if ii == 0:
                    meshVar.data[np.where(w == 0.0)] = 1.0
                else:
                    meshVar.data[np.where(w == 0.0)] = 0.0

        return


# @typechecked
class Swarm(_api_tools.Stateful):

    instances = 0

    @timing.routine_timer_decorator
    def __init__(self, mesh):

        Swarm.instances += 1

        self.mesh = mesh
        self.dim = mesh.dim
        self.cdim = mesh.cdim
        self.dm = PETSc.DMSwarm().create()
        self.dm.setDimension(self.dim)
        self.dm.setType(SwarmType.DMSWARM_PIC.value)
        self.dm.setCellDM(mesh.dm)
        self._data = None

        # dictionary for variables
        import weakref

        self._vars = weakref.WeakValueDictionary()

        # add variable to handle particle coords
        self._coord_var = SwarmVariable(&#34;DMSwarmPIC_coor&#34;, self, self.cdim, dtype=float, _register=False, _proxy=False)

        # add variable to handle particle cell id
        self._cellid_var = SwarmVariable(&#34;DMSwarm_cellid&#34;, self, 1, dtype=int, _register=False, _proxy=False)

        # add variable to hold swarm coordinates during position updates
        self._X0 = uw.swarm.SwarmVariable(&#34;DMSwarm_X0&#34;, self, self.cdim, dtype=float, _register=True, _proxy=False)
        self._X0_uninitialised = True

        self._index = None
        self._nnmapdict = {}

        super().__init__()

    @property
    def data(self):
        return self.particle_coordinates.data

    @property
    def particle_coordinates(self):
        return self._coord_var

    @property
    def particle_cellid(self):
        return self._cellid_var

    @timing.routine_timer_decorator
    def populate(
        self,
        fill_param: Optional[int] = 3,
        layout: Optional[SwarmPICLayout] = None,
    ):
        (
            &#34;&#34;&#34;
        Populate the swarm with particles throughout the domain.

        &#34;&#34;&#34;
            + SwarmPICLayout.__doc__
            + &#34;&#34;&#34;

        When using SwarmPICLayout.REGULAR,     `fill_param` defines the number of points in each spatial direction.
        When using SwarmPICLayout.GAUSS,       `fill_param` defines the number of quadrature points in each spatial direction.
        When using SwarmPICLayout.SUBDIVISION, `fill_param` defines the number times the reference cell is sub-divided.

        Parameters
        ----------
        fill_param:
            Parameter determining the particle count per cell for the given layout.
        layout:
            Type of layout to use. Defaults to `SwarmPICLayout.REGULAR` for mesh objects with simplex
            type cells, and `SwarmPICLayout.GAUSS` otherwise.



        &#34;&#34;&#34;
        )

        self.fill_param = fill_param

        &#34;&#34;&#34;
        Currently (2021.11.15) supported by PETSc release 3.16.x
 
        When using a DMPLEX the following case are supported:
              (i) DMSWARMPIC_LAYOUT_REGULAR: 2D (triangle),
             (ii) DMSWARMPIC_LAYOUT_GAUSS: 2D and 3D provided the cell is a tri/tet or a quad/hex,
            (iii) DMSWARMPIC_LAYOUT_SUBDIVISION: 2D and 3D for quad/hex and 2D tri.

        So this means, simplex mesh in 3D only supports GAUSS 

        &#34;&#34;&#34;

        if layout == None:
            if self.mesh.isSimplex == True and self.dim == 2 and fill_param &gt; 1:
                layout = SwarmPICLayout.REGULAR
            else:
                layout = SwarmPICLayout.GAUSS

        if not isinstance(layout, SwarmPICLayout):
            raise ValueError(&#34;&#39;layout&#39; must be an instance of &#39;SwarmPICLayout&#39;&#34;)

        self.layout = layout
        self.dm.finalizeFieldRegister()

        ## Commenting this out for now.
        ## Code seems to operate fine without it, and the
        ## existing values are wrong. It should be something like
        ## `(elend-elstart)*fill_param^dim` for quads, and around
        ## half that for simplices, depending on layout.
        # elstart,elend = self.mesh.dm.getHeightStratum(0)
        # self.dm.setLocalSizes((elend-elstart) * fill_param, 0)

        self.dm.insertPointUsingCellDM(self.layout.value, fill_param)
        return  # self # LM: Is there any reason to return self ?

    @timing.routine_timer_decorator
    def add_variable(self, name, num_components=1, dtype=float, proxy_degree=2, _nn_proxy=False):
        return SwarmVariable(name, self, num_components, dtype=dtype, proxy_degree=proxy_degree, _nn_proxy=_nn_proxy)

    @property
    def vars(self):
        return self._vars

    def access(self, *writeable_vars: SwarmVariable):
        &#34;&#34;&#34;
        This context manager makes the underlying swarm variables data available to
        the user. The data should be accessed via the variables `data` handle.

        As default, all data is read-only. To enable writeable data, the user should
        specify which variable they wish to modify.

        At the conclusion of the users context managed block, numerous further operations
        will be automatically executed. This includes swarm parallel migration routines
        where the swarm&#39;s `particle_coordinates` variable has been modified. The swarm
        variable proxy mesh variables will also be updated for modifed swarm variables.

        Parameters
        ----------
        writeable_vars
            The variables for which data write access is required.

        Example
        -------

        &gt;&gt;&gt; import underworld3 as uw
        &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
        &gt;&gt;&gt; with someMesh.deform_mesh():
        ...     someMesh.data[0] = [0.1,0.1]
        &gt;&gt;&gt; someMesh.data[0]
        array([ 0.1,  0.1])
        &#34;&#34;&#34;
        import time

        uw.timing._incrementDepth()
        stime = time.time()

        deaccess_list = []
        for var in self.vars.values():
            # if already accessed within higher level context manager, continue.
            if var._is_accessed == True:
                continue
            # set flag so variable status can be known elsewhere
            var._is_accessed = True
            # add to de-access list to rewind this later
            deaccess_list.append(var)
            # grab numpy object, setting read only if necessary
            var._data = self.dm.getField(var.name).reshape((-1, var.num_components))
            if var not in writeable_vars:
                var._old_data_flag = var._data.flags.writeable
                var._data.flags.writeable = False
            else:
                # increment variable state
                var._increment()
        # if particles moving, update swarm state
        if self.particle_coordinates in writeable_vars:
            self._increment()

        # Create a class which specifies the required context
        # manager hooks (`__enter__`, `__exit__`).
        class exit_manager:
            def __init__(self, swarm):
                self.em_swarm = swarm

            def __enter__(self):
                pass

            def __exit__(self, *args):
                for var in self.em_swarm.vars.values():
                    # only de-access variables we have set access for.
                    if var not in deaccess_list:
                        continue
                    # set this back, although possibly not required.
                    if var not in writeable_vars:
                        var._data.flags.writeable = var._old_data_flag
                    var._data = None
                    self.em_swarm.dm.restoreField(var.name)
                    var._is_accessed = False
                # do particle migration if coords changes
                if self.em_swarm.particle_coordinates in writeable_vars:
                    # let&#39;s use the mesh index to update the particles owning cells.
                    # note that the `petsc4py` interface is more convenient here as the
                    # `SwarmVariable.data` interface is controlled by the context manager
                    # that we are currently within, and it is therefore too easy to
                    # get things wrong that way.
                    cellid = self.em_swarm.dm.getField(&#34;DMSwarm_cellid&#34;)
                    coords = self.em_swarm.dm.getField(&#34;DMSwarmPIC_coor&#34;).reshape((-1, self.em_swarm.dim))
                    cellid[:] = self.em_swarm.mesh.get_closest_cells(coords)
                    self.em_swarm.dm.restoreField(&#34;DMSwarmPIC_coor&#34;)
                    self.em_swarm.dm.restoreField(&#34;DMSwarm_cellid&#34;)
                    # now migrate.
                    self.em_swarm.dm.migrate(remove_sent_points=True)
                    # void these things too
                    self.em_swarm._index = None
                    self.em_swarm._nnmapdict = {}
                # do var updates
                for var in self.em_swarm.vars.values():
                    # if swarm migrated, update all.
                    # if var updated, update var.
                    if (self.em_swarm.particle_coordinates in writeable_vars) or (var in writeable_vars):
                        var._update()

                uw.timing._decrementDepth()
                uw.timing.log_result(time.time() - stime, &#34;Swarm.access&#34;, 1)

        return exit_manager(self)

    def _get_map(self, var):
        # generate tree if not avaiable
        if not self._index:
            with self.access():
                self._index = uw.kdtree.KDTree(self.data)

        # get or generate map
        meshvar_coords = var._meshVar.coords
        # we can&#39;t use numpy arrays directly as keys in python dicts, so
        # we&#39;ll use `xxhash` to generate a hash of array.
        # this shouldn&#39;t be an issue performance wise but we should test to be
        # sufficiently confident of this.
        import xxhash

        h = xxhash.xxh64()
        h.update(meshvar_coords)
        digest = h.intdigest()
        if digest not in self._nnmapdict:
            self._nnmapdict[digest] = self._index.find_closest_point(meshvar_coords)[0]
        return self._nnmapdict[digest]

    def advection(self, V_fn, delta_t, order=2, corrector=False, restore_points_to_domain_func=None):

        X0 = self._X0

        # Use current velocity to estimate where the particles would have
        # landed in an implicit step.

        # ? how does this interact with the particle restoration function ?

        V_fn_matrix = self.mesh.vector.to_matrix(V_fn)

        if corrector == True and not self._X0_uninitialised:
            with self.access(self.particle_coordinates):
                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                corrected_position = X0.data + delta_t * v_at_Vpts
                if restore_points_to_domain_func is not None:
                    corrected_position = restore_points_to_domain_func(corrected_position)

                updated_current_coords = 0.5 * (corrected_position + self.data)

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    updated_current_coords = restore_points_to_domain_func(updated_current_coords)

                self.data[...] = updated_current_coords

        with self.access(X0):
            X0.data[...] = self.data[...]
            self._X0_uninitialised = False

        # Mid point algorithm (2nd order)
        if order == 2:
            with self.access(self.particle_coordinates):

                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                mid_pt_coords = self.data[...] + 0.5 * delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    mid_pt_coords = restore_points_to_domain_func(mid_pt_coords)

                self.data[...] = mid_pt_coords

                # if (uw.mpi.rank == 0):
                #     print(&#34;Updated mid point position&#34;, flush=True)

                ## Let the swarm be updated, and then move the rest of the way

            with self.access(self.particle_coordinates):

                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                # if (uw.mpi.rank == 0):
                #     print(&#34;Re-launch from X0&#34;, flush=True)

                new_coords = X0.data[...] + delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)
                if restore_points_to_domain_func is not None:
                    new_coords = restore_points_to_domain_func(new_coords)

                # if (uw.mpi.rank == 0):
                #     print(&#34;Update&#34;, flush=True)

                self.data[...] = new_coords

        # Previous position algorithm (cf above) - we use the previous step as the
        # launch point using the current velocity field. This gives a correction to the previous
        # landing point.

        # assumes X0 is stored from the previous step ... midpoint is needed in the first step

        # forward Euler (1st order)
        else:
            with self.access(self.particle_coordinates):
                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn[d], self.data).reshape(-1)

                new_coords = self.data + delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    new_coords = restore_points_to_domain_func(new_coords)

                self.data[...] = new_coords

        return</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.swarm.IndexSwarmVariable"><code class="flex name class">
<span>class <span class="ident">IndexSwarmVariable</span></span>
<span>(</span><span>name, swarm, indices=1, proxy_degree=1, proxy_continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>The IndexSwarmVariable is a class for managing material point
behaviour. The material index variable is rendered into a
collection of masks each representing the extent of one material</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndexSwarmVariable(SwarmVariable):
    &#34;&#34;&#34;
    The IndexSwarmVariable is a class for managing material point
    behaviour. The material index variable is rendered into a
    collection of masks each representing the extent of one material
    &#34;&#34;&#34;

    @timing.routine_timer_decorator
    def __init__(
        self,
        name,
        swarm,
        indices=1,
        proxy_degree=1,
        proxy_continuous=True,
    ):

        self.indices = indices

        # These are the things we require of the generic swarm variable type
        super().__init__(
            name,
            swarm,
            num_components=1,
            vtype=None,
            dtype=int,
            _proxy=False,
        )

        # The indices variable defines how many level set maps we create as components in the proxy variable

        import sympy

        self._MaskArray = sympy.Matrix.zeros(1, self.indices)
        self._meshLevelSetVars = [None] * self.indices

        for i in range(indices):
            self._meshLevelSetVars[i] = uw.discretisation.MeshVariable(
                name + R&#34;^{[&#34; + str(i) + R&#34;]}&#34;,
                self.swarm.mesh,
                num_components=1,
                degree=proxy_degree,
                continuous=proxy_continuous,
            )
            self._MaskArray[0, i] = self._meshLevelSetVars[i].sym[0, 0]

        return

    # This is the sympy vector interface - it&#39;s meaningless if these are not spatial arrays
    @property
    def sym(self):
        return self._MaskArray

    def _update(self):
        &#34;&#34;&#34;
        This method updates the proxy mesh (vector) variable for the index variable on the current swarm locations

        Here is how it works:

            1) for each particle, create a distance-weighted average on the node data
            2) for each index in the set, we create a mask mesh variable by mapping 1.0 wherever the
               index matches and 0.0 where it does not.

        NOTE: If no material is identified with a given nodal value, the default is to material zero

        &#34;&#34;&#34;

        kd = uw.kdtree.KDTree(self._meshLevelSetVars[0].coords)
        kd.build_index()

        for ii in range(self.indices):
            meshVar = self._meshLevelSetVars[ii]

            # 1 - Average particles to nodes with distance weighted average
            with self.swarm.mesh.access(meshVar), self.swarm.access():
                n, d, b = kd.find_closest_point(self.swarm.data)

                node_values = np.zeros((meshVar.data.shape[0],))
                w = np.zeros((meshVar.data.shape[0],))

                for i in range(self.data.shape[0]):
                    if b[i]:
                        node_values[n[i]] += np.isclose(self.data[i], ii) / (1.0e-16 + d[i])
                        w[n[i]] += 1.0 / (1.0e-16 + d[i])

                node_values[np.where(w &gt; 0.0)[0]] /= w[np.where(w &gt; 0.0)[0]]

            # 2 - set NN vals on mesh var where w == 0.0

            with self.swarm.mesh.access(meshVar), self.swarm.access():
                meshVar.data[...] = node_values[...].reshape(-1, 1)

                # Need to document this assumption, if there is no material found,
                # assume the default material (0). An alternative would be to impose
                # a near-neighbour hunt for a valid material and set that one.

                if ii == 0:
                    meshVar.data[np.where(w == 0.0)] = 1.0
                else:
                    meshVar.data[np.where(w == 0.0)] = 0.0

        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.swarm.SwarmVariable" href="#underworld3.swarm.SwarmVariable">SwarmVariable</a></li>
<li>underworld3.utilities._api_tools.Stateful</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.swarm.IndexSwarmVariable.sym"><code class="name">var <span class="ident">sym</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym(self):
    return self._MaskArray</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.swarm.SwarmVariable" href="#underworld3.swarm.SwarmVariable">SwarmVariable</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.swarm.SwarmVariable.save" href="#underworld3.swarm.SwarmVariable.save">save</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="underworld3.swarm.Swarm"><code class="flex name class">
<span>class <span class="ident">Swarm</span></span>
<span>(</span><span>mesh)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a mixin class for underworld objects that are stateful.
The state of an object is incremented whenever it is modified.
For example, heavy variables have states, and when a user modifies
it within its <code>access()</code> context manager, its state is incremented
at the conclusion of their modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Swarm(_api_tools.Stateful):

    instances = 0

    @timing.routine_timer_decorator
    def __init__(self, mesh):

        Swarm.instances += 1

        self.mesh = mesh
        self.dim = mesh.dim
        self.cdim = mesh.cdim
        self.dm = PETSc.DMSwarm().create()
        self.dm.setDimension(self.dim)
        self.dm.setType(SwarmType.DMSWARM_PIC.value)
        self.dm.setCellDM(mesh.dm)
        self._data = None

        # dictionary for variables
        import weakref

        self._vars = weakref.WeakValueDictionary()

        # add variable to handle particle coords
        self._coord_var = SwarmVariable(&#34;DMSwarmPIC_coor&#34;, self, self.cdim, dtype=float, _register=False, _proxy=False)

        # add variable to handle particle cell id
        self._cellid_var = SwarmVariable(&#34;DMSwarm_cellid&#34;, self, 1, dtype=int, _register=False, _proxy=False)

        # add variable to hold swarm coordinates during position updates
        self._X0 = uw.swarm.SwarmVariable(&#34;DMSwarm_X0&#34;, self, self.cdim, dtype=float, _register=True, _proxy=False)
        self._X0_uninitialised = True

        self._index = None
        self._nnmapdict = {}

        super().__init__()

    @property
    def data(self):
        return self.particle_coordinates.data

    @property
    def particle_coordinates(self):
        return self._coord_var

    @property
    def particle_cellid(self):
        return self._cellid_var

    @timing.routine_timer_decorator
    def populate(
        self,
        fill_param: Optional[int] = 3,
        layout: Optional[SwarmPICLayout] = None,
    ):
        (
            &#34;&#34;&#34;
        Populate the swarm with particles throughout the domain.

        &#34;&#34;&#34;
            + SwarmPICLayout.__doc__
            + &#34;&#34;&#34;

        When using SwarmPICLayout.REGULAR,     `fill_param` defines the number of points in each spatial direction.
        When using SwarmPICLayout.GAUSS,       `fill_param` defines the number of quadrature points in each spatial direction.
        When using SwarmPICLayout.SUBDIVISION, `fill_param` defines the number times the reference cell is sub-divided.

        Parameters
        ----------
        fill_param:
            Parameter determining the particle count per cell for the given layout.
        layout:
            Type of layout to use. Defaults to `SwarmPICLayout.REGULAR` for mesh objects with simplex
            type cells, and `SwarmPICLayout.GAUSS` otherwise.



        &#34;&#34;&#34;
        )

        self.fill_param = fill_param

        &#34;&#34;&#34;
        Currently (2021.11.15) supported by PETSc release 3.16.x
 
        When using a DMPLEX the following case are supported:
              (i) DMSWARMPIC_LAYOUT_REGULAR: 2D (triangle),
             (ii) DMSWARMPIC_LAYOUT_GAUSS: 2D and 3D provided the cell is a tri/tet or a quad/hex,
            (iii) DMSWARMPIC_LAYOUT_SUBDIVISION: 2D and 3D for quad/hex and 2D tri.

        So this means, simplex mesh in 3D only supports GAUSS 

        &#34;&#34;&#34;

        if layout == None:
            if self.mesh.isSimplex == True and self.dim == 2 and fill_param &gt; 1:
                layout = SwarmPICLayout.REGULAR
            else:
                layout = SwarmPICLayout.GAUSS

        if not isinstance(layout, SwarmPICLayout):
            raise ValueError(&#34;&#39;layout&#39; must be an instance of &#39;SwarmPICLayout&#39;&#34;)

        self.layout = layout
        self.dm.finalizeFieldRegister()

        ## Commenting this out for now.
        ## Code seems to operate fine without it, and the
        ## existing values are wrong. It should be something like
        ## `(elend-elstart)*fill_param^dim` for quads, and around
        ## half that for simplices, depending on layout.
        # elstart,elend = self.mesh.dm.getHeightStratum(0)
        # self.dm.setLocalSizes((elend-elstart) * fill_param, 0)

        self.dm.insertPointUsingCellDM(self.layout.value, fill_param)
        return  # self # LM: Is there any reason to return self ?

    @timing.routine_timer_decorator
    def add_variable(self, name, num_components=1, dtype=float, proxy_degree=2, _nn_proxy=False):
        return SwarmVariable(name, self, num_components, dtype=dtype, proxy_degree=proxy_degree, _nn_proxy=_nn_proxy)

    @property
    def vars(self):
        return self._vars

    def access(self, *writeable_vars: SwarmVariable):
        &#34;&#34;&#34;
        This context manager makes the underlying swarm variables data available to
        the user. The data should be accessed via the variables `data` handle.

        As default, all data is read-only. To enable writeable data, the user should
        specify which variable they wish to modify.

        At the conclusion of the users context managed block, numerous further operations
        will be automatically executed. This includes swarm parallel migration routines
        where the swarm&#39;s `particle_coordinates` variable has been modified. The swarm
        variable proxy mesh variables will also be updated for modifed swarm variables.

        Parameters
        ----------
        writeable_vars
            The variables for which data write access is required.

        Example
        -------

        &gt;&gt;&gt; import underworld3 as uw
        &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
        &gt;&gt;&gt; with someMesh.deform_mesh():
        ...     someMesh.data[0] = [0.1,0.1]
        &gt;&gt;&gt; someMesh.data[0]
        array([ 0.1,  0.1])
        &#34;&#34;&#34;
        import time

        uw.timing._incrementDepth()
        stime = time.time()

        deaccess_list = []
        for var in self.vars.values():
            # if already accessed within higher level context manager, continue.
            if var._is_accessed == True:
                continue
            # set flag so variable status can be known elsewhere
            var._is_accessed = True
            # add to de-access list to rewind this later
            deaccess_list.append(var)
            # grab numpy object, setting read only if necessary
            var._data = self.dm.getField(var.name).reshape((-1, var.num_components))
            if var not in writeable_vars:
                var._old_data_flag = var._data.flags.writeable
                var._data.flags.writeable = False
            else:
                # increment variable state
                var._increment()
        # if particles moving, update swarm state
        if self.particle_coordinates in writeable_vars:
            self._increment()

        # Create a class which specifies the required context
        # manager hooks (`__enter__`, `__exit__`).
        class exit_manager:
            def __init__(self, swarm):
                self.em_swarm = swarm

            def __enter__(self):
                pass

            def __exit__(self, *args):
                for var in self.em_swarm.vars.values():
                    # only de-access variables we have set access for.
                    if var not in deaccess_list:
                        continue
                    # set this back, although possibly not required.
                    if var not in writeable_vars:
                        var._data.flags.writeable = var._old_data_flag
                    var._data = None
                    self.em_swarm.dm.restoreField(var.name)
                    var._is_accessed = False
                # do particle migration if coords changes
                if self.em_swarm.particle_coordinates in writeable_vars:
                    # let&#39;s use the mesh index to update the particles owning cells.
                    # note that the `petsc4py` interface is more convenient here as the
                    # `SwarmVariable.data` interface is controlled by the context manager
                    # that we are currently within, and it is therefore too easy to
                    # get things wrong that way.
                    cellid = self.em_swarm.dm.getField(&#34;DMSwarm_cellid&#34;)
                    coords = self.em_swarm.dm.getField(&#34;DMSwarmPIC_coor&#34;).reshape((-1, self.em_swarm.dim))
                    cellid[:] = self.em_swarm.mesh.get_closest_cells(coords)
                    self.em_swarm.dm.restoreField(&#34;DMSwarmPIC_coor&#34;)
                    self.em_swarm.dm.restoreField(&#34;DMSwarm_cellid&#34;)
                    # now migrate.
                    self.em_swarm.dm.migrate(remove_sent_points=True)
                    # void these things too
                    self.em_swarm._index = None
                    self.em_swarm._nnmapdict = {}
                # do var updates
                for var in self.em_swarm.vars.values():
                    # if swarm migrated, update all.
                    # if var updated, update var.
                    if (self.em_swarm.particle_coordinates in writeable_vars) or (var in writeable_vars):
                        var._update()

                uw.timing._decrementDepth()
                uw.timing.log_result(time.time() - stime, &#34;Swarm.access&#34;, 1)

        return exit_manager(self)

    def _get_map(self, var):
        # generate tree if not avaiable
        if not self._index:
            with self.access():
                self._index = uw.kdtree.KDTree(self.data)

        # get or generate map
        meshvar_coords = var._meshVar.coords
        # we can&#39;t use numpy arrays directly as keys in python dicts, so
        # we&#39;ll use `xxhash` to generate a hash of array.
        # this shouldn&#39;t be an issue performance wise but we should test to be
        # sufficiently confident of this.
        import xxhash

        h = xxhash.xxh64()
        h.update(meshvar_coords)
        digest = h.intdigest()
        if digest not in self._nnmapdict:
            self._nnmapdict[digest] = self._index.find_closest_point(meshvar_coords)[0]
        return self._nnmapdict[digest]

    def advection(self, V_fn, delta_t, order=2, corrector=False, restore_points_to_domain_func=None):

        X0 = self._X0

        # Use current velocity to estimate where the particles would have
        # landed in an implicit step.

        # ? how does this interact with the particle restoration function ?

        V_fn_matrix = self.mesh.vector.to_matrix(V_fn)

        if corrector == True and not self._X0_uninitialised:
            with self.access(self.particle_coordinates):
                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                corrected_position = X0.data + delta_t * v_at_Vpts
                if restore_points_to_domain_func is not None:
                    corrected_position = restore_points_to_domain_func(corrected_position)

                updated_current_coords = 0.5 * (corrected_position + self.data)

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    updated_current_coords = restore_points_to_domain_func(updated_current_coords)

                self.data[...] = updated_current_coords

        with self.access(X0):
            X0.data[...] = self.data[...]
            self._X0_uninitialised = False

        # Mid point algorithm (2nd order)
        if order == 2:
            with self.access(self.particle_coordinates):

                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                mid_pt_coords = self.data[...] + 0.5 * delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    mid_pt_coords = restore_points_to_domain_func(mid_pt_coords)

                self.data[...] = mid_pt_coords

                # if (uw.mpi.rank == 0):
                #     print(&#34;Updated mid point position&#34;, flush=True)

                ## Let the swarm be updated, and then move the rest of the way

            with self.access(self.particle_coordinates):

                v_at_Vpts = np.zeros_like(self.data)

                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

                # if (uw.mpi.rank == 0):
                #     print(&#34;Re-launch from X0&#34;, flush=True)

                new_coords = X0.data[...] + delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)
                if restore_points_to_domain_func is not None:
                    new_coords = restore_points_to_domain_func(new_coords)

                # if (uw.mpi.rank == 0):
                #     print(&#34;Update&#34;, flush=True)

                self.data[...] = new_coords

        # Previous position algorithm (cf above) - we use the previous step as the
        # launch point using the current velocity field. This gives a correction to the previous
        # landing point.

        # assumes X0 is stored from the previous step ... midpoint is needed in the first step

        # forward Euler (1st order)
        else:
            with self.access(self.particle_coordinates):
                for d in range(self.dim):
                    v_at_Vpts[:, d] = uw.function.evaluate(V_fn[d], self.data).reshape(-1)

                new_coords = self.data + delta_t * v_at_Vpts

                # validate_coords to ensure they live within the domain (or there will be trouble)

                if restore_points_to_domain_func is not None:
                    new_coords = restore_points_to_domain_func(new_coords)

                self.data[...] = new_coords

        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.Stateful</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.swarm.Swarm.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.swarm.Swarm.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    return self.particle_coordinates.data</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.particle_cellid"><code class="name">var <span class="ident">particle_cellid</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def particle_cellid(self):
    return self._cellid_var</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.particle_coordinates"><code class="name">var <span class="ident">particle_coordinates</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def particle_coordinates(self):
    return self._coord_var</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.vars"><code class="name">var <span class="ident">vars</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self):
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.swarm.Swarm.access"><code class="name flex">
<span>def <span class="ident">access</span></span>(<span>self, *writeable_vars: <a title="underworld3.swarm.SwarmVariable" href="#underworld3.swarm.SwarmVariable">SwarmVariable</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This context manager makes the underlying swarm variables data available to
the user. The data should be accessed via the variables <code>data</code> handle.</p>
<p>As default, all data is read-only. To enable writeable data, the user should
specify which variable they wish to modify.</p>
<p>At the conclusion of the users context managed block, numerous further operations
will be automatically executed. This includes swarm parallel migration routines
where the swarm's <code>particle_coordinates</code> variable has been modified. The swarm
variable proxy mesh variables will also be updated for modifed swarm variables.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>writeable_vars</code></strong></dt>
<dd>The variables for which data write access is required.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; import underworld3 as uw
&gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
&gt;&gt;&gt; with someMesh.deform_mesh():
...     someMesh.data[0] = [0.1,0.1]
&gt;&gt;&gt; someMesh.data[0]
array([ 0.1,  0.1])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def access(self, *writeable_vars: SwarmVariable):
    &#34;&#34;&#34;
    This context manager makes the underlying swarm variables data available to
    the user. The data should be accessed via the variables `data` handle.

    As default, all data is read-only. To enable writeable data, the user should
    specify which variable they wish to modify.

    At the conclusion of the users context managed block, numerous further operations
    will be automatically executed. This includes swarm parallel migration routines
    where the swarm&#39;s `particle_coordinates` variable has been modified. The swarm
    variable proxy mesh variables will also be updated for modifed swarm variables.

    Parameters
    ----------
    writeable_vars
        The variables for which data write access is required.

    Example
    -------

    &gt;&gt;&gt; import underworld3 as uw
    &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
    &gt;&gt;&gt; with someMesh.deform_mesh():
    ...     someMesh.data[0] = [0.1,0.1]
    &gt;&gt;&gt; someMesh.data[0]
    array([ 0.1,  0.1])
    &#34;&#34;&#34;
    import time

    uw.timing._incrementDepth()
    stime = time.time()

    deaccess_list = []
    for var in self.vars.values():
        # if already accessed within higher level context manager, continue.
        if var._is_accessed == True:
            continue
        # set flag so variable status can be known elsewhere
        var._is_accessed = True
        # add to de-access list to rewind this later
        deaccess_list.append(var)
        # grab numpy object, setting read only if necessary
        var._data = self.dm.getField(var.name).reshape((-1, var.num_components))
        if var not in writeable_vars:
            var._old_data_flag = var._data.flags.writeable
            var._data.flags.writeable = False
        else:
            # increment variable state
            var._increment()
    # if particles moving, update swarm state
    if self.particle_coordinates in writeable_vars:
        self._increment()

    # Create a class which specifies the required context
    # manager hooks (`__enter__`, `__exit__`).
    class exit_manager:
        def __init__(self, swarm):
            self.em_swarm = swarm

        def __enter__(self):
            pass

        def __exit__(self, *args):
            for var in self.em_swarm.vars.values():
                # only de-access variables we have set access for.
                if var not in deaccess_list:
                    continue
                # set this back, although possibly not required.
                if var not in writeable_vars:
                    var._data.flags.writeable = var._old_data_flag
                var._data = None
                self.em_swarm.dm.restoreField(var.name)
                var._is_accessed = False
            # do particle migration if coords changes
            if self.em_swarm.particle_coordinates in writeable_vars:
                # let&#39;s use the mesh index to update the particles owning cells.
                # note that the `petsc4py` interface is more convenient here as the
                # `SwarmVariable.data` interface is controlled by the context manager
                # that we are currently within, and it is therefore too easy to
                # get things wrong that way.
                cellid = self.em_swarm.dm.getField(&#34;DMSwarm_cellid&#34;)
                coords = self.em_swarm.dm.getField(&#34;DMSwarmPIC_coor&#34;).reshape((-1, self.em_swarm.dim))
                cellid[:] = self.em_swarm.mesh.get_closest_cells(coords)
                self.em_swarm.dm.restoreField(&#34;DMSwarmPIC_coor&#34;)
                self.em_swarm.dm.restoreField(&#34;DMSwarm_cellid&#34;)
                # now migrate.
                self.em_swarm.dm.migrate(remove_sent_points=True)
                # void these things too
                self.em_swarm._index = None
                self.em_swarm._nnmapdict = {}
            # do var updates
            for var in self.em_swarm.vars.values():
                # if swarm migrated, update all.
                # if var updated, update var.
                if (self.em_swarm.particle_coordinates in writeable_vars) or (var in writeable_vars):
                    var._update()

            uw.timing._decrementDepth()
            uw.timing.log_result(time.time() - stime, &#34;Swarm.access&#34;, 1)

    return exit_manager(self)</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.add_variable"><code class="name flex">
<span>def <span class="ident">add_variable</span></span>(<span>self, name, num_components=1, dtype=builtins.float, proxy_degree=2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def add_variable(self, name, num_components=1, dtype=float, proxy_degree=2, _nn_proxy=False):
    return SwarmVariable(name, self, num_components, dtype=dtype, proxy_degree=proxy_degree, _nn_proxy=_nn_proxy)</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.advection"><code class="name flex">
<span>def <span class="ident">advection</span></span>(<span>self, V_fn, delta_t, order=2, corrector=False, restore_points_to_domain_func=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def advection(self, V_fn, delta_t, order=2, corrector=False, restore_points_to_domain_func=None):

    X0 = self._X0

    # Use current velocity to estimate where the particles would have
    # landed in an implicit step.

    # ? how does this interact with the particle restoration function ?

    V_fn_matrix = self.mesh.vector.to_matrix(V_fn)

    if corrector == True and not self._X0_uninitialised:
        with self.access(self.particle_coordinates):
            v_at_Vpts = np.zeros_like(self.data)

            for d in range(self.dim):
                v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

            corrected_position = X0.data + delta_t * v_at_Vpts
            if restore_points_to_domain_func is not None:
                corrected_position = restore_points_to_domain_func(corrected_position)

            updated_current_coords = 0.5 * (corrected_position + self.data)

            # validate_coords to ensure they live within the domain (or there will be trouble)

            if restore_points_to_domain_func is not None:
                updated_current_coords = restore_points_to_domain_func(updated_current_coords)

            self.data[...] = updated_current_coords

    with self.access(X0):
        X0.data[...] = self.data[...]
        self._X0_uninitialised = False

    # Mid point algorithm (2nd order)
    if order == 2:
        with self.access(self.particle_coordinates):

            v_at_Vpts = np.zeros_like(self.data)

            for d in range(self.dim):
                v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

            mid_pt_coords = self.data[...] + 0.5 * delta_t * v_at_Vpts

            # validate_coords to ensure they live within the domain (or there will be trouble)

            if restore_points_to_domain_func is not None:
                mid_pt_coords = restore_points_to_domain_func(mid_pt_coords)

            self.data[...] = mid_pt_coords

            # if (uw.mpi.rank == 0):
            #     print(&#34;Updated mid point position&#34;, flush=True)

            ## Let the swarm be updated, and then move the rest of the way

        with self.access(self.particle_coordinates):

            v_at_Vpts = np.zeros_like(self.data)

            for d in range(self.dim):
                v_at_Vpts[:, d] = uw.function.evaluate(V_fn_matrix[d], self.data).reshape(-1)

            # if (uw.mpi.rank == 0):
            #     print(&#34;Re-launch from X0&#34;, flush=True)

            new_coords = X0.data[...] + delta_t * v_at_Vpts

            # validate_coords to ensure they live within the domain (or there will be trouble)
            if restore_points_to_domain_func is not None:
                new_coords = restore_points_to_domain_func(new_coords)

            # if (uw.mpi.rank == 0):
            #     print(&#34;Update&#34;, flush=True)

            self.data[...] = new_coords

    # Previous position algorithm (cf above) - we use the previous step as the
    # launch point using the current velocity field. This gives a correction to the previous
    # landing point.

    # assumes X0 is stored from the previous step ... midpoint is needed in the first step

    # forward Euler (1st order)
    else:
        with self.access(self.particle_coordinates):
            for d in range(self.dim):
                v_at_Vpts[:, d] = uw.function.evaluate(V_fn[d], self.data).reshape(-1)

            new_coords = self.data + delta_t * v_at_Vpts

            # validate_coords to ensure they live within the domain (or there will be trouble)

            if restore_points_to_domain_func is not None:
                new_coords = restore_points_to_domain_func(new_coords)

            self.data[...] = new_coords

    return</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.Swarm.populate"><code class="name flex">
<span>def <span class="ident">populate</span></span>(<span>self, fill_param: Optional[int] = 3, layout: Optional[<a title="underworld3.swarm.SwarmPICLayout" href="#underworld3.swarm.SwarmPICLayout">SwarmPICLayout</a>] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def populate(
    self,
    fill_param: Optional[int] = 3,
    layout: Optional[SwarmPICLayout] = None,
):
    (
        &#34;&#34;&#34;
    Populate the swarm with particles throughout the domain.

    &#34;&#34;&#34;
        + SwarmPICLayout.__doc__
        + &#34;&#34;&#34;

    When using SwarmPICLayout.REGULAR,     `fill_param` defines the number of points in each spatial direction.
    When using SwarmPICLayout.GAUSS,       `fill_param` defines the number of quadrature points in each spatial direction.
    When using SwarmPICLayout.SUBDIVISION, `fill_param` defines the number times the reference cell is sub-divided.

    Parameters
    ----------
    fill_param:
        Parameter determining the particle count per cell for the given layout.
    layout:
        Type of layout to use. Defaults to `SwarmPICLayout.REGULAR` for mesh objects with simplex
        type cells, and `SwarmPICLayout.GAUSS` otherwise.



    &#34;&#34;&#34;
    )

    self.fill_param = fill_param

    &#34;&#34;&#34;
    Currently (2021.11.15) supported by PETSc release 3.16.x

    When using a DMPLEX the following case are supported:
          (i) DMSWARMPIC_LAYOUT_REGULAR: 2D (triangle),
         (ii) DMSWARMPIC_LAYOUT_GAUSS: 2D and 3D provided the cell is a tri/tet or a quad/hex,
        (iii) DMSWARMPIC_LAYOUT_SUBDIVISION: 2D and 3D for quad/hex and 2D tri.

    So this means, simplex mesh in 3D only supports GAUSS 

    &#34;&#34;&#34;

    if layout == None:
        if self.mesh.isSimplex == True and self.dim == 2 and fill_param &gt; 1:
            layout = SwarmPICLayout.REGULAR
        else:
            layout = SwarmPICLayout.GAUSS

    if not isinstance(layout, SwarmPICLayout):
        raise ValueError(&#34;&#39;layout&#39; must be an instance of &#39;SwarmPICLayout&#39;&#34;)

    self.layout = layout
    self.dm.finalizeFieldRegister()

    ## Commenting this out for now.
    ## Code seems to operate fine without it, and the
    ## existing values are wrong. It should be something like
    ## `(elend-elstart)*fill_param^dim` for quads, and around
    ## half that for simplices, depending on layout.
    # elstart,elend = self.mesh.dm.getHeightStratum(0)
    # self.dm.setLocalSizes((elend-elstart) * fill_param, 0)

    self.dm.insertPointUsingCellDM(self.layout.value, fill_param)
    return  # self # LM: Is there any reason to return self ?</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.swarm.SwarmPICLayout"><code class="flex name class">
<span>class <span class="ident">SwarmPICLayout</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Particle population fill type:</p>
<p>SwarmPICLayout.REGULAR
defines points on a regular ijk mesh. Supported by simplex cell types only.
SwarmPICLayout.GAUSS
defines points using an npoint Gauss-Legendre tensor product quadrature rule.
SwarmPICLayout.SUBDIVISION defines points on the centroid of a sub-divided reference cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwarmPICLayout(Enum):
    &#34;&#34;&#34;
    Particle population fill type:

    SwarmPICLayout.REGULAR     defines points on a regular ijk mesh. Supported by simplex cell types only.
    SwarmPICLayout.GAUSS       defines points using an npoint Gauss-Legendre tensor product quadrature rule.
    SwarmPICLayout.SUBDIVISION defines points on the centroid of a sub-divided reference cell.
    &#34;&#34;&#34;

    REGULAR = 0
    GAUSS = 1
    SUBDIVISION = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.swarm.SwarmPICLayout.GAUSS"><code class="name">var <span class="ident">GAUSS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.swarm.SwarmPICLayout.REGULAR"><code class="name">var <span class="ident">REGULAR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="underworld3.swarm.SwarmPICLayout.SUBDIVISION"><code class="name">var <span class="ident">SUBDIVISION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="underworld3.swarm.SwarmType"><code class="flex name class">
<span>class <span class="ident">SwarmType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwarmType(Enum):
    DMSWARM_PIC = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.swarm.SwarmType.DMSWARM_PIC"><code class="name">var <span class="ident">DMSWARM_PIC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="underworld3.swarm.SwarmVariable"><code class="flex name class">
<span>class <span class="ident">SwarmVariable</span></span>
<span>(</span><span>name, swarm, num_components, vtype=None, dtype=builtins.float, proxy_degree=1, proxy_continuous=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a mixin class for underworld objects that are stateful.
The state of an object is incremented whenever it is modified.
For example, heavy variables have states, and when a user modifies
it within its <code>access()</code> context manager, its state is incremented
at the conclusion of their modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwarmVariable(_api_tools.Stateful):
    @timing.routine_timer_decorator
    def __init__(
        self,
        name,
        swarm,
        num_components,
        vtype=None,
        dtype=float,
        proxy_degree=1,
        proxy_continuous=True,
        _register=True,
        _proxy=True,
        _nn_proxy=False,
    ):

        if name in swarm.vars.keys():
            raise ValueError(&#34;Variable with name {} already exists on swarm.&#34;.format(name))

        self.name = name
        self.swarm = swarm
        self.num_components = num_components

        if (dtype == float) or (dtype == &#34;float&#34;) or (dtype == np.float64):
            self.dtype = float
            petsc_type = PETSc.ScalarType
        elif (dtype == int) or (dtype == &#34;int&#34;) or (dtype == np.int32) or (dtype == np.int64):
            self.dtype = int
            petsc_type = PETSc.IntType
        else:
            raise TypeError(f&#34;Provided dtype={dtype} is not supported. Supported types are &#39;int&#39; and &#39;float&#39;.&#34;)

        if _register:
            self.swarm.dm.registerField(self.name, self.num_components, dtype=petsc_type)

        self._data = None
        # add to swarms dict
        swarm.vars[name] = self
        self._is_accessed = False

        # create proxy variable
        self._meshVar = None
        if _proxy:
            self.proxy_degree = proxy_degree
            self.proxy_continuous = proxy_continuous
            self._meshVar = uw.discretisation.MeshVariable(
                name, self.swarm.mesh, num_components, vtype, degree=proxy_degree, continuous=proxy_continuous
            )

        self._register = _register
        self._proxy = _proxy
        self._nn_proxy = _nn_proxy

        super().__init__()

    def _update(self):
        &#34;&#34;&#34;
        This method updates the proxy mesh variable for the current
        swarm &amp; particle variable state.

        Here is how it works:

            1) for each particle, create a distance-weighted average on the node data
            2) check to see which nodes have zero weight / zero contribution and replace with nearest particle value

        Todo: caching the k-d trees etc for the proxy-mesh-variable nodal points
        Todo: some form of global fall-back for when there are no particles on a processor

        &#34;&#34;&#34;

        # if not proxied, nothing to do. return.
        if not self._meshVar:
            return

        # 1 - Average particles to nodes with distance weighted average

        kd = uw.kdtree.KDTree(self._meshVar.coords)
        kd.build_index()

        with self.swarm.access():
            n, d, b = kd.find_closest_point(self.swarm.data)

            node_values = np.zeros((self._meshVar.coords.shape[0], self.num_components))
            w = np.zeros(self._meshVar.coords.shape[0])

            if not self._nn_proxy:
                for i in range(self.data.shape[0]):
                    if b[i]:
                        node_values[n[i], :] += self.data[i, :] / (1.0e-16 + d[i])
                        w[n[i]] += 1.0 / (1.0e-16 + d[i])

                node_values[np.where(w &gt; 0.0)[0], :] /= w[np.where(w &gt; 0.0)[0]].reshape(-1, 1)

        # 2 - set NN vals on mesh var where w == 0.0

        p_nnmap = self.swarm._get_map(self)

        with self.swarm.mesh.access(self._meshVar), self.swarm.access():
            self._meshVar.data[...] = node_values[...]
            self._meshVar.data[np.where(w == 0.0), :] = self.data[p_nnmap[np.where(w == 0.0)], :]

        return

    @timing.routine_timer_decorator
    def project_from(self, meshvar):
        # use method found in
        # /tmp/petsc-build/petsc/src/dm/impls/swarm/tests/ex2.c
        # to project from fields to particles

        self.swarm.mesh.dm.clearDS()
        self.swarm.mesh.dm.createDS()

        meshdm = meshvar.mesh.dm
        fields = meshvar.field_id
        _, meshvardm = meshdm.createSubDM(fields)

        ksp = PETSc.KSP().create()
        ksp.setOptionsPrefix(&#34;swarm_project_from_&#34;)
        options = PETSc.Options()
        options.setValue(&#34;swarm_project_from_ksp_type&#34;, &#34;lsqr&#34;)
        options.setValue(&#34;swarm_project_from_ksp_rtol&#34;, 1e-17)
        options.setValue(&#34;swarm_project_from_pc_type&#34;, &#34;none&#34;)
        ksp.setFromOptions()

        rhs = meshvardm.getGlobalVec()

        M_p = self.swarm.dm.createMassMatrix(meshvardm)

        # make particle weight vector
        f = self.swarm.createGlobalVectorFromField(self.name)

        # create matrix RHS vector, in this case the FEM field fhat with the coefficients vector #alpha
        M = meshvardm.createMassMatrix(meshvardm)
        with meshvar.mesh.access():
            M.multTranspose(meshvar.vec_global, rhs)

        ksp.setOperators(M_p, M_p)
        ksp.solveTranspose(rhs, f)

        self.swarm.dm.destroyGlobalVectorFromField(self.name)
        meshvardm.restoreGlobalVec(rhs)
        meshvardm.destroy()
        ksp.destroy()
        M.destroy()
        M_p.destroy()

    @property
    def data(self):
        if self._data is None:
            raise RuntimeError(&#34;Data must be accessed via the swarm `access()` context manager.&#34;)
        return self._data

    # @property
    # def fn(self):
    #     return self._meshVar.fn

    @property
    def sym(self):
        return self._meshVar.sym

    @timing.routine_timer_decorator
    def save(self, filename: str, name: Optional[str] = None, index: Optional[int] = None):
        &#34;&#34;&#34;
        Append variable data to the specified mesh
        checkpoint file. The file must already exist.

        For swarm data, we currently save the proxy
        variable (so this will fail if the variable has
        no proxy value). This allows some form of
        reconstruction of the information on a swarm
        even if it is not an exact mapping.

        This is not ideal for discontinuous fields.

        Parameters
        ----------
        filename :
            The filename of the mesh checkpoint file. It
            must already exist.
        name :
            Textual name for dataset. In particular, this
            will be used for XDMF generation. If not
            provided, the variable name will be used.
        index :
            Not currently supported. An optional index which
            might correspond to the timestep (for example).
        &#34;&#34;&#34;

        # if not proxied, nothing to do. return.
        if not self._meshVar:
            print(&#34;No proxy mesh variable that can be saved&#34;)
            return

        self._meshVar.save(filename, name, index)

        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.Stateful</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="underworld3.swarm.IndexSwarmVariable" href="#underworld3.swarm.IndexSwarmVariable">IndexSwarmVariable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.swarm.SwarmVariable.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self):
    if self._data is None:
        raise RuntimeError(&#34;Data must be accessed via the swarm `access()` context manager.&#34;)
    return self._data</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.SwarmVariable.sym"><code class="name">var <span class="ident">sym</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sym(self):
    return self._meshVar.sym</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.swarm.SwarmVariable.project_from"><code class="name flex">
<span>def <span class="ident">project_from</span></span>(<span>self, meshvar)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def project_from(self, meshvar):
    # use method found in
    # /tmp/petsc-build/petsc/src/dm/impls/swarm/tests/ex2.c
    # to project from fields to particles

    self.swarm.mesh.dm.clearDS()
    self.swarm.mesh.dm.createDS()

    meshdm = meshvar.mesh.dm
    fields = meshvar.field_id
    _, meshvardm = meshdm.createSubDM(fields)

    ksp = PETSc.KSP().create()
    ksp.setOptionsPrefix(&#34;swarm_project_from_&#34;)
    options = PETSc.Options()
    options.setValue(&#34;swarm_project_from_ksp_type&#34;, &#34;lsqr&#34;)
    options.setValue(&#34;swarm_project_from_ksp_rtol&#34;, 1e-17)
    options.setValue(&#34;swarm_project_from_pc_type&#34;, &#34;none&#34;)
    ksp.setFromOptions()

    rhs = meshvardm.getGlobalVec()

    M_p = self.swarm.dm.createMassMatrix(meshvardm)

    # make particle weight vector
    f = self.swarm.createGlobalVectorFromField(self.name)

    # create matrix RHS vector, in this case the FEM field fhat with the coefficients vector #alpha
    M = meshvardm.createMassMatrix(meshvardm)
    with meshvar.mesh.access():
        M.multTranspose(meshvar.vec_global, rhs)

    ksp.setOperators(M_p, M_p)
    ksp.solveTranspose(rhs, f)

    self.swarm.dm.destroyGlobalVectorFromField(self.name)
    meshvardm.restoreGlobalVec(rhs)
    meshvardm.destroy()
    ksp.destroy()
    M.destroy()
    M_p.destroy()</code></pre>
</details>
</dd>
<dt id="underworld3.swarm.SwarmVariable.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename: str, name: Optional[str] = None, index: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Append variable data to the specified mesh
checkpoint file. The file must already exist.</p>
<p>For swarm data, we currently save the proxy
variable (so this will fail if the variable has
no proxy value). This allows some form of
reconstruction of the information on a swarm
even if it is not an exact mapping.</p>
<p>This is not ideal for discontinuous fields.</p>
<h2 id="parameters">Parameters</h2>
<p>filename :
The filename of the mesh checkpoint file. It
must already exist.
name :
Textual name for dataset. In particular, this
will be used for XDMF generation. If not
provided, the variable name will be used.
index :
Not currently supported. An optional index which
might correspond to the timestep (for example).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def save(self, filename: str, name: Optional[str] = None, index: Optional[int] = None):
    &#34;&#34;&#34;
    Append variable data to the specified mesh
    checkpoint file. The file must already exist.

    For swarm data, we currently save the proxy
    variable (so this will fail if the variable has
    no proxy value). This allows some form of
    reconstruction of the information on a swarm
    even if it is not an exact mapping.

    This is not ideal for discontinuous fields.

    Parameters
    ----------
    filename :
        The filename of the mesh checkpoint file. It
        must already exist.
    name :
        Textual name for dataset. In particular, this
        will be used for XDMF generation. If not
        provided, the variable name will be used.
    index :
        Not currently supported. An optional index which
        might correspond to the timestep (for example).
    &#34;&#34;&#34;

    # if not proxied, nothing to do. return.
    if not self._meshVar:
        print(&#34;No proxy mesh variable that can be saved&#34;)
        return

    self._meshVar.save(filename, name, index)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3" href="index.html">underworld3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.swarm.IndexSwarmVariable" href="#underworld3.swarm.IndexSwarmVariable">IndexSwarmVariable</a></code></h4>
<ul class="">
<li><code><a title="underworld3.swarm.IndexSwarmVariable.sym" href="#underworld3.swarm.IndexSwarmVariable.sym">sym</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.swarm.Swarm" href="#underworld3.swarm.Swarm">Swarm</a></code></h4>
<ul class="">
<li><code><a title="underworld3.swarm.Swarm.access" href="#underworld3.swarm.Swarm.access">access</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.add_variable" href="#underworld3.swarm.Swarm.add_variable">add_variable</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.advection" href="#underworld3.swarm.Swarm.advection">advection</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.data" href="#underworld3.swarm.Swarm.data">data</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.instances" href="#underworld3.swarm.Swarm.instances">instances</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.particle_cellid" href="#underworld3.swarm.Swarm.particle_cellid">particle_cellid</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.particle_coordinates" href="#underworld3.swarm.Swarm.particle_coordinates">particle_coordinates</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.populate" href="#underworld3.swarm.Swarm.populate">populate</a></code></li>
<li><code><a title="underworld3.swarm.Swarm.vars" href="#underworld3.swarm.Swarm.vars">vars</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.swarm.SwarmPICLayout" href="#underworld3.swarm.SwarmPICLayout">SwarmPICLayout</a></code></h4>
<ul class="">
<li><code><a title="underworld3.swarm.SwarmPICLayout.GAUSS" href="#underworld3.swarm.SwarmPICLayout.GAUSS">GAUSS</a></code></li>
<li><code><a title="underworld3.swarm.SwarmPICLayout.REGULAR" href="#underworld3.swarm.SwarmPICLayout.REGULAR">REGULAR</a></code></li>
<li><code><a title="underworld3.swarm.SwarmPICLayout.SUBDIVISION" href="#underworld3.swarm.SwarmPICLayout.SUBDIVISION">SUBDIVISION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.swarm.SwarmType" href="#underworld3.swarm.SwarmType">SwarmType</a></code></h4>
<ul class="">
<li><code><a title="underworld3.swarm.SwarmType.DMSWARM_PIC" href="#underworld3.swarm.SwarmType.DMSWARM_PIC">DMSWARM_PIC</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.swarm.SwarmVariable" href="#underworld3.swarm.SwarmVariable">SwarmVariable</a></code></h4>
<ul class="">
<li><code><a title="underworld3.swarm.SwarmVariable.data" href="#underworld3.swarm.SwarmVariable.data">data</a></code></li>
<li><code><a title="underworld3.swarm.SwarmVariable.project_from" href="#underworld3.swarm.SwarmVariable.project_from">project_from</a></code></li>
<li><code><a title="underworld3.swarm.SwarmVariable.save" href="#underworld3.swarm.SwarmVariable.save">save</a></code></li>
<li><code><a title="underworld3.swarm.SwarmVariable.sym" href="#underworld3.swarm.SwarmVariable.sym">sym</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>