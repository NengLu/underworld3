<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>underworld3.meshing API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.meshing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional, Tuple
from enum import Enum

import tempfile
import numpy as np
from petsc4py import PETSc

from underworld3.discretisation import Mesh
from underworld3 import VarType
from underworld3.coordinates import CoordinateSystemType
import sympy


def UnstructuredSimplexBox(
    minCoords: Tuple = (0.0, 0.0),
    maxCoords: Tuple = (1.0, 1.0),
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    regular: bool = False,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    minCoord:
        Tuple specifying minimum mesh location.
    maxCoord:
        Tuple specifying maximum mesh location.

    regular option works in 2D but not (currently) in 3D

    &#34;&#34;&#34;

    boundaries = {
        &#34;Bottom&#34;: 11,
        &#34;Top&#34;: 12,
        &#34;Right&#34;: 13,
        &#34;Left&#34;: 14,
        &#34;Front&#34;: 15,
        &#34;Back&#34;: 16,
    }

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(1, [tag], tag)
            gmsh.model.set_physical_name(1, tag, name)

        gmsh.model.addPhysicalGroup(2, [surface], 99999)
        gmsh.model.setPhysicalName(2, 99999, &#34;Elements&#34;)

        if regular:
            gmsh.model.mesh.set_transfinite_surface(
                surface, cornerTags=[p1, p2, p3, p4]
            )

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin, meshSize=cellSize)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax, meshSize=cellSize)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax, meshSize=cellSize)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax, meshSize=cellSize)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], 99999)
        gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )


def StructuredQuadBox(
    elementRes: Optional[Tuple[int, int, int]] = (16, 16),
    minCoords: Optional[Tuple[float, float, float]] = None,
    maxCoords: Optional[Tuple[float, float, float]] = None,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    elementRes:
        Tuple specifying number of elements in each axis direction.
    minCoord:
        Optional. Tuple specifying minimum mesh location.
    maxCoord:
        Optional. Tuple specifying maximum mesh location.
    &#34;&#34;&#34;
    if minCoords == None:
        minCoords = len(elementRes) * (0.0,)
    if maxCoords == None:
        maxCoords = len(elementRes) * (1.0,)

    import gmsh

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, tag=1)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, tag=2)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, tag=3)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, tag=4)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        gmsh.model.add_physical_group(1, [l1], l1)
        gmsh.model.set_physical_name(1, l1, &#34;Bottom&#34;)
        gmsh.model.add_physical_group(1, [l2], l2)
        gmsh.model.set_physical_name(1, l2, &#34;Right&#34;)
        gmsh.model.add_physical_group(1, [l3], l3)
        gmsh.model.set_physical_name(1, l3, &#34;Top&#34;)
        gmsh.model.add_physical_group(1, [l4], l4)
        gmsh.model.set_physical_name(1, l4, &#34;Left&#34;)

        gmsh.model.add_physical_group(2, [surface], 99999)
        gmsh.model.set_physical_name(2, 99999, &#34;Elements&#34;)

        nx, ny = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            tag=l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=surface, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p3, p4]
        )
        gmsh.model.mesh.set_recombine(2, surface)

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        nx, ny, nz = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l5, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l6, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l7, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l8, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l9, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l10, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l11, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l12, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )

        gmsh.model.mesh.set_transfinite_surface(
            tag=bottom, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p4, p3]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=top, arrangement=&#34;Left&#34;, cornerTags=[p5, p6, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=front, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p6, p5]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=back, arrangement=&#34;Left&#34;, cornerTags=[p3, p4, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=right, arrangement=&#34;Left&#34;, cornerTags=[p2, p6, p8, p4]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=left, arrangement=&#34;Left&#34;, cornerTags=[p5, p1, p3, p7]
        )

        gmsh.model.mesh.set_recombine(2, front)
        gmsh.model.mesh.set_recombine(2, back)
        gmsh.model.mesh.set_recombine(2, bottom)
        gmsh.model.mesh.set_recombine(2, top)
        gmsh.model.mesh.set_recombine(2, right)
        gmsh.model.mesh.set_recombine(2, left)

        gmsh.model.mesh.set_transfinite_volume(
            volume, cornerTags=[p1, p2, p4, p3, p5, p6, p8, p7]
        )

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], 99999)
        gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)
    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )


def SphericalShell(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.1,
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 1}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Sphere&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    ball1_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusOuter)

    if radiusInner &gt; 0.0:
        ball2_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusInner)
        gmsh.model.occ.cut(
            [(3, ball1_tag)], [(3, ball2_tag)], removeObject=True, removeTool=True
        )

    gmsh.option.setNumber(&#34;Mesh.CharacteristicLengthMax&#34;, cellSize)
    gmsh.model.occ.synchronize()

    surfaces = gmsh.model.getEntities(2)
    volume = gmsh.model.getEntities(3)[0]

    if radiusInner &gt; 0.0:
        outerSurface, innerSurface = surfaces
        gmsh.model.addPhysicalGroup(
            innerSurface[0], [innerSurface[1]], boundaries[&#34;Lower&#34;]
        )
        gmsh.model.setPhysicalName(innerSurface[1], boundaries[&#34;Lower&#34;], &#34;Lower&#34;)
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], 99999)
        gmsh.model.setPhysicalName(volume[1], 99999, &#34;Elements&#34;)

    else:
        outerSurface = surfaces[0]
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], 99999)
        gmsh.model.setPhysicalName(volume[1], 99999, &#34;Elements&#34;)
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;])
        gmsh.model.setPhysicalName(0, vertices[&#34;Centre&#34;], &#34;Centre&#34;)

    gmsh.model.occ.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None
        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    # This seems not to work any longer ?? 3.17.4
    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )


def Annulus(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.1,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2, &#34;FixedStars&#34;: 3}

    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Annulus&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # l1 = gmsh.model.geo.add_line(p5, p4)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])

    loops = [cl2] + loops

    s = gmsh.model.geo.add_plane_surface(loops)
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(0, [p1], 2, s)
    # gmsh.model.mesh.embed(1, [l1], 2, s)

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(1, [c3, c4], boundaries[&#34;Upper&#34;], name=&#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )


def AnnulusFixedStars(
    radiusFixedStars: float = 1.5,
    radiusOuter: float = 1.0,
    radiusInner: float = 0.5,
    cellSize: float = 0.1,
    cellSize_FS: float = 0.2,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2, &#34;FixedStars&#34;: 3}
    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;AnnulusFS&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # Fixed Stars

    p6 = gmsh.model.geo.add_point(radiusFixedStars, 0.0, 0.0, meshSize=cellSize_FS)
    p7 = gmsh.model.geo.add_point(-radiusFixedStars, 0.0, 0.0, meshSize=cellSize_FS)

    c5 = gmsh.model.geo.add_circle_arc(p6, p1, p7)
    c6 = gmsh.model.geo.add_circle_arc(p7, p1, p6)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])
    cl3 = gmsh.model.geo.add_curve_loop([c5, c6], tag=boundaries[&#34;FixedStars&#34;])

    loops = [cl3] + loops

    s = gmsh.model.geo.add_plane_surface(loops)

    gmsh.model.geo.synchronize()

    if radiusInner == 0.0:
        gmsh.model.mesh.embed(0, [p1], 2, s)

    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(1, [c3, c4], 2, s)

    gmsh.model.geo.synchronize()

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(
        1,
        [c3, c4],
        boundaries[&#34;Upper&#34;],
        name=&#34;Upper&#34;,
    )
    gmsh.model.addPhysicalGroup(
        1,
        [c5, c6],
        boundaries[&#34;FixedStars&#34;],
        name=&#34;FixedStars&#34;,
    )

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )


def CubedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    numElements: int = 5,
    degree: int = 1,
    qdegree: int = 2,
    simplex: bool = False,
    filename=None,
):

    &#34;&#34;&#34;Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
    The number of elements is the edge of each cube&#34;&#34;&#34;

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    r1 = radiusInner / np.sqrt(3)
    r2 = radiusOuter / np.sqrt(3)

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.option.setNumber(&#34;Mesh.Algorithm3D&#34;, 4)
    gmsh.model.add(&#34;Cubed Sphere&#34;)

    center_point = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=1)

    gmsh.model.geo.addPoint(r2, r2, -r2, tag=2)
    gmsh.model.geo.addPoint(-r2, r2, -r2, tag=3)
    gmsh.model.geo.addPoint(-r2, -r2, -r2, tag=4)
    gmsh.model.geo.addPoint(r2, -r2, -r2, tag=5)

    gmsh.model.geo.addCircleArc(3, 1, 2, tag=1)
    gmsh.model.geo.addCircleArc(2, 1, 5, tag=2)
    gmsh.model.geo.addCircleArc(5, 1, 4, tag=3)
    gmsh.model.geo.addCircleArc(4, 1, 3, tag=4)

    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], tag=1)
    gmsh.model.geo.addSurfaceFilling([1], tag=1, sphereCenterTag=1)

    gmsh.model.geo.addPoint(r1, r1, -r1, tag=6)
    gmsh.model.geo.addPoint(-r1, r1, -r1, tag=7)
    gmsh.model.geo.addPoint(-r1, -r1, -r1, tag=8)
    gmsh.model.geo.addPoint(r1, -r1, -r1, tag=9)

    gmsh.model.geo.addCircleArc(7, 1, 6, tag=5)
    gmsh.model.geo.addCircleArc(6, 1, 9, tag=6)
    gmsh.model.geo.addCircleArc(9, 1, 8, tag=7)
    gmsh.model.geo.addCircleArc(8, 1, 7, tag=8)

    gmsh.model.geo.addCurveLoop([5, 6, 7, 8], tag=2)
    gmsh.model.geo.addSurfaceFilling([2], tag=2, sphereCenterTag=1)

    gmsh.model.geo.addLine(2, 6, tag=9)
    gmsh.model.geo.addLine(3, 7, tag=10)
    gmsh.model.geo.addLine(5, 9, tag=11)
    gmsh.model.geo.addLine(4, 8, tag=12)

    gmsh.model.geo.addCurveLoop([3, 12, -7, -11], tag=3)
    gmsh.model.geo.addSurfaceFilling([3], tag=3)

    gmsh.model.geo.addCurveLoop([10, 5, -9, -1], tag=4)
    gmsh.model.geo.addSurfaceFilling([4], tag=4)

    gmsh.model.geo.addCurveLoop([9, 6, -11, -2], tag=5)
    gmsh.model.geo.addSurfaceFilling([5], tag=5)

    gmsh.model.geo.addCurveLoop([12, 8, -10, -4], tag=6)
    gmsh.model.geo.addSurfaceFilling([6], tag=6)

    gmsh.model.geo.addSurfaceLoop([2, 4, 6, 3, 1, 5], tag=1)
    gmsh.model.geo.addVolume([1], tag=1)

    # Make copies
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 3.0 * np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -np.pi / 2.0
    )

    gmsh.model.geo.synchronize()

    gmsh.model.addPhysicalGroup(2, [1, 34, 61, 88, 115, 137], boundaries[&#34;Upper&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
    gmsh.model.addPhysicalGroup(2, [2, 14, 41, 68, 95, 117], boundaries[&#34;Lower&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Lower&#34;], &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, [1, 13, 40, 67, 94, 116], 99999)
    gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    for _, line in gmsh.model.get_entities(1):
        gmsh.model.mesh.setTransfiniteCurve(line, numNodes=numElements + 1)

    for _, surface in gmsh.model.get_entities(2):
        gmsh.model.mesh.setTransfiniteSurface(surface)
        if not simplex:
            gmsh.model.mesh.set_recombine(2, surface)

    if not simplex:
        for _, volume in gmsh.model.get_entities(3):
            gmsh.model.mesh.set_transfinite_volume(volume)
            # if not simplex:
            gmsh.model.mesh.set_recombine(3, volume)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )


def SegmentedSphericalSurface2D(
    radius: float = 1.0,
    cellSize: float = 0.05,
    numSegments: int = 6,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    import gmsh
    import underworld3 as uw

    options = PETSc.Options()
    options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
    options[&#34;dm_plex_gmsh_spacedim&#34;] = 2
    options[&#34;dm_plex_gmsh_use_regions&#34;] = None
    options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Segmented Sphere 2D Surface&#34;)

    # Mesh like an orange

    num_segments = numSegments
    meshRes = cellSize

    surflist = []
    longitudesN = []
    longitudesS = []
    segments_clps = []
    segments_surfs = []
    equator_pts = []

    centre = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=-1)
    poleN = gmsh.model.geo.addPoint(0.0, 0.0, 1.0, tag=-1, meshSize=0.5 * meshRes)
    poleS = gmsh.model.geo.addPoint(0.0, 0.0, -1.0, tag=-1, meshSize=0.5 * meshRes)

    dtheta = 2 * np.pi / num_segments

    for i in range(num_segments):
        theta = i * 2 * np.pi / num_segments
        x1 = np.cos(theta)
        y1 = np.sin(theta)
        equator_pts.append(
            gmsh.model.geo.addPoint(x1, y1, 0.0, tag=-1, meshSize=meshRes)
        )

    for i in range(num_segments):
        pEq = equator_pts[i]
        longitudesN.append(gmsh.model.geo.addCircleArc(poleN, centre, pEq, tag=-1))
        longitudesS.append(gmsh.model.geo.addCircleArc(pEq, centre, poleS, tag=-1))

    gmsh.model.geo.synchronize()

    # Curve loops:

    for i in range(num_segments):
        loops = [
            longitudesN[i],
            longitudesS[i],
            longitudesS[np.mod(i + 1, num_segments)],
            longitudesN[np.mod(i + 1, num_segments)],
        ]
        segments_clps.append(
            gmsh.model.geo.addCurveLoop(loops[::-1], tag=-1, reorient=True)
        )

    gmsh.model.geo.synchronize()

    # Surfaces

    for i in range(num_segments):
        segments_surfs.append(
            gmsh.model.geo.addSurfaceFilling(
                [segments_clps[i]], tag=-1, sphereCenterTag=centre
            )
        )

    gmsh.model.geo.synchronize()

    # Add some physical labels etc.

    gmsh.model.addPhysicalGroup(0, [poleN], 1000)
    gmsh.model.addPhysicalGroup(0, [poleS], 2000)
    gmsh.model.addPhysicalGroup(0, [poleN, poleS], 3000)
    gmsh.model.setPhysicalName(0, 1000, &#34;NPole&#34;)
    gmsh.model.setPhysicalName(0, 2000, &#34;SPole&#34;)
    gmsh.model.setPhysicalName(0, 3000, &#34;Poles&#34;)

    gmsh.model.addPhysicalGroup(2, segments_surfs, 10000)
    gmsh.model.setPhysicalName(2, 10000, &#34;Elements&#34;)

    gmsh.model.mesh.remove_duplicate_nodes()
    gmsh.model.remove_entities([(0, centre)])

    # Generate Mesh
    gmsh.model.mesh.generate(2)

    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        plex = PETSc.DMPlex().createFromFile(fp.name)

    # xyz coordinates of the mesh
    xyz = gmsh.model.mesh.get_nodes()[1].reshape(-1, 3)  # [1::, :]

    # Re-interpret the DM coordinates
    lonlat_vec = plex.getCoordinates()
    lonlat = np.empty_like(xyz[:, 0:2])
    lonlat[:, 0] = np.mod(np.arctan2(xyz[:, 1], xyz[:, 0]), 2.0 * np.pi) - np.pi
    lonlat[:, 1] = np.arcsin(xyz[:, 2])
    lonlat_vec.array[...] = lonlat.reshape(-1)
    plex.setCoordinates(lonlat_vec)

    # This mesh will always be periodic in the longitudinal coordinate

    uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
        plex, [np.pi, 0.0], [-np.pi, 0.0], [np.pi * 2, 0.0]
    )

    gmsh.finalize()

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERE_SURFACE_NATIVE,
        filename=filename,
    )


def SegmentedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.05,
    numSegments: int = 6,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
    coordinatesNative=False,
):

    if coordinatesNative == True:
        coordinate_system = CoordinateSystemType.SPHERICAL_NATIVE
    else:
        coordinate_system = CoordinateSystemType.SPHERICAL

    import gmsh
    import underworld3 as uw

    options = PETSc.Options()
    options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
    # options[&#34;dm_plex_gmsh_spacedim&#34;] = 2
    options[&#34;dm_plex_gmsh_use_regions&#34;] = None
    options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

    ## Follow the lead of the cubed sphere and make copies of a segment

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 2)
    gmsh.option.setNumber(&#34;Mesh.Algorithm3D&#34;, 4)
    gmsh.model.add(&#34;Segmented Sphere 3D&#34;)

    meshRes = cellSize
    num_segments = numSegments

    centre = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=-1)

    poleNo = gmsh.model.geo.addPoint(0.0, 0.0, radiusOuter, tag=-1, meshSize=meshRes)
    poleSo = gmsh.model.geo.addPoint(0.0, 0.0, -radiusOuter, tag=-1, meshSize=meshRes)
    poleNi = gmsh.model.geo.addPoint(0.0, 0.0, radiusInner, tag=-1, meshSize=meshRes)
    poleSi = gmsh.model.geo.addPoint(0.0, 0.0, -radiusInner, tag=-1, meshSize=meshRes)

    dtheta = 2 * np.pi / num_segments

    r = radiusOuter
    equator_pts_0o = gmsh.model.geo.addPoint(r, 0.0, 0.0, tag=-1, meshSize=meshRes)
    equator_pts_1o = gmsh.model.geo.addPoint(
        r * np.cos(dtheta), r * np.sin(dtheta), 0.0, tag=-1, meshSize=meshRes
    )
    r = radiusInner
    equator_pts_0i = gmsh.model.geo.addPoint(r, 0.0, 0.0, tag=-1, meshSize=meshRes)
    equator_pts_1i = gmsh.model.geo.addPoint(
        r * np.cos(dtheta), r * np.sin(dtheta), 0.0, tag=-1, meshSize=meshRes
    )

    gmsh.model.geo.synchronize()

    # Make edges

    edgeWo = gmsh.model.geo.addCircleArc(poleNo, centre, equator_pts_0o, tag=-1)
    edgeEqo = gmsh.model.geo.addCircleArc(
        equator_pts_0o, centre, equator_pts_1o, tag=-1
    )
    edgeEo = gmsh.model.geo.addCircleArc(equator_pts_1o, centre, poleNo, tag=-1)

    edgeWi = gmsh.model.geo.addCircleArc(poleNi, centre, equator_pts_0i, tag=-1)
    edgeEqi = gmsh.model.geo.addCircleArc(
        equator_pts_0i, centre, equator_pts_1i, tag=-1
    )
    edgeEi = gmsh.model.geo.addCircleArc(equator_pts_1i, centre, poleNi, tag=-1)

    ## Struts

    radialW = gmsh.model.geo.addLine(equator_pts_0o, equator_pts_0i, tag=-1)
    radialE = gmsh.model.geo.addLine(equator_pts_1o, equator_pts_1i, tag=-1)
    radialN = gmsh.model.geo.addLine(poleNo, poleNi, tag=-1)

    # Make boundaries

    faceLoopo = gmsh.model.geo.addCurveLoop(
        [edgeWo, edgeEqo, edgeEo], tag=-1, reorient=True
    )
    faceLoopi = gmsh.model.geo.addCurveLoop(
        [edgeWi, edgeEqi, edgeEi], tag=-1, reorient=True
    )
    faceLoopW = gmsh.model.geo.addCurveLoop(
        [edgeWo, radialW, edgeWi, radialN], tag=-1, reorient=True
    )
    faceLoopE = gmsh.model.geo.addCurveLoop(
        [edgeEo, radialE, edgeEi, radialN], tag=-1, reorient=True
    )
    faceLoopS = gmsh.model.geo.addCurveLoop(
        [edgeEqo, radialW, edgeEqi, radialE], tag=-1, reorient=True
    )

    # Make surfaces

    face_o = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopo,
        ],
        tag=-1,
        sphereCenterTag=centre,
    )
    face_i = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopi,
        ],
        tag=-1,
        sphereCenterTag=centre,
    )
    face_W = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopW,
        ],
        tag=-1,
    )
    face_E = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopE,
        ],
        tag=-1,
    )
    face_S = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopS,
        ],
        tag=-1,
    )

    outer_faces = [face_o]
    inner_faces = [face_i]

    # Make volume

    wedge_surf = gmsh.model.geo.addSurfaceLoop(
        [face_o, face_i, face_W, face_E, face_S], tag=-1
    )
    wedge_vol = gmsh.model.geo.addVolume([wedge_surf], tag=-1)
    wedges = [wedge_vol]

    gmsh.model.geo.synchronize()

    # Make copies

    for i in range(1, num_segments):

        new_wedge = gmsh.model.geo.copy([(3, 1)])
        gmsh.model.geo.rotate(new_wedge, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, i * dtheta)

        gmsh.model.geo.synchronize()

        _, new_faces = gmsh.model.get_adjacencies(3, new_wedge[0][1])

        wedges.append(new_wedge[0][1])
        outer_faces.append(new_faces[0])
        inner_faces.append(new_faces[1])

    mirror_wedge = gmsh.model.geo.copy([(3, 1)])
    gmsh.model.geo.mirror(mirror_wedge, 0.0, 0.0, 1.0, 0.0)

    gmsh.model.geo.synchronize()
    _, mirror_faces = gmsh.model.get_adjacencies(3, mirror_wedge[0][1])
    wedges.append(mirror_wedge[0][1])
    outer_faces.append(mirror_faces[0])
    inner_faces.append(mirror_faces[1])

    _, mirror_edges_w = gmsh.model.get_adjacencies(2, mirror_faces[2])
    _, mirror_edges_e = gmsh.model.get_adjacencies(2, mirror_faces[3])

    radialS = tuple(set(mirror_edges_e).intersection(set(mirror_edges_w)))[0]

    for i in range(1, num_segments):

        new_wedge = gmsh.model.geo.copy(mirror_wedge)
        gmsh.model.geo.rotate(new_wedge, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, i * dtheta)

        gmsh.model.geo.synchronize()

        _, new_faces = gmsh.model.get_adjacencies(3, new_wedge[0][1])

        wedges.append(new_wedge[0][1])
        outer_faces.append(new_faces[0])
        inner_faces.append(new_faces[1])

    gmsh.model.addPhysicalGroup(0, [poleNo], 1)
    gmsh.model.setPhysicalName(0, 1, &#34;PolePtNo&#34;)

    gmsh.model.addPhysicalGroup(0, [poleNi], 2)
    gmsh.model.setPhysicalName(0, 2, &#34;PolePtNi&#34;)

    gmsh.model.addPhysicalGroup(0, [poleSo], 3)
    gmsh.model.setPhysicalName(0, 3, &#34;PolePtSo&#34;)

    gmsh.model.addPhysicalGroup(0, [poleSi], 4)
    gmsh.model.setPhysicalName(0, 4, &#34;PolePtSi&#34;)

    gmsh.model.addPhysicalGroup(1, [radialN], 10)
    gmsh.model.setPhysicalName(1, 10, &#34;PoleAxisN&#34;)

    gmsh.model.addPhysicalGroup(1, [radialS], 11)
    gmsh.model.setPhysicalName(1, 11, &#34;PoleAxisS&#34;)

    gmsh.model.addPhysicalGroup(2, outer_faces, 20)
    gmsh.model.setPhysicalName(2, 20, &#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, inner_faces, 21)
    gmsh.model.setPhysicalName(2, 21, &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, wedges, 30)
    gmsh.model.setPhysicalName(3, 30, &#34;Elements&#34;)

    gmsh.model.remove_entities([(0, centre)])

    gmsh.model.mesh.generate(3)

    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        plex = PETSc.DMPlex().createFromFile(fp.name)
        # plex = PETSc.DMPlex().createFromFile(filename)

    gmsh.finalize()

    ## This is the lat lon version that I can&#39;t quite seem to get right
    ## in the vector calculus section

    # if coordinatesNative:
    #     xyz_vec = plex.getCoordinates()
    #     xyz = xyz_vec.array.reshape(-1, 3)

    #     rl1l2 = np.empty_like(xyz)
    #     rl1l2[:, 0] = np.sqrt(xyz[:, 0] ** 2 + xyz[:, 1] ** 2 + xyz[:, 2] ** 2)
    #     rl1l2[:, 1] = np.arctan2(xyz[:, 1], xyz[:, 0] + 1.0e-16) - np.pi
    #     rl1l2[:, 2] = np.arcsin((xyz[:, 2] + 1.0e-16) / (rl1l2[:, 0] + 1.0e-16))

    #     rl1l2_vec = xyz_vec.copy()
    #     rl1l2_vec.array[...] = rl1l2.reshape(-1)[...]
    #     plex.setCoordinates(rl1l2_vec)

    #     uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
    #         plex, [0.0, np.pi, 0.0], [0.0, -np.pi, 0.0], [0.0, np.pi * 2, 0.0]
    #     )

    if coordinatesNative:
        xyz_vec = plex.getCoordinates()
        xyz = xyz_vec.array.reshape(-1, 3)

        rthph = np.empty_like(xyz)
        rthph[:, 0] = np.sqrt(xyz[:, 0] ** 2 + xyz[:, 1] ** 2 + xyz[:, 2] ** 2)
        rthph[:, 1] = np.arccos((xyz[:, 2]) / (rthph[:, 0] + 1.0e-6))
        rthph[:, 2] = np.arctan2(xyz[:, 1], xyz[:, 0] + 1.0e-6) - np.pi

        rthph_vec = xyz_vec.copy()
        rthph_vec.array[...] = rthph.reshape(-1)[...]
        plex.setCoordinates(rthph_vec)

        uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
            plex, [0.0, 0.0, np.pi], [0.0, 0.0, -np.pi], [0.0, 0.0, np.pi * 2]
        )

    return Mesh(
        plex,
        simplex=True,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=coordinate_system,
        filename=filename,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="underworld3.meshing.Annulus"><code class="name flex">
<span>def <span class="ident">Annulus</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.3, cellSize: float = 0.1, centre: bool = False, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Annulus(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.1,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2, &#34;FixedStars&#34;: 3}

    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Annulus&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # l1 = gmsh.model.geo.add_line(p5, p4)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])

    loops = [cl2] + loops

    s = gmsh.model.geo.add_plane_surface(loops)
    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(0, [p1], 2, s)
    # gmsh.model.mesh.embed(1, [l1], 2, s)

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(1, [c3, c4], boundaries[&#34;Upper&#34;], name=&#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.AnnulusFixedStars"><code class="name flex">
<span>def <span class="ident">AnnulusFixedStars</span></span>(<span>radiusFixedStars: float = 1.5, radiusOuter: float = 1.0, radiusInner: float = 0.5, cellSize: float = 0.1, cellSize_FS: float = 0.2, centre: bool = False, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AnnulusFixedStars(
    radiusFixedStars: float = 1.5,
    radiusOuter: float = 1.0,
    radiusInner: float = 0.5,
    cellSize: float = 0.1,
    cellSize_FS: float = 0.2,
    centre: bool = False,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2, &#34;FixedStars&#34;: 3}
    vertices = {&#34;Centre&#34;: 10}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;AnnulusFS&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    loops = []

    if radiusInner &gt; 0.0:
        p2 = gmsh.model.geo.add_point(radiusInner, 0.0, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(-radiusInner, 0.0, 0.0, meshSize=cellSize)

        c1 = gmsh.model.geo.add_circle_arc(p2, p1, p3)
        c2 = gmsh.model.geo.add_circle_arc(p3, p1, p2)

        cl1 = gmsh.model.geo.add_curve_loop([c1, c2], tag=boundaries[&#34;Lower&#34;])

        loops = [cl1] + loops

    p4 = gmsh.model.geo.add_point(radiusOuter, 0.0, 0.0, meshSize=cellSize)
    p5 = gmsh.model.geo.add_point(-radiusOuter, 0.0, 0.0, meshSize=cellSize)

    c3 = gmsh.model.geo.add_circle_arc(p4, p1, p5)
    c4 = gmsh.model.geo.add_circle_arc(p5, p1, p4)

    # Fixed Stars

    p6 = gmsh.model.geo.add_point(radiusFixedStars, 0.0, 0.0, meshSize=cellSize_FS)
    p7 = gmsh.model.geo.add_point(-radiusFixedStars, 0.0, 0.0, meshSize=cellSize_FS)

    c5 = gmsh.model.geo.add_circle_arc(p6, p1, p7)
    c6 = gmsh.model.geo.add_circle_arc(p7, p1, p6)

    cl2 = gmsh.model.geo.add_curve_loop([c3, c4], tag=boundaries[&#34;Upper&#34;])
    cl3 = gmsh.model.geo.add_curve_loop([c5, c6], tag=boundaries[&#34;FixedStars&#34;])

    loops = [cl3] + loops

    s = gmsh.model.geo.add_plane_surface(loops)

    gmsh.model.geo.synchronize()

    if radiusInner == 0.0:
        gmsh.model.mesh.embed(0, [p1], 2, s)

    gmsh.model.geo.synchronize()
    gmsh.model.mesh.embed(1, [c3, c4], 2, s)

    gmsh.model.geo.synchronize()

    if radiusInner &gt; 0.0:
        gmsh.model.addPhysicalGroup(1, [c1, c2], boundaries[&#34;Lower&#34;], name=&#34;Lower&#34;)
    else:
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;], name=&#34;Centre&#34;)

    gmsh.model.addPhysicalGroup(
        1,
        [c3, c4],
        boundaries[&#34;Upper&#34;],
        name=&#34;Upper&#34;,
    )
    gmsh.model.addPhysicalGroup(
        1,
        [c5, c6],
        boundaries[&#34;FixedStars&#34;],
        name=&#34;FixedStars&#34;,
    )

    gmsh.model.addPhysicalGroup(2, [s], 666666, &#34;Elements&#34;)

    gmsh.model.geo.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(2)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CYLINDRICAL2D,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.CubedSphere"><code class="name flex">
<span>def <span class="ident">CubedSphere</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.3, numElements: int = 5, degree: int = 1, qdegree: int = 2, simplex: bool = False, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
The number of elements is the edge of each cube</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CubedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    numElements: int = 5,
    degree: int = 1,
    qdegree: int = 2,
    simplex: bool = False,
    filename=None,
):

    &#34;&#34;&#34;Cubed Sphere mesh in hexahedra (which can be left uncombined to produce a simplex-based mesh
    The number of elements is the edge of each cube&#34;&#34;&#34;

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    r1 = radiusInner / np.sqrt(3)
    r2 = radiusOuter / np.sqrt(3)

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.option.setNumber(&#34;Mesh.Algorithm3D&#34;, 4)
    gmsh.model.add(&#34;Cubed Sphere&#34;)

    center_point = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=1)

    gmsh.model.geo.addPoint(r2, r2, -r2, tag=2)
    gmsh.model.geo.addPoint(-r2, r2, -r2, tag=3)
    gmsh.model.geo.addPoint(-r2, -r2, -r2, tag=4)
    gmsh.model.geo.addPoint(r2, -r2, -r2, tag=5)

    gmsh.model.geo.addCircleArc(3, 1, 2, tag=1)
    gmsh.model.geo.addCircleArc(2, 1, 5, tag=2)
    gmsh.model.geo.addCircleArc(5, 1, 4, tag=3)
    gmsh.model.geo.addCircleArc(4, 1, 3, tag=4)

    gmsh.model.geo.addCurveLoop([1, 2, 3, 4], tag=1)
    gmsh.model.geo.addSurfaceFilling([1], tag=1, sphereCenterTag=1)

    gmsh.model.geo.addPoint(r1, r1, -r1, tag=6)
    gmsh.model.geo.addPoint(-r1, r1, -r1, tag=7)
    gmsh.model.geo.addPoint(-r1, -r1, -r1, tag=8)
    gmsh.model.geo.addPoint(r1, -r1, -r1, tag=9)

    gmsh.model.geo.addCircleArc(7, 1, 6, tag=5)
    gmsh.model.geo.addCircleArc(6, 1, 9, tag=6)
    gmsh.model.geo.addCircleArc(9, 1, 8, tag=7)
    gmsh.model.geo.addCircleArc(8, 1, 7, tag=8)

    gmsh.model.geo.addCurveLoop([5, 6, 7, 8], tag=2)
    gmsh.model.geo.addSurfaceFilling([2], tag=2, sphereCenterTag=1)

    gmsh.model.geo.addLine(2, 6, tag=9)
    gmsh.model.geo.addLine(3, 7, tag=10)
    gmsh.model.geo.addLine(5, 9, tag=11)
    gmsh.model.geo.addLine(4, 8, tag=12)

    gmsh.model.geo.addCurveLoop([3, 12, -7, -11], tag=3)
    gmsh.model.geo.addSurfaceFilling([3], tag=3)

    gmsh.model.geo.addCurveLoop([10, 5, -9, -1], tag=4)
    gmsh.model.geo.addSurfaceFilling([4], tag=4)

    gmsh.model.geo.addCurveLoop([9, 6, -11, -2], tag=5)
    gmsh.model.geo.addSurfaceFilling([5], tag=5)

    gmsh.model.geo.addCurveLoop([12, 8, -10, -4], tag=6)
    gmsh.model.geo.addSurfaceFilling([6], tag=6)

    gmsh.model.geo.addSurfaceLoop([2, 4, 6, 3, 1, 5], tag=1)
    gmsh.model.geo.addVolume([1], tag=1)

    # Make copies
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, np.pi
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 3.0 * np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, np.pi / 2.0
    )
    gmsh.model.geo.rotate(
        gmsh.model.geo.copy([(3, 1)]), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -np.pi / 2.0
    )

    gmsh.model.geo.synchronize()

    gmsh.model.addPhysicalGroup(2, [1, 34, 61, 88, 115, 137], boundaries[&#34;Upper&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
    gmsh.model.addPhysicalGroup(2, [2, 14, 41, 68, 95, 117], boundaries[&#34;Lower&#34;])
    gmsh.model.setPhysicalName(2, boundaries[&#34;Lower&#34;], &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, [1, 13, 40, 67, 94, 116], 99999)
    gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    for _, line in gmsh.model.get_entities(1):
        gmsh.model.mesh.setTransfiniteCurve(line, numNodes=numElements + 1)

    for _, surface in gmsh.model.get_entities(2):
        gmsh.model.mesh.setTransfiniteSurface(surface)
        if not simplex:
            gmsh.model.mesh.set_recombine(2, surface)

    if not simplex:
        for _, volume in gmsh.model.get_entities(3):
            gmsh.model.mesh.set_transfinite_volume(volume)
            # if not simplex:
            gmsh.model.mesh.set_recombine(3, volume)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()
        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.SegmentedSphere"><code class="name flex">
<span>def <span class="ident">SegmentedSphere</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.3, cellSize: float = 0.05, numSegments: int = 6, degree: int = 1, qdegree: int = 2, filename=None, coordinatesNative=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SegmentedSphere(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.3,
    cellSize: float = 0.05,
    numSegments: int = 6,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
    coordinatesNative=False,
):

    if coordinatesNative == True:
        coordinate_system = CoordinateSystemType.SPHERICAL_NATIVE
    else:
        coordinate_system = CoordinateSystemType.SPHERICAL

    import gmsh
    import underworld3 as uw

    options = PETSc.Options()
    options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
    # options[&#34;dm_plex_gmsh_spacedim&#34;] = 2
    options[&#34;dm_plex_gmsh_use_regions&#34;] = None
    options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

    ## Follow the lead of the cubed sphere and make copies of a segment

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 2)
    gmsh.option.setNumber(&#34;Mesh.Algorithm3D&#34;, 4)
    gmsh.model.add(&#34;Segmented Sphere 3D&#34;)

    meshRes = cellSize
    num_segments = numSegments

    centre = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=-1)

    poleNo = gmsh.model.geo.addPoint(0.0, 0.0, radiusOuter, tag=-1, meshSize=meshRes)
    poleSo = gmsh.model.geo.addPoint(0.0, 0.0, -radiusOuter, tag=-1, meshSize=meshRes)
    poleNi = gmsh.model.geo.addPoint(0.0, 0.0, radiusInner, tag=-1, meshSize=meshRes)
    poleSi = gmsh.model.geo.addPoint(0.0, 0.0, -radiusInner, tag=-1, meshSize=meshRes)

    dtheta = 2 * np.pi / num_segments

    r = radiusOuter
    equator_pts_0o = gmsh.model.geo.addPoint(r, 0.0, 0.0, tag=-1, meshSize=meshRes)
    equator_pts_1o = gmsh.model.geo.addPoint(
        r * np.cos(dtheta), r * np.sin(dtheta), 0.0, tag=-1, meshSize=meshRes
    )
    r = radiusInner
    equator_pts_0i = gmsh.model.geo.addPoint(r, 0.0, 0.0, tag=-1, meshSize=meshRes)
    equator_pts_1i = gmsh.model.geo.addPoint(
        r * np.cos(dtheta), r * np.sin(dtheta), 0.0, tag=-1, meshSize=meshRes
    )

    gmsh.model.geo.synchronize()

    # Make edges

    edgeWo = gmsh.model.geo.addCircleArc(poleNo, centre, equator_pts_0o, tag=-1)
    edgeEqo = gmsh.model.geo.addCircleArc(
        equator_pts_0o, centre, equator_pts_1o, tag=-1
    )
    edgeEo = gmsh.model.geo.addCircleArc(equator_pts_1o, centre, poleNo, tag=-1)

    edgeWi = gmsh.model.geo.addCircleArc(poleNi, centre, equator_pts_0i, tag=-1)
    edgeEqi = gmsh.model.geo.addCircleArc(
        equator_pts_0i, centre, equator_pts_1i, tag=-1
    )
    edgeEi = gmsh.model.geo.addCircleArc(equator_pts_1i, centre, poleNi, tag=-1)

    ## Struts

    radialW = gmsh.model.geo.addLine(equator_pts_0o, equator_pts_0i, tag=-1)
    radialE = gmsh.model.geo.addLine(equator_pts_1o, equator_pts_1i, tag=-1)
    radialN = gmsh.model.geo.addLine(poleNo, poleNi, tag=-1)

    # Make boundaries

    faceLoopo = gmsh.model.geo.addCurveLoop(
        [edgeWo, edgeEqo, edgeEo], tag=-1, reorient=True
    )
    faceLoopi = gmsh.model.geo.addCurveLoop(
        [edgeWi, edgeEqi, edgeEi], tag=-1, reorient=True
    )
    faceLoopW = gmsh.model.geo.addCurveLoop(
        [edgeWo, radialW, edgeWi, radialN], tag=-1, reorient=True
    )
    faceLoopE = gmsh.model.geo.addCurveLoop(
        [edgeEo, radialE, edgeEi, radialN], tag=-1, reorient=True
    )
    faceLoopS = gmsh.model.geo.addCurveLoop(
        [edgeEqo, radialW, edgeEqi, radialE], tag=-1, reorient=True
    )

    # Make surfaces

    face_o = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopo,
        ],
        tag=-1,
        sphereCenterTag=centre,
    )
    face_i = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopi,
        ],
        tag=-1,
        sphereCenterTag=centre,
    )
    face_W = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopW,
        ],
        tag=-1,
    )
    face_E = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopE,
        ],
        tag=-1,
    )
    face_S = gmsh.model.geo.addSurfaceFilling(
        [
            faceLoopS,
        ],
        tag=-1,
    )

    outer_faces = [face_o]
    inner_faces = [face_i]

    # Make volume

    wedge_surf = gmsh.model.geo.addSurfaceLoop(
        [face_o, face_i, face_W, face_E, face_S], tag=-1
    )
    wedge_vol = gmsh.model.geo.addVolume([wedge_surf], tag=-1)
    wedges = [wedge_vol]

    gmsh.model.geo.synchronize()

    # Make copies

    for i in range(1, num_segments):

        new_wedge = gmsh.model.geo.copy([(3, 1)])
        gmsh.model.geo.rotate(new_wedge, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, i * dtheta)

        gmsh.model.geo.synchronize()

        _, new_faces = gmsh.model.get_adjacencies(3, new_wedge[0][1])

        wedges.append(new_wedge[0][1])
        outer_faces.append(new_faces[0])
        inner_faces.append(new_faces[1])

    mirror_wedge = gmsh.model.geo.copy([(3, 1)])
    gmsh.model.geo.mirror(mirror_wedge, 0.0, 0.0, 1.0, 0.0)

    gmsh.model.geo.synchronize()
    _, mirror_faces = gmsh.model.get_adjacencies(3, mirror_wedge[0][1])
    wedges.append(mirror_wedge[0][1])
    outer_faces.append(mirror_faces[0])
    inner_faces.append(mirror_faces[1])

    _, mirror_edges_w = gmsh.model.get_adjacencies(2, mirror_faces[2])
    _, mirror_edges_e = gmsh.model.get_adjacencies(2, mirror_faces[3])

    radialS = tuple(set(mirror_edges_e).intersection(set(mirror_edges_w)))[0]

    for i in range(1, num_segments):

        new_wedge = gmsh.model.geo.copy(mirror_wedge)
        gmsh.model.geo.rotate(new_wedge, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, i * dtheta)

        gmsh.model.geo.synchronize()

        _, new_faces = gmsh.model.get_adjacencies(3, new_wedge[0][1])

        wedges.append(new_wedge[0][1])
        outer_faces.append(new_faces[0])
        inner_faces.append(new_faces[1])

    gmsh.model.addPhysicalGroup(0, [poleNo], 1)
    gmsh.model.setPhysicalName(0, 1, &#34;PolePtNo&#34;)

    gmsh.model.addPhysicalGroup(0, [poleNi], 2)
    gmsh.model.setPhysicalName(0, 2, &#34;PolePtNi&#34;)

    gmsh.model.addPhysicalGroup(0, [poleSo], 3)
    gmsh.model.setPhysicalName(0, 3, &#34;PolePtSo&#34;)

    gmsh.model.addPhysicalGroup(0, [poleSi], 4)
    gmsh.model.setPhysicalName(0, 4, &#34;PolePtSi&#34;)

    gmsh.model.addPhysicalGroup(1, [radialN], 10)
    gmsh.model.setPhysicalName(1, 10, &#34;PoleAxisN&#34;)

    gmsh.model.addPhysicalGroup(1, [radialS], 11)
    gmsh.model.setPhysicalName(1, 11, &#34;PoleAxisS&#34;)

    gmsh.model.addPhysicalGroup(2, outer_faces, 20)
    gmsh.model.setPhysicalName(2, 20, &#34;Upper&#34;)

    gmsh.model.addPhysicalGroup(2, inner_faces, 21)
    gmsh.model.setPhysicalName(2, 21, &#34;Lower&#34;)

    gmsh.model.addPhysicalGroup(3, wedges, 30)
    gmsh.model.setPhysicalName(3, 30, &#34;Elements&#34;)

    gmsh.model.remove_entities([(0, centre)])

    gmsh.model.mesh.generate(3)

    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        plex = PETSc.DMPlex().createFromFile(fp.name)
        # plex = PETSc.DMPlex().createFromFile(filename)

    gmsh.finalize()

    ## This is the lat lon version that I can&#39;t quite seem to get right
    ## in the vector calculus section

    # if coordinatesNative:
    #     xyz_vec = plex.getCoordinates()
    #     xyz = xyz_vec.array.reshape(-1, 3)

    #     rl1l2 = np.empty_like(xyz)
    #     rl1l2[:, 0] = np.sqrt(xyz[:, 0] ** 2 + xyz[:, 1] ** 2 + xyz[:, 2] ** 2)
    #     rl1l2[:, 1] = np.arctan2(xyz[:, 1], xyz[:, 0] + 1.0e-16) - np.pi
    #     rl1l2[:, 2] = np.arcsin((xyz[:, 2] + 1.0e-16) / (rl1l2[:, 0] + 1.0e-16))

    #     rl1l2_vec = xyz_vec.copy()
    #     rl1l2_vec.array[...] = rl1l2.reshape(-1)[...]
    #     plex.setCoordinates(rl1l2_vec)

    #     uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
    #         plex, [0.0, np.pi, 0.0], [0.0, -np.pi, 0.0], [0.0, np.pi * 2, 0.0]
    #     )

    if coordinatesNative:
        xyz_vec = plex.getCoordinates()
        xyz = xyz_vec.array.reshape(-1, 3)

        rthph = np.empty_like(xyz)
        rthph[:, 0] = np.sqrt(xyz[:, 0] ** 2 + xyz[:, 1] ** 2 + xyz[:, 2] ** 2)
        rthph[:, 1] = np.arccos((xyz[:, 2]) / (rthph[:, 0] + 1.0e-6))
        rthph[:, 2] = np.arctan2(xyz[:, 1], xyz[:, 0] + 1.0e-6) - np.pi

        rthph_vec = xyz_vec.copy()
        rthph_vec.array[...] = rthph.reshape(-1)[...]
        plex.setCoordinates(rthph_vec)

        uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
            plex, [0.0, 0.0, np.pi], [0.0, 0.0, -np.pi], [0.0, 0.0, np.pi * 2]
        )

    return Mesh(
        plex,
        simplex=True,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=coordinate_system,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.SegmentedSphericalSurface2D"><code class="name flex">
<span>def <span class="ident">SegmentedSphericalSurface2D</span></span>(<span>radius: float = 1.0, cellSize: float = 0.05, numSegments: int = 6, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SegmentedSphericalSurface2D(
    radius: float = 1.0,
    cellSize: float = 0.05,
    numSegments: int = 6,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    import gmsh
    import underworld3 as uw

    options = PETSc.Options()
    options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
    options[&#34;dm_plex_gmsh_spacedim&#34;] = 2
    options[&#34;dm_plex_gmsh_use_regions&#34;] = None
    options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 1)
    gmsh.model.add(&#34;Segmented Sphere 2D Surface&#34;)

    # Mesh like an orange

    num_segments = numSegments
    meshRes = cellSize

    surflist = []
    longitudesN = []
    longitudesS = []
    segments_clps = []
    segments_surfs = []
    equator_pts = []

    centre = gmsh.model.geo.addPoint(0.0, 0.0, 0.0, tag=-1)
    poleN = gmsh.model.geo.addPoint(0.0, 0.0, 1.0, tag=-1, meshSize=0.5 * meshRes)
    poleS = gmsh.model.geo.addPoint(0.0, 0.0, -1.0, tag=-1, meshSize=0.5 * meshRes)

    dtheta = 2 * np.pi / num_segments

    for i in range(num_segments):
        theta = i * 2 * np.pi / num_segments
        x1 = np.cos(theta)
        y1 = np.sin(theta)
        equator_pts.append(
            gmsh.model.geo.addPoint(x1, y1, 0.0, tag=-1, meshSize=meshRes)
        )

    for i in range(num_segments):
        pEq = equator_pts[i]
        longitudesN.append(gmsh.model.geo.addCircleArc(poleN, centre, pEq, tag=-1))
        longitudesS.append(gmsh.model.geo.addCircleArc(pEq, centre, poleS, tag=-1))

    gmsh.model.geo.synchronize()

    # Curve loops:

    for i in range(num_segments):
        loops = [
            longitudesN[i],
            longitudesS[i],
            longitudesS[np.mod(i + 1, num_segments)],
            longitudesN[np.mod(i + 1, num_segments)],
        ]
        segments_clps.append(
            gmsh.model.geo.addCurveLoop(loops[::-1], tag=-1, reorient=True)
        )

    gmsh.model.geo.synchronize()

    # Surfaces

    for i in range(num_segments):
        segments_surfs.append(
            gmsh.model.geo.addSurfaceFilling(
                [segments_clps[i]], tag=-1, sphereCenterTag=centre
            )
        )

    gmsh.model.geo.synchronize()

    # Add some physical labels etc.

    gmsh.model.addPhysicalGroup(0, [poleN], 1000)
    gmsh.model.addPhysicalGroup(0, [poleS], 2000)
    gmsh.model.addPhysicalGroup(0, [poleN, poleS], 3000)
    gmsh.model.setPhysicalName(0, 1000, &#34;NPole&#34;)
    gmsh.model.setPhysicalName(0, 2000, &#34;SPole&#34;)
    gmsh.model.setPhysicalName(0, 3000, &#34;Poles&#34;)

    gmsh.model.addPhysicalGroup(2, segments_surfs, 10000)
    gmsh.model.setPhysicalName(2, 10000, &#34;Elements&#34;)

    gmsh.model.mesh.remove_duplicate_nodes()
    gmsh.model.remove_entities([(0, centre)])

    # Generate Mesh
    gmsh.model.mesh.generate(2)

    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        plex = PETSc.DMPlex().createFromFile(fp.name)

    # xyz coordinates of the mesh
    xyz = gmsh.model.mesh.get_nodes()[1].reshape(-1, 3)  # [1::, :]

    # Re-interpret the DM coordinates
    lonlat_vec = plex.getCoordinates()
    lonlat = np.empty_like(xyz[:, 0:2])
    lonlat[:, 0] = np.mod(np.arctan2(xyz[:, 1], xyz[:, 0]), 2.0 * np.pi) - np.pi
    lonlat[:, 1] = np.arcsin(xyz[:, 2])
    lonlat_vec.array[...] = lonlat.reshape(-1)
    plex.setCoordinates(lonlat_vec)

    # This mesh will always be periodic in the longitudinal coordinate

    uw.cython.petsc_discretisation.petsc_dm_set_periodicity(
        plex, [np.pi, 0.0], [-np.pi, 0.0], [np.pi * 2, 0.0]
    )

    gmsh.finalize()

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERE_SURFACE_NATIVE,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.SphericalShell"><code class="name flex">
<span>def <span class="ident">SphericalShell</span></span>(<span>radiusOuter: float = 1.0, radiusInner: float = 0.1, cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SphericalShell(
    radiusOuter: float = 1.0,
    radiusInner: float = 0.1,
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    boundaries = {&#34;Lower&#34;: 1, &#34;Upper&#34;: 2}

    vertices = {&#34;Centre&#34;: 1}

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Sphere&#34;)

    p1 = gmsh.model.geo.add_point(0.0, 0.0, 0.0, meshSize=cellSize)

    ball1_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusOuter)

    if radiusInner &gt; 0.0:
        ball2_tag = gmsh.model.occ.addSphere(0, 0, 0, radiusInner)
        gmsh.model.occ.cut(
            [(3, ball1_tag)], [(3, ball2_tag)], removeObject=True, removeTool=True
        )

    gmsh.option.setNumber(&#34;Mesh.CharacteristicLengthMax&#34;, cellSize)
    gmsh.model.occ.synchronize()

    surfaces = gmsh.model.getEntities(2)
    volume = gmsh.model.getEntities(3)[0]

    if radiusInner &gt; 0.0:
        outerSurface, innerSurface = surfaces
        gmsh.model.addPhysicalGroup(
            innerSurface[0], [innerSurface[1]], boundaries[&#34;Lower&#34;]
        )
        gmsh.model.setPhysicalName(innerSurface[1], boundaries[&#34;Lower&#34;], &#34;Lower&#34;)
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], 99999)
        gmsh.model.setPhysicalName(volume[1], 99999, &#34;Elements&#34;)

    else:
        outerSurface = surfaces[0]
        gmsh.model.addPhysicalGroup(
            outerSurface[0], [outerSurface[1]], boundaries[&#34;Upper&#34;]
        )
        gmsh.model.setPhysicalName(outerSurface[1], boundaries[&#34;Upper&#34;], &#34;Upper&#34;)
        gmsh.model.addPhysicalGroup(volume[0], [volume[1]], 99999)
        gmsh.model.setPhysicalName(volume[1], 99999, &#34;Elements&#34;)
        gmsh.model.addPhysicalGroup(0, [p1], tag=vertices[&#34;Centre&#34;])
        gmsh.model.setPhysicalName(0, vertices[&#34;Centre&#34;], &#34;Centre&#34;)

    gmsh.model.occ.synchronize()

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(3)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None
        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)

    # This seems not to work any longer ?? 3.17.4
    for name, tag in vertices.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Vertex Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Vertex Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.SPHERICAL,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.StructuredQuadBox"><code class="name flex">
<span>def <span class="ident">StructuredQuadBox</span></span>(<span>elementRes: Optional[Tuple[int, int, int]] = (16, 16), minCoords: Optional[Tuple[float, float, float]] = None, maxCoords: Optional[Tuple[float, float, float]] = None, degree: int = 1, qdegree: int = 2, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a 2 or 3-dimensional box mesh.</p>
<h2 id="parameters">Parameters</h2>
<p>elementRes:
Tuple specifying number of elements in each axis direction.
minCoord:
Optional. Tuple specifying minimum mesh location.
maxCoord:
Optional. Tuple specifying maximum mesh location.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def StructuredQuadBox(
    elementRes: Optional[Tuple[int, int, int]] = (16, 16),
    minCoords: Optional[Tuple[float, float, float]] = None,
    maxCoords: Optional[Tuple[float, float, float]] = None,
    degree: int = 1,
    qdegree: int = 2,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    elementRes:
        Tuple specifying number of elements in each axis direction.
    minCoord:
        Optional. Tuple specifying minimum mesh location.
    maxCoord:
        Optional. Tuple specifying maximum mesh location.
    &#34;&#34;&#34;
    if minCoords == None:
        minCoords = len(elementRes) * (0.0,)
    if maxCoords == None:
        maxCoords = len(elementRes) * (1.0,)

    import gmsh

    boundaries = {&#34;Bottom&#34;: 1, &#34;Top&#34;: 2, &#34;Right&#34;: 3, &#34;Left&#34;: 4, &#34;Front&#34;: 5, &#34;Back&#34;: 6}

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, tag=1)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, tag=2)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, tag=3)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, tag=4)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        gmsh.model.add_physical_group(1, [l1], l1)
        gmsh.model.set_physical_name(1, l1, &#34;Bottom&#34;)
        gmsh.model.add_physical_group(1, [l2], l2)
        gmsh.model.set_physical_name(1, l2, &#34;Right&#34;)
        gmsh.model.add_physical_group(1, [l3], l3)
        gmsh.model.set_physical_name(1, l3, &#34;Top&#34;)
        gmsh.model.add_physical_group(1, [l4], l4)
        gmsh.model.set_physical_name(1, l4, &#34;Left&#34;)

        gmsh.model.add_physical_group(2, [surface], 99999)
        gmsh.model.set_physical_name(2, 99999, &#34;Elements&#34;)

        nx, ny = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            tag=l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            tag=l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=surface, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p3, p4]
        )
        gmsh.model.mesh.set_recombine(2, surface)

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        nx, ny, nz = elementRes

        gmsh.model.mesh.set_transfinite_curve(
            l1, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l2, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l3, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l4, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l5, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l6, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l7, numNodes=nx + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l8, numNodes=ny + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l9, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l10, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l11, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )
        gmsh.model.mesh.set_transfinite_curve(
            l12, numNodes=nz + 1, meshType=&#34;Progression&#34;, coef=1.0
        )

        gmsh.model.mesh.set_transfinite_surface(
            tag=bottom, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p4, p3]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=top, arrangement=&#34;Left&#34;, cornerTags=[p5, p6, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=front, arrangement=&#34;Left&#34;, cornerTags=[p1, p2, p6, p5]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=back, arrangement=&#34;Left&#34;, cornerTags=[p3, p4, p8, p7]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=right, arrangement=&#34;Left&#34;, cornerTags=[p2, p6, p8, p4]
        )
        gmsh.model.mesh.set_transfinite_surface(
            tag=left, arrangement=&#34;Left&#34;, cornerTags=[p5, p1, p3, p7]
        )

        gmsh.model.mesh.set_recombine(2, front)
        gmsh.model.mesh.set_recombine(2, back)
        gmsh.model.mesh.set_recombine(2, bottom)
        gmsh.model.mesh.set_recombine(2, top)
        gmsh.model.mesh.set_recombine(2, right)
        gmsh.model.mesh.set_recombine(2, left)

        gmsh.model.mesh.set_transfinite_volume(
            volume, cornerTags=[p1, p2, p4, p3, p5, p6, p8, p7]
        )

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], 99999)
        gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)
    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )</code></pre>
</details>
</dd>
<dt id="underworld3.meshing.UnstructuredSimplexBox"><code class="name flex">
<span>def <span class="ident">UnstructuredSimplexBox</span></span>(<span>minCoords: Tuple = (0.0, 0.0), maxCoords: Tuple = (1.0, 1.0), cellSize: float = 0.1, degree: int = 1, qdegree: int = 2, regular: bool = False, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a 2 or 3-dimensional box mesh.</p>
<h2 id="parameters">Parameters</h2>
<p>minCoord:
Tuple specifying minimum mesh location.
maxCoord:
Tuple specifying maximum mesh location.</p>
<p>regular option works in 2D but not (currently) in 3D</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnstructuredSimplexBox(
    minCoords: Tuple = (0.0, 0.0),
    maxCoords: Tuple = (1.0, 1.0),
    cellSize: float = 0.1,
    degree: int = 1,
    qdegree: int = 2,
    regular: bool = False,
    filename=None,
):

    &#34;&#34;&#34;
    Generates a 2 or 3-dimensional box mesh.

    Parameters
    ----------
    minCoord:
        Tuple specifying minimum mesh location.
    maxCoord:
        Tuple specifying maximum mesh location.

    regular option works in 2D but not (currently) in 3D

    &#34;&#34;&#34;

    boundaries = {
        &#34;Bottom&#34;: 11,
        &#34;Top&#34;: 12,
        &#34;Right&#34;: 13,
        &#34;Left&#34;: 14,
        &#34;Front&#34;: 15,
        &#34;Back&#34;: 16,
    }

    import gmsh

    gmsh.initialize()
    gmsh.option.setNumber(&#34;General.Verbosity&#34;, 0)
    gmsh.model.add(&#34;Box&#34;)

    # Create Box Geometry
    dim = len(minCoords)

    if dim == 2:

        xmin, ymin = minCoords
        xmax, ymax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, 0.0, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, 0.0, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, 0.0, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, 0.0, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2, tag=boundaries[&#34;Bottom&#34;])
        l2 = gmsh.model.geo.add_line(p2, p4, tag=boundaries[&#34;Right&#34;])
        l3 = gmsh.model.geo.add_line(p4, p3, tag=boundaries[&#34;Top&#34;])
        l4 = gmsh.model.geo.add_line(p3, p1, tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        surface = gmsh.model.geo.add_plane_surface([cl])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(1, [tag], tag)
            gmsh.model.set_physical_name(1, tag, name)

        gmsh.model.addPhysicalGroup(2, [surface], 99999)
        gmsh.model.setPhysicalName(2, 99999, &#34;Elements&#34;)

        if regular:
            gmsh.model.mesh.set_transfinite_surface(
                surface, cornerTags=[p1, p2, p3, p4]
            )

    else:

        xmin, ymin, zmin = minCoords
        xmax, ymax, zmax = maxCoords

        p1 = gmsh.model.geo.add_point(xmin, ymin, zmin, meshSize=cellSize)
        p2 = gmsh.model.geo.add_point(xmax, ymin, zmin, meshSize=cellSize)
        p3 = gmsh.model.geo.add_point(xmin, ymax, zmin, meshSize=cellSize)
        p4 = gmsh.model.geo.add_point(xmax, ymax, zmin, meshSize=cellSize)
        p5 = gmsh.model.geo.add_point(xmin, ymin, zmax, meshSize=cellSize)
        p6 = gmsh.model.geo.add_point(xmax, ymin, zmax, meshSize=cellSize)
        p7 = gmsh.model.geo.add_point(xmin, ymax, zmax, meshSize=cellSize)
        p8 = gmsh.model.geo.add_point(xmax, ymax, zmax, meshSize=cellSize)

        l1 = gmsh.model.geo.add_line(p1, p2)
        l2 = gmsh.model.geo.add_line(p2, p4)
        l3 = gmsh.model.geo.add_line(p4, p3)
        l4 = gmsh.model.geo.add_line(p3, p1)
        l5 = gmsh.model.geo.add_line(p5, p6)
        l6 = gmsh.model.geo.add_line(p6, p8)
        l7 = gmsh.model.geo.add_line(p8, p7)
        l8 = gmsh.model.geo.add_line(p7, p5)
        l9 = gmsh.model.geo.add_line(p5, p1)
        l10 = gmsh.model.geo.add_line(p2, p6)
        l11 = gmsh.model.geo.add_line(p7, p3)
        l12 = gmsh.model.geo.add_line(p4, p8)

        cl = gmsh.model.geo.add_curve_loop((l1, l2, l3, l4))
        bottom = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Bottom&#34;])

        cl = gmsh.model.geo.add_curve_loop((l5, l6, l7, l8))
        top = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Top&#34;])

        cl = gmsh.model.geo.add_curve_loop((l10, l6, -l12, -l2))
        right = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Right&#34;])

        cl = gmsh.model.geo.add_curve_loop((l9, -l4, -l11, l8))
        left = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Left&#34;])

        cl = gmsh.model.geo.add_curve_loop((l1, l10, -l5, l9))
        front = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Front&#34;])

        cl = gmsh.model.geo.add_curve_loop((-l3, l12, l7, l11))
        back = gmsh.model.geo.add_plane_surface([cl], tag=boundaries[&#34;Back&#34;])

        sloop = gmsh.model.geo.add_surface_loop([front, right, back, top, left, bottom])
        volume = gmsh.model.geo.add_volume([sloop])

        gmsh.model.geo.synchronize()

        # Add Physical groups
        for name, tag in boundaries.items():
            gmsh.model.add_physical_group(2, [tag], tag)
            gmsh.model.set_physical_name(2, tag, name)

        gmsh.model.addPhysicalGroup(3, [volume], 99999)
        gmsh.model.setPhysicalName(3, 99999, &#34;Elements&#34;)

    # Generate Mesh
    with tempfile.NamedTemporaryFile(mode=&#34;w&#34;, suffix=&#34;.msh&#34;) as fp:
        gmsh.model.mesh.generate(dim)
        gmsh.write(fp.name)
        if filename:
            gmsh.write(filename)
        gmsh.finalize()

        options = PETSc.Options()
        options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
        options[&#34;dm_plex_gmsh_use_regions&#34;] = None
        options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

        plex = PETSc.DMPlex().createFromFile(fp.name)

    &#34;&#34;&#34;
    for name, tag in boundaries.items():
        plex.createLabel(name)
        label = plex.getLabel(name)
        indexSet = plex.getStratumIS(&#34;Face Sets&#34;, tag)
        if indexSet:
            label.insertIS(indexSet, 1)
        else:
            plex.removeLabel(name)

    plex.removeLabel(&#34;Face Sets&#34;)
    &#34;&#34;&#34;

    return Mesh(
        plex,
        degree=degree,
        qdegree=qdegree,
        coordinate_system_type=CoordinateSystemType.CARTESIAN,
        filename=filename,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3" href="index.html">underworld3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="underworld3.meshing.Annulus" href="#underworld3.meshing.Annulus">Annulus</a></code></li>
<li><code><a title="underworld3.meshing.AnnulusFixedStars" href="#underworld3.meshing.AnnulusFixedStars">AnnulusFixedStars</a></code></li>
<li><code><a title="underworld3.meshing.CubedSphere" href="#underworld3.meshing.CubedSphere">CubedSphere</a></code></li>
<li><code><a title="underworld3.meshing.SegmentedSphere" href="#underworld3.meshing.SegmentedSphere">SegmentedSphere</a></code></li>
<li><code><a title="underworld3.meshing.SegmentedSphericalSurface2D" href="#underworld3.meshing.SegmentedSphericalSurface2D">SegmentedSphericalSurface2D</a></code></li>
<li><code><a title="underworld3.meshing.SphericalShell" href="#underworld3.meshing.SphericalShell">SphericalShell</a></code></li>
<li><code><a title="underworld3.meshing.StructuredQuadBox" href="#underworld3.meshing.StructuredQuadBox">StructuredQuadBox</a></code></li>
<li><code><a title="underworld3.meshing.UnstructuredSimplexBox" href="#underworld3.meshing.UnstructuredSimplexBox">UnstructuredSimplexBox</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>