<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>underworld3.discretisation API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.discretisation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># from telnetlib import DM
# from this import d
from typing import Optional, Tuple, Union
import os
from xmlrpc.client import Boolean
import mpi4py
import numpy
import sympy
import sympy.vector
from petsc4py import PETSc
import underworld3 as uw

from underworld3.utilities import _api_tools
from underworld3.coordinates import CoordinateSystem, CoordinateSystemType
from underworld3.cython import petsc_discretisation


import underworld3.timing as timing
import weakref


@PETSc.Log.EventDecorator()
def _from_gmsh(filename, comm=None, cellSets=None, faceSets=None, vertexSets=None):
    &#34;&#34;&#34;Read a Gmsh .msh file from `filename`.

    :kwarg comm: Optional communicator to build the mesh on (defaults to
        COMM_WORLD).
    &#34;&#34;&#34;
    comm = comm or PETSc.COMM_WORLD
    # Create a read-only PETSc.Viewer
    # gmsh_viewer = PETSc.Viewer().create(comm=comm)
    # gmsh_viewer.setType(&#34;ascii&#34;)
    # gmsh_viewer.setFileMode(&#34;r&#34;)
    # gmsh_viewer.setFileName(filename)
    # gmsh_plex = PETSc.DMPlex().createGmsh(gmsh_viewer, comm=comm)

    options = PETSc.Options()
    options[&#34;dm_plex_gmsh_multiple_tags&#34;] = None
    options[&#34;dm_plex_gmsh_use_regions&#34;] = None
    options[&#34;dm_plex_gmsh_mark_vertices&#34;] = None

    # This is probably simpler
    gmsh_plex = PETSc.DMPlex().createFromFile(filename)

    &#34;&#34;&#34;
    # Extract Physical groups from the gmsh file

    ## NOTE: should we be doing this is parallel ??
    ## 1) Race conditions on gmsh files / locking etc
    ## 2) Why not pass in these collections from the gmsh generator and process accordingly

    import gmsh

    gmsh.initialize()
    gmsh.model.add(&#34;Model&#34;)
    gmsh.open(filename)

    ## What about cells and vertices ?

    physical_groups = {}
    for dim, tag in gmsh.model.get_physical_groups():

        name = gmsh.model.get_physical_name(dim, tag)

        physical_groups[name] = tag

        gmsh_plex.createLabel(name)
        label = gmsh_plex.getLabel(name)

        for elem in [&#34;Face Sets&#34;]:
            indexSet = gmsh_plex.getStratumIS(elem, tag)
            if indexSet:
                label.insertIS(indexSet, 1)
            indexSet.destroy()

    # cell sets / face sets / vertex sets by numerical tag (by hand for the case where  gmsh has no physical groups)

    if cellSets is not None:
        for cellSet in cellSets:
            label_name = cellSet[&#34;name&#34;]
            label_id = cellSet[&#34;id&#34;]

            gmsh_plex.createLabel(label_name)
            label = gmsh_plex.getLabel(label_name)
            indexSet = gmsh_plex.getStratumIS(&#34;Cell Sets&#34;, label_id)
            if indexSet:
                label.insertIS(indexSet, 1)
            else:
                gmsh_plex.removeLabel(label_name)
            indexSet.destroy()

    if faceSets is not None:
        for faceSet in faceSets:
            label_name = faceSet[&#34;name&#34;]
            label_id = faceSet[&#34;id&#34;]

            gmsh_plex.createLabel(label_name)
            label = gmsh_plex.getLabel(label_name)
            indexSet = gmsh_plex.getStratumIS(&#34;Face Sets&#34;, label_id)
            if indexSet:
                label.insertIS(indexSet, 1)
            else:
                gmsh_plex.removeLabel(label_name)
            indexSet.destroy()

    if vertexSets is not None:
        for vertexSet in vertexSets:
            label_name = vertexSet[&#34;name&#34;]
            label_id = vertexSet[&#34;id&#34;]

            gmsh_plex.createLabel(label_name)
            label = gmsh_plex.getLabel(label_name)
            indexSet = gmsh_plex.getStratumIS(&#34;Vertex Sets&#34;, label_id)
            if indexSet:
                label.insertIS(indexSet, 1)
            else:
                gmsh_plex.removeLabel(label_name)
            indexSet.destroy()

    gmsh.finalize()
    &#34;&#34;&#34;

    return gmsh_plex


class Mesh(_api_tools.Stateful):

    mesh_instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        plex_or_meshfile,
        degree=1,
        simplex=True,
        coordinate_system_type=None,
        qdegree=2,
        cellSets=None,
        vertexSets=None,
        faceSets=None,
        filename=None,
        *args,
        **kwargs,
    ):

        if isinstance(plex_or_meshfile, PETSc.DMPlex):
            name = &#34;plexmesh&#34;
            self.dm = plex_or_meshfile
        else:
            comm = kwargs.get(&#34;comm&#34;, PETSc.COMM_WORLD)
            name = plex_or_meshfile
            basename, ext = os.path.splitext(plex_or_meshfile)

            # Note: should be able to handle a .geo as well on this pathway
            if ext.lower() == &#34;.msh&#34;:
                self.dm = _from_gmsh(
                    plex_or_meshfile, comm, cellSets, faceSets, vertexSets
                )
            else:
                raise RuntimeError(
                    &#34;Mesh file %s has unknown format &#39;%s&#39;.&#34;
                    % (plex_or_meshfile, ext[1:])
                )

        self.filename = filename
        self.dm.markBoundaryFaces(&#34;All_Boundaries&#34;, 1001)
        self.dm.distribute()

        Mesh.mesh_instances += 1

        # Set sympy constructs. First a generic, symbolic, Cartesian coordinate system
        from sympy.vector import CoordSys3D

        # A unique set of vectors / names for each mesh instance
        self._N = CoordSys3D(f&#34;N{Mesh.mesh_instances}&#34;)

        self._N.x._latex_form = r&#34;\mathrm{\xi_0}&#34;
        self._N.y._latex_form = r&#34;\mathrm{\xi_1}&#34;
        self._N.z._latex_form = r&#34;\mathrm{\xi_2}&#34;
        self._N.i._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_0}&#34;
        self._N.j._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_1}&#34;
        self._N.k._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_2}&#34;

        # Now add the appropriate coordinate system for the mesh&#39;s natural geometry
        # This step will usually over-write the defaults we just defined
        self._CoordinateSystem = CoordinateSystem(self, coordinate_system_type)

        # Tidy some of this printing without changing the
        # underlying vector names (as these are part of the code generation system)

        try:
            self.isSimplex = self.dm.isSimplex()
        except:
            self.isSimplex = simplex

        # Use grid hashing for point location
        options = PETSc.Options()
        options[&#34;dm_plex_hash_location&#34;] = None
        self.dm.setFromOptions()

        self._vars = weakref.WeakValueDictionary()

        # a list of equation systems that will
        # need to be rebuilt if the mesh coordinates change

        self._equation_systems_register = []

        self._accessed = False
        self._quadrature = False
        self._stale_lvec = True
        self._lvec = None
        self.petsc_fe = None

        self.degree = degree
        self.qdegree = qdegree

        self.nuke_coords_and_rebuild()

        # A private work array used in the stats routines.
        # This is defined now since we cannot make a new one
        # once the init phase of uw3 is complete.

        self._work_MeshVar = MeshVariable(&#34;work_array_1&#34;, self, 1, degree=2)

        # This looks a bit strange, but we&#39;d like to
        # put these mesh-dependent vector calculus functions
        # and mesh-based tensor manipulation routines
        # in a bundle to avoid the mesh being required as an argument
        # since this could lead to things going out of sync

        if (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL2D_NATIVE
            or self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL3D_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_cylindrical(
                mesh=self,
            )
        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERICAL_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical(
                mesh=self,
            )  ## Not yet complete or tested

        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERE_SURFACE_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical_surface2D_lonlat(
                mesh=self,
            )

        else:
            self.vector = uw.maths.vector_calculus(mesh=self)

        super().__init__()

    @property
    def dim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getDimension()

    @property
    def cdim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getCoordinateDim()

    def nuke_coords_and_rebuild(self):

        # This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)

        self._coord_array = {}

        # let&#39;s go ahead and do an initial projection from linear (the default)
        # to linear. this really is a nothing operation, but a
        # side effect of this operation is that coordinate DM DMField is
        # converted to the required `PetscFE` type. this may become necessary
        # later where we call the interpolation routines to project from the linear
        # mesh coordinates to other mesh coordinates.

        options = PETSc.Options()
        options.setValue(
            &#34;meshproj_{}_petscspace_degree&#34;.format(self.mesh_instances), self.degree
        )

        self.petsc_fe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;meshproj_{}_&#34;.format(self.mesh_instances),
            PETSc.COMM_WORLD,
        )

        if self.degree != 1:

            # We have to be careful as a projection onto an equivalent PETScFE can cause problematic
            # issues with petsc that we see in parallel - in which case there is a fallback, pass no
            # PETScFE and let PETSc decide. Note that the petsc4py wrapped version does not allow this
            # (but it should !)

            self.dm.projectCoordinates(self.petsc_fe)

        else:

            uw.cython.petsc_discretisation.petsc_dm_project_coordinates(self.dm)

        # now set copy of this array into dictionary

        arr = self.dm.getCoordinatesLocal().array

        key = (
            self.isSimplex,
            self.degree,
            True,
        )  # True here assumes continuous basis for coordinates ...

        self._coord_array[key] = arr.reshape(-1, self.cdim).copy()

        # self._centroids = self._get_coords_for_basis(0, True)
        self._centroids = self._get_mesh_centroids()

        # invalidate the cell-search k-d tree and the mesh centroid data
        self._index = None

        return

    @timing.routine_timer_decorator
    def update_lvec(self):
        &#34;&#34;&#34;
        This method creates and/or updates the mesh variable local vector.
        If the local vector is already up to date, this method will do nothing.
        &#34;&#34;&#34;

        if self._stale_lvec:
            if not self._lvec:
                # self.dm.clearDS()
                # self.dm.createDS()
                # create the local vector (memory chunk) and attach to original dm
                self._lvec = self.dm.createLocalVec()
            # push avar arrays into the parent dm array
            a_global = self.dm.getGlobalVec()
            names, isets, dms = self.dm.createFieldDecomposition()

            with self.access():
                # traverse subdms, taking user generated data in the subdm
                # local vec, pushing it into a global sub vec
                for var, subiset, subdm in zip(self.vars.values(), isets, dms):
                    lvec = var.vec
                    subvec = a_global.getSubVector(subiset)
                    subdm.localToGlobal(lvec, subvec, addv=False)
                    a_global.restoreSubVector(subiset, subvec)

            self.dm.globalToLocal(a_global, self._lvec)
            self.dm.restoreGlobalVec(a_global)
            self._stale_lvec = False

    @property
    def lvec(self) -&gt; PETSc.Vec:
        &#34;&#34;&#34;
        Returns a local Petsc vector containing the flattened array
        of all the mesh variables.
        &#34;&#34;&#34;
        if self._stale_lvec:
            raise RuntimeError(
                &#34;Mesh `lvec` needs to be updated using the update_lvec()` method.&#34;
            )
        return self._lvec

    def __del__(self):
        if hasattr(self, &#34;_lvec&#34;) and self._lvec:
            self._lvec.destroy()

    def deform_mesh(self, new_coords: numpy.ndarray):
        &#34;&#34;&#34;
        This method will update the mesh coordinates and reset any cached coordinates in
        the mesh and in equation systems that are registered on the mesh.

        The coord array that is passed in should match the shape of self.data
        &#34;&#34;&#34;

        coord_vec = self.dm.getCoordinatesLocal()
        coords = coord_vec.array.reshape(-1, self.cdim)
        coords[...] = new_coords[...]

        self.dm.setCoordinatesLocal(coord_vec)
        self.nuke_coords_and_rebuild()

        for eq_system in self._equation_systems_register:
            eq_system._rebuild_after_mesh_update()

        return

    def access(self, *writeable_vars: &#34;MeshVariable&#34;):
        &#34;&#34;&#34;
        This context manager makes the underlying mesh variables data available to
        the user. The data should be accessed via the variables `data` handle.

        As default, all data is read-only. To enable writeable data, the user should
        specify which variable they wish to modify.

        Parameters
        ----------
        writeable_vars
            The variables for which data write access is required.

        Example
        -------
        &gt;&gt;&gt; import underworld3 as uw
        &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
        &gt;&gt;&gt; with someMesh.deform_mesh():
        ...     someMesh.data[0] = [0.1,0.1]
        &gt;&gt;&gt; someMesh.data[0]
        array([ 0.1,  0.1])
        &#34;&#34;&#34;

        import time

        timing._incrementDepth()
        stime = time.time()

        self._accessed = True
        deaccess_list = []
        for var in self.vars.values():
            # if already accessed within higher level context manager, continue.
            if var._is_accessed == True:
                continue

            # set flag so variable status can be known elsewhere
            var._is_accessed = True
            # add to de-access list to rewind this later
            deaccess_list.append(var)

            # create &amp; set vec
            var._set_vec(available=True)

            # grab numpy object, setting read only if necessary
            var._data = var.vec.array.reshape(-1, var.num_components)

            if var not in writeable_vars:
                var._old_data_flag = var._data.flags.writeable
                var._data.flags.writeable = False
            else:
                # increment variable state
                var._increment()

        class exit_manager:
            def __init__(self, mesh):
                self.mesh = mesh

            def __enter__(self):
                pass

            def __exit__(self, *args):
                for var in self.mesh.vars.values():
                    # only de-access variables we have set access for.
                    if var not in deaccess_list:
                        continue
                    # set this back, although possibly not required.
                    if var not in writeable_vars:
                        var._data.flags.writeable = var._old_data_flag
                    # perform sync for any modified vars.

                    if var in writeable_vars:
                        indexset, subdm = self.mesh.dm.createSubDM(var.field_id)

                        # sync ghost values
                        subdm.localToGlobal(var.vec, var._gvec, addv=False)
                        subdm.globalToLocal(var._gvec, var.vec, addv=False)

                        # subdm.destroy()
                        self.mesh._stale_lvec = True

                    var._data = None
                    var._set_vec(available=False)
                    var._is_accessed = False

                timing._decrementDepth()
                timing.log_result(time.time() - stime, &#34;Mesh.access&#34;, 1)

        return exit_manager(self)

    @property
    def N(self) -&gt; sympy.vector.CoordSys3D:
        &#34;&#34;&#34;
        The mesh coordinate system.
        &#34;&#34;&#34;
        return self._N

    @property
    def X(self) -&gt; sympy.Matrix:
        return self._CoordinateSystem.X

    @property
    def CoordinateSystem(self) -&gt; CoordinateSystem:
        return self._CoordinateSystem

    @property
    def r(self) -&gt; Tuple[sympy.vector.BaseScalar]:
        &#34;&#34;&#34;
        The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.
        &#34;&#34;&#34;
        return self._N.base_scalars()[0 : self.cdim]

    @property
    def rvec(self) -&gt; sympy.vector.Vector:
        &#34;&#34;&#34;
        The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.
        &#34;&#34;&#34;
        N = self.N

        r_vec = sympy.vector.Vector.zero

        N_s = N.base_scalars()
        N_v = N.base_vectors()
        for i in range(self.cdim):
            r_vec += N_s[i] * N_v[i]

        return r_vec

    @property
    def data(self) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        The array of mesh element vertex coordinates.
        &#34;&#34;&#34;
        # get flat array
        arr = self.dm.getCoordinatesLocal().array
        return arr.reshape(-1, self.cdim)

    @timing.routine_timer_decorator
    def save(self, filename: str, index: Optional[int] = None):
        &#34;&#34;&#34;
        Save mesh data to the specified hdf5 file.

        Users will generally create this file, and then
        append mesh variable data to it via the variable
        `save` method.

        Parameters
        ----------
        filename :
            The filename for the mesh checkpoint file.
        index :
            Not yet implemented. An optional index which might
            correspond to the timestep (for example).

        &#34;&#34;&#34;
        viewer = PETSc.ViewerHDF5().create(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        if index:
            raise RuntimeError(&#34;Recording `index` not currently supported&#34;)
            ## JM:To enable timestep recording, the following needs to be called.
            ## I&#39;m unsure if the corresponding xdmf functionality is enabled via
            ## the PETSc xdmf script.
            # viewer.pushTimestepping(viewer)
            # viewer.setTimestep(index)
        viewer(self.dm)

    def vtk(self, filename: str):
        &#34;&#34;&#34;
        Save mesh to the specified file
        &#34;&#34;&#34;

        viewer = PETSc.Viewer().createVTK(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        viewer(self.dm)

    def generate_xdmf(self, filename: str):
        &#34;&#34;&#34;
        This method generates an xdmf schema for the specified file.

        The filename of the generated file will be the same as the hdf5 file
        but with the `xmf` extension.

        Parameters
        ----------
        filename :
            File name of the checkpointed hdf5 file for which the
            xdmf schema will be written.
        &#34;&#34;&#34;
        from underworld3.utilities import generateXdmf

        generateXdmf(filename)

    @property
    def vars(self):
        &#34;&#34;&#34;
        A list of variables recorded on the mesh.
        &#34;&#34;&#34;
        return self._vars

    def _get_coords_for_var(self, var):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;
        key = (self.isSimplex, var.degree, var.continuous)

        # if array already created, return.
        if key in self._coord_array:
            return self._coord_array[key]
        else:
            self._coord_array[key] = self._get_coords_for_basis(
                var.degree, var.continuous
            )
            return self._coord_array[key]

    def _get_coords_for_basis(self, degree, continuous):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;

        dmold = self.dm.getCoordinateDM()
        dmold.createDS()

        dmnew = dmold.clone()

        options = PETSc.Options()
        options[&#34;coordinterp_petscspace_degree&#34;] = degree
        options[&#34;coordinterp_petscdualspace_lagrange_continuity&#34;] = continuous
        options[&#34;coordinterp_petscdualspace_lagrange_node_endpoints&#34;] = False

        dmfe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;coordinterp_&#34;,
            PETSc.COMM_WORLD,
        )

        dmnew.setField(0, dmfe)
        dmnew.createDS()

        matInterp, vecScale = dmold.createInterpolation(dmnew)
        coordsOld = self.dm.getCoordinates()
        coordsNewL = dmnew.getLocalVec()
        coordsNewG = matInterp * coordsOld
        dmnew.globalToLocal(coordsNewG, coordsNewL)

        arr = coordsNewL.array
        arrcopy = arr.reshape(-1, self.cdim).copy()

        return arrcopy

    @timing.routine_timer_decorator
    def get_closest_cells(self, coords: numpy.ndarray) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        This method uses a kd-tree algorithm to find the closest
        cells to the provided coords. For a regular mesh, this should
        be exactly the owning cell, but if the mesh is deformed, this
        is not guaranteed.

        Parameters:
        -----------
        coords:
            An array of the coordinates for which we wish to determine the
            closest cells. This should be a 2-dimensional array of
            shape (n_coords,dim).

        Returns:
        --------
        closest_cells:
            An array of indices representing the cells closest to the provided
            coordinates. This will be a 1-dimensional array of
            shape (n_coords).
        &#34;&#34;&#34;
        # Create index if required
        if not self._index:
            from underworld3.swarm import Swarm, SwarmPICLayout

            # Create a temp swarm which we&#39;ll use to populate particles
            # at gauss points. These will then be used as basis for
            # kd-tree indexing back to owning cells.
            tempSwarm = Swarm(self)
            # 4^dim pop is used. This number may need to be considered
            # more carefully, or possibly should be coded to be set dynamically.
            tempSwarm.populate(fill_param=4, layout=SwarmPICLayout.GAUSS)
            with tempSwarm.access():
                # Build index on particle coords
                self._indexCoords = tempSwarm.particle_coordinates.data.copy()
                self._index = uw.kdtree.KDTree(self._indexCoords)
                self._index.build_index()
                # Grab mapping back to cell_ids.
                # Note that this is the numpy array that we eventually return from this
                # method. As such, we take measures to ensure that we use `numpy.int64` here
                # because we cast from this type in  `_function.evaluate` to construct
                # the PETSc cell-sf datasets, and if instead a `numpy.int32` is used it
                # will cause bugs that are difficult to find.
                self._indexMap = numpy.array(
                    tempSwarm.particle_cellid.data[:, 0], dtype=numpy.int64
                )

        closest_points, dist, found = self._index.find_closest_point(coords)

        if not numpy.allclose(found, True):
            raise RuntimeError(
                &#34;An error was encountered attempting to find the closest cells to the provided coordinates.&#34;
            )

        return self._indexMap[closest_points]

    def _get_mesh_centroids(self):
        &#34;&#34;&#34;
        Obtain and cache the mesh centroids using underworld swarm technology.
        This routine is called when the mesh is built / rebuilt
        &#34;&#34;&#34;

        from underworld3.swarm import Swarm, SwarmPICLayout

        tempSwarm = Swarm(self)
        tempSwarm.populate(fill_param=1, layout=SwarmPICLayout.GAUSS)

        with tempSwarm.access():
            # Build index on particle coords
            centroids = tempSwarm.data.copy()

        return centroids

    def get_min_radius(self) -&gt; float:
        &#34;&#34;&#34;
        This method returns the minimum distance from any cell centroid to a face.
        It wraps to the PETSc `DMPlexGetMinRadius` routine.
        &#34;&#34;&#34;

        ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
        ## does not obtain the minimum radius for the mesh.

        from underworld3.cython.petsc_discretisation import petsc_fvm_get_min_radius

        if (not hasattr(self, &#34;_min_radius&#34;)) or (self._min_radius == None):
            self._min_radius = petsc_fvm_get_min_radius(self)

        return self._min_radius

    # def get_boundary_subdm(self) -&gt; PETSc.DM:
    #     &#34;&#34;&#34;
    #     This method returns the boundary subdm that wraps DMPlexCreateSubmesh
    #     &#34;&#34;&#34;
    #     from underworld3.petsc_discretisation import petsc_create_surface_submesh
    #     return petsc_create_surface_submesh(self, &#34;Boundary&#34;, 666, )

    def stats(self, uw_function):
        &#34;&#34;&#34;
        Returns various norms on the mesh for the provided function.
          - size
          - mean
          - min
          - max
          - sum
          - L2 norm
          - rms

          NOTE: this currently assumes scalar variables !
        &#34;&#34;&#34;

        #       This uses a private work MeshVariable and the various norms defined there but
        #       could either be simplified to just use petsc vectors, or extended to
        #       compute integrals over the elements which is in line with uw1 and uw2

        from petsc4py.PETSc import NormType

        tmp = self._work_MeshVar

        with self.access(tmp):
            tmp.data[...] = uw.function.evaluate(uw_function, tmp.coords).reshape(-1, 1)

        vsize = self._work_MeshVar._gvec.getSize()
        vmean = tmp.mean()
        vmax = tmp.max()[1]
        vmin = tmp.min()[1]
        vsum = tmp.sum()
        vnorm2 = tmp.norm(NormType.NORM_2)
        vrms = vnorm2 / numpy.sqrt(vsize)

        return vsize, vmean, vmin, vmax, vsum, vnorm2, vrms

        ## Here we check the existence of the meshVariable and so on before defining a new one
        ## (and potentially losing the handle to the old one)


def MeshVariable(
    varname: Union[str, list],
    mesh: &#34;underworld.mesh.Mesh&#34;,
    num_components: int,
    vtype: Optional[&#34;underworld.VarType&#34;] = None,
    degree: int = 1,
    continuous: bool = True,
):

    &#34;&#34;&#34;
    The MeshVariable class generates a variable supported by a finite element mesh and the
    underlying sympy representation that makes it possible to construct expressions that
    depend on the values of the MeshVariable.

    To set / read nodal values, use the numpy interface via the &#39;data&#39; property.

    Parameters
    ----------
    name :
        A textual name for this variable.
    mesh :
        The supporting underworld mesh.
    num_components :
        The number of components this variable has.
        For example, scalars will have `num_components=1`,
        while a 2d vector would have `num_components=2`.
    vtype :
        Optional. The underworld variable type for this variable.
        If not defined it will be inferred from `num_components`
        if possible.
    degree :
        The polynomial degree for this variable.

    &#34;&#34;&#34;

    if isinstance(varname, list):
        name = varname[0] + R&#34;+ \dots&#34;
    else:
        name = varname

    if mesh._accessed:
        print(
            &#34;It is not possible to add new variables to a mesh after existing variables have been accessed&#34;
        )
        print(&#34;Variable {name} has NOT been added&#34;)
        return

    ## Smash if already defined (we should check this BEFORE the old meshVariable object is destroyed)

    if name in mesh.vars.keys():
        print(f&#34;Variable with name {name} already exists on the mesh - Skipping.&#34;)
        return mesh.vars[name]

    return _MeshVariable(varname, mesh, num_components, vtype, degree, continuous)


class _MeshVariable(_api_tools.Stateful):
    @timing.routine_timer_decorator
    def __init__(
        self,
        varname: Union[str, list],
        mesh: &#34;underworld.mesh.Mesh&#34;,
        num_components: int,
        vtype: Optional[&#34;underworld.VarType&#34;] = None,
        degree: int = 1,
        continuous: bool = True,
    ):
        &#34;&#34;&#34;
        The MeshVariable class generates a variable supported by a finite element mesh and the
        underlying sympy representation that makes it possible to construct expressions that
        depend on the values of the MeshVariable.

        To set / read nodal values, use the numpy interface via the &#39;data&#39; property.

        Parameters
        ----------
        name :
            A textual name for this variable.
        mesh :
            The supporting underworld mesh.
        num_components :
            The number of components this variable has.
            For example, scalars will have `num_components=1`,
            while a 2d vector would have `num_components=2`.
        vtype :
            Optional. The underworld variable type for this variable.
            If not defined it will be inferred from `num_components`
            if possible.
        degree :
            The polynomial degree for this variable.
        continuous:
            True for continuous element discretisation across element boundaries.
            False for discontinuous values across element boundaries.
        &#34;&#34;&#34;

        if isinstance(varname, list):
            name = varname[0] + R&#34;+ \dots&#34;
        else:
            name = varname

        self._lvec = None
        self._gvec = None
        self._data = None
        self._is_accessed = False
        self._available = False

        self.name = name

        import re

        self.clean_name = re.sub(r&#34;[^a-zA-Z0-9]&#34;, &#34;&#34;, name)

        if vtype == None:
            if num_components == 1:
                vtype = uw.VarType.SCALAR
            elif num_components == mesh.dim:
                vtype = uw.VarType.VECTOR
            else:
                raise ValueError(
                    &#34;Unable to infer variable type from `num_components`. Please explicitly set the `vtype` parameter.&#34;
                )

        if not isinstance(vtype, uw.VarType):
            raise ValueError(
                &#34;&#39;vtype&#39; must be an instance of &#39;Variable_Type&#39;, for example `underworld.VarType.SCALAR`.&#34;
            )

        self.vtype = vtype
        self.mesh = mesh
        self.num_components = num_components
        self.degree = degree
        self.continuous = continuous

        options = PETSc.Options()
        name0 = self.clean_name
        options.setValue(f&#34;{name0}_petscspace_degree&#34;, degree)
        options.setValue(f&#34;{name0}_petscdualspace_lagrange_continuity&#34;, continuous)
        options.setValue(
            f&#34;{name0}_petscdualspace_lagrange_node_endpoints&#34;, False
        )  # only active if discontinuous

        dim = self.mesh.dm.getDimension()

        self.petsc_fe = PETSc.FE().createDefault(
            dim,
            num_components,
            self.mesh.isSimplex,
            self.mesh.qdegree,
            name0 + &#34;_&#34;,
            PETSc.COMM_WORLD,
        )

        self.field_id = self.mesh.dm.getNumFields()
        self.mesh.dm.setField(self.field_id, self.petsc_fe)

        # self.mesh.dm.clearDS()
        # self.mesh.dm.createDS()

        # create associated sympy function
        from underworld3.function import UnderworldFunction

        if vtype == uw.VarType.SCALAR:
            self._sym = sympy.Matrix.zeros(1, 1)
            self._sym[0] = UnderworldFunction(name, self, vtype)(*self.mesh.r)
            self._sym[0].mesh = self.mesh

            self._ijk = self._sym[0]

        elif vtype == uw.VarType.VECTOR:
            self._sym = sympy.Matrix.zeros(1, num_components)

            # Matrix form (any number of components)
            for comp in range(num_components):
                self._sym[0, comp] = UnderworldFunction(name, self, vtype, comp)(
                    *self.mesh.r
                )
                self._sym[0, comp].mesh = self.mesh

            # Spatial vector form (2 vectors and 3 vectors according to mesh dim)
            if num_components == mesh.dim:
                self._ijk = sympy.vector.matrix_to_vector(self._sym, self.mesh.N)
                # self.mesh.vector.to_vector(self._sym)

        elif (
            vtype == uw.VarType.COMPOSITE
        ):  # This is just to allow full control over the names of the components
            self._sym = sympy.Matrix.zeros(1, num_components)
            if isinstance(varname, list):
                if len(varname) == num_components:
                    for comp in range(num_components):
                        self._sym[0, comp] = UnderworldFunction(
                            varname[comp], self, vtype, comp
                        )(*self.mesh.r)
                        self._sym[0, comp].mesh = self.mesh

                else:
                    raise RuntimeError(
                        &#34;Please supply a list of names for all components of this vector&#34;
                    )
            else:
                for comp in range(num_components):
                    self._sym[0, comp] = UnderworldFunction(name, self, vtype, comp)(
                        *self.mesh.r
                    )

        super().__init__()

        self.mesh.vars[name] = self

        self.mesh.dm.clearDS()
        self.mesh.dm.createDS()

        return

    @timing.routine_timer_decorator
    def save(
        self, filename: str, name: Optional[str] = None, index: Optional[int] = None
    ):
        &#34;&#34;&#34;
        Append variable data to the specified mesh hdf5
        data file. The file must already exist.

        Parameters
        ----------
        filename :
            The filename of the mesh checkpoint file. It
            must already exist.
        name :
            Textual name for dataset. In particular, this
            will be used for XDMF generation. If not
            provided, the variable name will be used.
        index :
            Not currently supported. An optional index which
            might correspond to the timestep (for example).
        &#34;&#34;&#34;
        viewer = PETSc.ViewerHDF5().create(filename, &#34;a&#34;, comm=PETSc.COMM_WORLD)
        if index:
            raise RuntimeError(&#34;Recording `index` not currently supported&#34;)
            ## JM:To enable timestep recording, the following needs to be called.
            ## I&#39;m unsure if the corresponding xdmf functionality is enabled via
            ## the PETSc xdmf script.
            # PetscViewerHDF5PushTimestepping(cviewer)
            # viewer.setTimestep(index)

        if name:
            oldname = self._gvec.getName()
            self._gvec.setName(name)
        viewer(self._gvec)
        if name:
            self._gvec.setName(oldname)

    @property
    def fn(self) -&gt; sympy.Basic:
        &#34;&#34;&#34;
        The handle to the function view of this variable.
        &#34;&#34;&#34;
        return self._ijk

    @property
    def ijk(self) -&gt; sympy.Basic:
        &#34;&#34;&#34;
        The handle to the scalar / vector view of this variable.
        &#34;&#34;&#34;
        return self._ijk

    @property
    def sym(self) -&gt; sympy.Basic:
        &#34;&#34;&#34;
        The handle to the tensor view of this variable.
        &#34;&#34;&#34;
        return self._sym

    def _set_vec(self, available):

        if self._lvec == None:
            indexset, subdm = self.mesh.dm.createSubDM(self.field_id)
            # subdm = uw.cython.petsc_discretisation.petsc_fe_create_sub_dm(self.mesh.dm, self.field_id)

            self._lvec = subdm.createLocalVector()
            self._lvec.zeroEntries()  # not sure if required, but to be sure.
            self._gvec = subdm.createGlobalVector()
            self._gvec.setName(self.clean_name)  # This is set for checkpointing.
            self._gvec.zeroEntries()

        self._available = available

    def __del__(self):
        if self._lvec:
            self._lvec.destroy()
        if self._gvec:
            self._gvec.destroy()

    @property
    def vec(self) -&gt; PETSc.Vec:
        &#34;&#34;&#34;
        The corresponding PETSc local vector for this variable.
        &#34;&#34;&#34;
        if not self._available:
            raise RuntimeError(
                &#34;Vector must be accessed via the mesh `access()` context manager.&#34;
            )
        return self._lvec

    @property
    def data(self) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        Numpy proxy array to underlying variable data.
        Note that the returned array is a proxy for all the *local* nodal
        data, and is provided as 1d list.

        For both read and write, this array can only be accessed via the
        mesh `access()` context manager.
        &#34;&#34;&#34;
        if self._data is None:
            raise RuntimeError(
                &#34;Data must be accessed via the mesh `access()` context manager.&#34;
            )
        return self._data

    def min(self) -&gt; Union[float, tuple]:
        &#34;&#34;&#34;
        The global variable minimum value.
        &#34;&#34;&#34;
        if not self._lvec:
            raise RuntimeError(&#34;It doesn&#39;t appear that any data has been set.&#34;)

        if self.num_components == 1:
            return self._gvec.min()
        else:
            return tuple(
                [self._gvec.strideMin(i)[1] for i in range(self.num_components)]
            )

    def max(self) -&gt; Union[float, tuple]:
        &#34;&#34;&#34;
        The global variable maximum value.
        &#34;&#34;&#34;
        if not self._lvec:
            raise RuntimeError(&#34;It doesn&#39;t appear that any data has been set.&#34;)

        if self.num_components == 1:
            return self._gvec.max()
        else:
            return tuple(
                [self._gvec.strideMax(i)[1] for i in range(self.num_components)]
            )

    def sum(self) -&gt; Union[float, tuple]:
        &#34;&#34;&#34;
        The global variable sum value.
        &#34;&#34;&#34;
        if not self._lvec:
            raise RuntimeError(&#34;It doesn&#39;t appear that any data has been set.&#34;)

        if self.num_components == 1:
            return self._gvec.sum()
        else:
            cpts = []
            for i in range(0, self.num_components):
                cpts.append(self._gvec.strideSum(i))

            return tuple(cpts)

    def norm(self, norm_type) -&gt; Union[float, tuple]:
        &#34;&#34;&#34;
        The global variable norm value.

        norm_type: type of norm, one of
            - 0: NORM 1 ||v|| = sum_i | v_i |. ||A|| = max_j || v_*j ||
            - 1: NORM 2 ||v|| = sqrt(sum_i |v_i|^2) (vectors only)
            - 3: NORM INFINITY ||v|| = max_i |v_i|. ||A|| = max_i || v_i* ||, maximum row sum
        &#34;&#34;&#34;
        if not self._lvec:
            raise RuntimeError(&#34;It doesn&#39;t appear that any data has been set.&#34;)

        if self.num_components &gt; 1 and norm_type == 2:
            raise RuntimeError(&#34;Norm 2 is only available for vectors.&#34;)

        if self.num_components == 1:
            return self._gvec.norm(norm_type)
        else:
            return tuple(
                [
                    self._gvec.strideNorm(i, norm_type)
                    for i in range(self.num_components)
                ]
            )

    def mean(self) -&gt; Union[float, tuple]:
        &#34;&#34;&#34;
        The global variable mean value.
        &#34;&#34;&#34;
        if not self._lvec:
            raise RuntimeError(&#34;It doesn&#39;t appear that any data has been set.&#34;)

        if self.num_components == 1:
            vecsize = self._gvec.getSize()
            return self._gvec.sum() / vecsize
        else:
            vecsize = self._gvec.getSize() / self.num_components
            return tuple(
                [self._gvec.strideSum(i) / vecsize for i in range(self.num_components)]
            )

    def stats(self):
        &#34;&#34;&#34;
        The equivalent of mesh.stats but using the native coordinates for this variable
        Not set up for vector variables so we just skip that for now.

        Returns various norms on the mesh using the native mesh discretisation for this
        variable. It is a wrapper on the various _gvec stats routines for the variable.

          - size
          - mean
          - min
          - max
          - sum
          - L2 norm
          - rms
        &#34;&#34;&#34;

        if self.num_components &gt; 1:
            raise NotImplementedError(
                &#34;stats not available for multi-component variables&#34;
            )

        #       This uses a private work MeshVariable and the various norms defined there but
        #       could either be simplified to just use petsc vectors, or extended to
        #       compute integrals over the elements which is in line with uw1 and uw2

        from petsc4py.PETSc import NormType

        vsize = self._gvec.getSize()
        vmean = self.mean()
        vmax = self.max()[1]
        vmin = self.min()[1]
        vsum = self.sum()
        vnorm2 = self.norm(NormType.NORM_2)
        vrms = vnorm2 / numpy.sqrt(vsize)

        return vsize, vmean, vmin, vmax, vsum, vnorm2, vrms

    @property
    def coords(self) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        The array of variable vertex coordinates.
        &#34;&#34;&#34;
        return self.mesh._get_coords_for_var(self)

    # vector calculus routines - the advantage of using these inbuilt routines is
    # that they are tied to the appropriate mesh definition.

    def divergence(self):
        try:
            return self.mesh.vector.divergence(self.sym)
        except:
            return None

    def gradient(self):
        try:
            return self.mesh.vector.gradient(self.sym)
        except:
            return None

    def curl(self):
        try:
            return self.mesh.vector.curl(self.sym)
        except:
            return None

    def jacobian(self):
        ## validate if this is a vector ?
        return self.mesh.vector.jacobian(self.sym)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="underworld3.discretisation.MeshVariable"><code class="name flex">
<span>def <span class="ident">MeshVariable</span></span>(<span>varname: Union[str, list], mesh: underworld.mesh.Mesh, num_components: int, vtype: Optional[ForwardRef('underworld.VarType')] = None, degree: int = 1, continuous: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>The MeshVariable class generates a variable supported by a finite element mesh and the
underlying sympy representation that makes it possible to construct expressions that
depend on the values of the MeshVariable.</p>
<p>To set / read nodal values, use the numpy interface via the 'data' property.</p>
<h2 id="parameters">Parameters</h2>
<p>name :
A textual name for this variable.
mesh :
The supporting underworld mesh.
num_components :
The number of components this variable has.
For example, scalars will have <code>num_components=1</code>,
while a 2d vector would have <code>num_components=2</code>.
vtype :
Optional. The underworld variable type for this variable.
If not defined it will be inferred from <code>num_components</code>
if possible.
degree :
The polynomial degree for this variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MeshVariable(
    varname: Union[str, list],
    mesh: &#34;underworld.mesh.Mesh&#34;,
    num_components: int,
    vtype: Optional[&#34;underworld.VarType&#34;] = None,
    degree: int = 1,
    continuous: bool = True,
):

    &#34;&#34;&#34;
    The MeshVariable class generates a variable supported by a finite element mesh and the
    underlying sympy representation that makes it possible to construct expressions that
    depend on the values of the MeshVariable.

    To set / read nodal values, use the numpy interface via the &#39;data&#39; property.

    Parameters
    ----------
    name :
        A textual name for this variable.
    mesh :
        The supporting underworld mesh.
    num_components :
        The number of components this variable has.
        For example, scalars will have `num_components=1`,
        while a 2d vector would have `num_components=2`.
    vtype :
        Optional. The underworld variable type for this variable.
        If not defined it will be inferred from `num_components`
        if possible.
    degree :
        The polynomial degree for this variable.

    &#34;&#34;&#34;

    if isinstance(varname, list):
        name = varname[0] + R&#34;+ \dots&#34;
    else:
        name = varname

    if mesh._accessed:
        print(
            &#34;It is not possible to add new variables to a mesh after existing variables have been accessed&#34;
        )
        print(&#34;Variable {name} has NOT been added&#34;)
        return

    ## Smash if already defined (we should check this BEFORE the old meshVariable object is destroyed)

    if name in mesh.vars.keys():
        print(f&#34;Variable with name {name} already exists on the mesh - Skipping.&#34;)
        return mesh.vars[name]

    return _MeshVariable(varname, mesh, num_components, vtype, degree, continuous)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.discretisation.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>plex_or_meshfile, degree=1, simplex=True, coordinate_system_type=None, qdegree=2, cellSets=None, vertexSets=None, faceSets=None, filename=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a mixin class for underworld objects that are stateful.
The state of an object is incremented whenever it is modified.
For example, heavy variables have states, and when a user modifies
it within its <code>access()</code> context manager, its state is incremented
at the conclusion of their modifications.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mesh(_api_tools.Stateful):

    mesh_instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        plex_or_meshfile,
        degree=1,
        simplex=True,
        coordinate_system_type=None,
        qdegree=2,
        cellSets=None,
        vertexSets=None,
        faceSets=None,
        filename=None,
        *args,
        **kwargs,
    ):

        if isinstance(plex_or_meshfile, PETSc.DMPlex):
            name = &#34;plexmesh&#34;
            self.dm = plex_or_meshfile
        else:
            comm = kwargs.get(&#34;comm&#34;, PETSc.COMM_WORLD)
            name = plex_or_meshfile
            basename, ext = os.path.splitext(plex_or_meshfile)

            # Note: should be able to handle a .geo as well on this pathway
            if ext.lower() == &#34;.msh&#34;:
                self.dm = _from_gmsh(
                    plex_or_meshfile, comm, cellSets, faceSets, vertexSets
                )
            else:
                raise RuntimeError(
                    &#34;Mesh file %s has unknown format &#39;%s&#39;.&#34;
                    % (plex_or_meshfile, ext[1:])
                )

        self.filename = filename
        self.dm.markBoundaryFaces(&#34;All_Boundaries&#34;, 1001)
        self.dm.distribute()

        Mesh.mesh_instances += 1

        # Set sympy constructs. First a generic, symbolic, Cartesian coordinate system
        from sympy.vector import CoordSys3D

        # A unique set of vectors / names for each mesh instance
        self._N = CoordSys3D(f&#34;N{Mesh.mesh_instances}&#34;)

        self._N.x._latex_form = r&#34;\mathrm{\xi_0}&#34;
        self._N.y._latex_form = r&#34;\mathrm{\xi_1}&#34;
        self._N.z._latex_form = r&#34;\mathrm{\xi_2}&#34;
        self._N.i._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_0}&#34;
        self._N.j._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_1}&#34;
        self._N.k._latex_form = r&#34;\mathbf{\hat{\mathbf{e}}_2}&#34;

        # Now add the appropriate coordinate system for the mesh&#39;s natural geometry
        # This step will usually over-write the defaults we just defined
        self._CoordinateSystem = CoordinateSystem(self, coordinate_system_type)

        # Tidy some of this printing without changing the
        # underlying vector names (as these are part of the code generation system)

        try:
            self.isSimplex = self.dm.isSimplex()
        except:
            self.isSimplex = simplex

        # Use grid hashing for point location
        options = PETSc.Options()
        options[&#34;dm_plex_hash_location&#34;] = None
        self.dm.setFromOptions()

        self._vars = weakref.WeakValueDictionary()

        # a list of equation systems that will
        # need to be rebuilt if the mesh coordinates change

        self._equation_systems_register = []

        self._accessed = False
        self._quadrature = False
        self._stale_lvec = True
        self._lvec = None
        self.petsc_fe = None

        self.degree = degree
        self.qdegree = qdegree

        self.nuke_coords_and_rebuild()

        # A private work array used in the stats routines.
        # This is defined now since we cannot make a new one
        # once the init phase of uw3 is complete.

        self._work_MeshVar = MeshVariable(&#34;work_array_1&#34;, self, 1, degree=2)

        # This looks a bit strange, but we&#39;d like to
        # put these mesh-dependent vector calculus functions
        # and mesh-based tensor manipulation routines
        # in a bundle to avoid the mesh being required as an argument
        # since this could lead to things going out of sync

        if (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL2D_NATIVE
            or self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.CYLINDRICAL3D_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_cylindrical(
                mesh=self,
            )
        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERICAL_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical(
                mesh=self,
            )  ## Not yet complete or tested

        elif (
            self.CoordinateSystem.coordinate_type
            == CoordinateSystemType.SPHERE_SURFACE_NATIVE
        ):
            self.vector = uw.maths.vector_calculus_spherical_surface2D_lonlat(
                mesh=self,
            )

        else:
            self.vector = uw.maths.vector_calculus(mesh=self)

        super().__init__()

    @property
    def dim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getDimension()

    @property
    def cdim(self) -&gt; int:
        &#34;&#34;&#34;
        The mesh dimensionality.
        &#34;&#34;&#34;
        return self.dm.getCoordinateDim()

    def nuke_coords_and_rebuild(self):

        # This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)

        self._coord_array = {}

        # let&#39;s go ahead and do an initial projection from linear (the default)
        # to linear. this really is a nothing operation, but a
        # side effect of this operation is that coordinate DM DMField is
        # converted to the required `PetscFE` type. this may become necessary
        # later where we call the interpolation routines to project from the linear
        # mesh coordinates to other mesh coordinates.

        options = PETSc.Options()
        options.setValue(
            &#34;meshproj_{}_petscspace_degree&#34;.format(self.mesh_instances), self.degree
        )

        self.petsc_fe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;meshproj_{}_&#34;.format(self.mesh_instances),
            PETSc.COMM_WORLD,
        )

        if self.degree != 1:

            # We have to be careful as a projection onto an equivalent PETScFE can cause problematic
            # issues with petsc that we see in parallel - in which case there is a fallback, pass no
            # PETScFE and let PETSc decide. Note that the petsc4py wrapped version does not allow this
            # (but it should !)

            self.dm.projectCoordinates(self.petsc_fe)

        else:

            uw.cython.petsc_discretisation.petsc_dm_project_coordinates(self.dm)

        # now set copy of this array into dictionary

        arr = self.dm.getCoordinatesLocal().array

        key = (
            self.isSimplex,
            self.degree,
            True,
        )  # True here assumes continuous basis for coordinates ...

        self._coord_array[key] = arr.reshape(-1, self.cdim).copy()

        # self._centroids = self._get_coords_for_basis(0, True)
        self._centroids = self._get_mesh_centroids()

        # invalidate the cell-search k-d tree and the mesh centroid data
        self._index = None

        return

    @timing.routine_timer_decorator
    def update_lvec(self):
        &#34;&#34;&#34;
        This method creates and/or updates the mesh variable local vector.
        If the local vector is already up to date, this method will do nothing.
        &#34;&#34;&#34;

        if self._stale_lvec:
            if not self._lvec:
                # self.dm.clearDS()
                # self.dm.createDS()
                # create the local vector (memory chunk) and attach to original dm
                self._lvec = self.dm.createLocalVec()
            # push avar arrays into the parent dm array
            a_global = self.dm.getGlobalVec()
            names, isets, dms = self.dm.createFieldDecomposition()

            with self.access():
                # traverse subdms, taking user generated data in the subdm
                # local vec, pushing it into a global sub vec
                for var, subiset, subdm in zip(self.vars.values(), isets, dms):
                    lvec = var.vec
                    subvec = a_global.getSubVector(subiset)
                    subdm.localToGlobal(lvec, subvec, addv=False)
                    a_global.restoreSubVector(subiset, subvec)

            self.dm.globalToLocal(a_global, self._lvec)
            self.dm.restoreGlobalVec(a_global)
            self._stale_lvec = False

    @property
    def lvec(self) -&gt; PETSc.Vec:
        &#34;&#34;&#34;
        Returns a local Petsc vector containing the flattened array
        of all the mesh variables.
        &#34;&#34;&#34;
        if self._stale_lvec:
            raise RuntimeError(
                &#34;Mesh `lvec` needs to be updated using the update_lvec()` method.&#34;
            )
        return self._lvec

    def __del__(self):
        if hasattr(self, &#34;_lvec&#34;) and self._lvec:
            self._lvec.destroy()

    def deform_mesh(self, new_coords: numpy.ndarray):
        &#34;&#34;&#34;
        This method will update the mesh coordinates and reset any cached coordinates in
        the mesh and in equation systems that are registered on the mesh.

        The coord array that is passed in should match the shape of self.data
        &#34;&#34;&#34;

        coord_vec = self.dm.getCoordinatesLocal()
        coords = coord_vec.array.reshape(-1, self.cdim)
        coords[...] = new_coords[...]

        self.dm.setCoordinatesLocal(coord_vec)
        self.nuke_coords_and_rebuild()

        for eq_system in self._equation_systems_register:
            eq_system._rebuild_after_mesh_update()

        return

    def access(self, *writeable_vars: &#34;MeshVariable&#34;):
        &#34;&#34;&#34;
        This context manager makes the underlying mesh variables data available to
        the user. The data should be accessed via the variables `data` handle.

        As default, all data is read-only. To enable writeable data, the user should
        specify which variable they wish to modify.

        Parameters
        ----------
        writeable_vars
            The variables for which data write access is required.

        Example
        -------
        &gt;&gt;&gt; import underworld3 as uw
        &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
        &gt;&gt;&gt; with someMesh.deform_mesh():
        ...     someMesh.data[0] = [0.1,0.1]
        &gt;&gt;&gt; someMesh.data[0]
        array([ 0.1,  0.1])
        &#34;&#34;&#34;

        import time

        timing._incrementDepth()
        stime = time.time()

        self._accessed = True
        deaccess_list = []
        for var in self.vars.values():
            # if already accessed within higher level context manager, continue.
            if var._is_accessed == True:
                continue

            # set flag so variable status can be known elsewhere
            var._is_accessed = True
            # add to de-access list to rewind this later
            deaccess_list.append(var)

            # create &amp; set vec
            var._set_vec(available=True)

            # grab numpy object, setting read only if necessary
            var._data = var.vec.array.reshape(-1, var.num_components)

            if var not in writeable_vars:
                var._old_data_flag = var._data.flags.writeable
                var._data.flags.writeable = False
            else:
                # increment variable state
                var._increment()

        class exit_manager:
            def __init__(self, mesh):
                self.mesh = mesh

            def __enter__(self):
                pass

            def __exit__(self, *args):
                for var in self.mesh.vars.values():
                    # only de-access variables we have set access for.
                    if var not in deaccess_list:
                        continue
                    # set this back, although possibly not required.
                    if var not in writeable_vars:
                        var._data.flags.writeable = var._old_data_flag
                    # perform sync for any modified vars.

                    if var in writeable_vars:
                        indexset, subdm = self.mesh.dm.createSubDM(var.field_id)

                        # sync ghost values
                        subdm.localToGlobal(var.vec, var._gvec, addv=False)
                        subdm.globalToLocal(var._gvec, var.vec, addv=False)

                        # subdm.destroy()
                        self.mesh._stale_lvec = True

                    var._data = None
                    var._set_vec(available=False)
                    var._is_accessed = False

                timing._decrementDepth()
                timing.log_result(time.time() - stime, &#34;Mesh.access&#34;, 1)

        return exit_manager(self)

    @property
    def N(self) -&gt; sympy.vector.CoordSys3D:
        &#34;&#34;&#34;
        The mesh coordinate system.
        &#34;&#34;&#34;
        return self._N

    @property
    def X(self) -&gt; sympy.Matrix:
        return self._CoordinateSystem.X

    @property
    def CoordinateSystem(self) -&gt; CoordinateSystem:
        return self._CoordinateSystem

    @property
    def r(self) -&gt; Tuple[sympy.vector.BaseScalar]:
        &#34;&#34;&#34;
        The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.
        &#34;&#34;&#34;
        return self._N.base_scalars()[0 : self.cdim]

    @property
    def rvec(self) -&gt; sympy.vector.Vector:
        &#34;&#34;&#34;
        The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.
        &#34;&#34;&#34;
        N = self.N

        r_vec = sympy.vector.Vector.zero

        N_s = N.base_scalars()
        N_v = N.base_vectors()
        for i in range(self.cdim):
            r_vec += N_s[i] * N_v[i]

        return r_vec

    @property
    def data(self) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        The array of mesh element vertex coordinates.
        &#34;&#34;&#34;
        # get flat array
        arr = self.dm.getCoordinatesLocal().array
        return arr.reshape(-1, self.cdim)

    @timing.routine_timer_decorator
    def save(self, filename: str, index: Optional[int] = None):
        &#34;&#34;&#34;
        Save mesh data to the specified hdf5 file.

        Users will generally create this file, and then
        append mesh variable data to it via the variable
        `save` method.

        Parameters
        ----------
        filename :
            The filename for the mesh checkpoint file.
        index :
            Not yet implemented. An optional index which might
            correspond to the timestep (for example).

        &#34;&#34;&#34;
        viewer = PETSc.ViewerHDF5().create(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        if index:
            raise RuntimeError(&#34;Recording `index` not currently supported&#34;)
            ## JM:To enable timestep recording, the following needs to be called.
            ## I&#39;m unsure if the corresponding xdmf functionality is enabled via
            ## the PETSc xdmf script.
            # viewer.pushTimestepping(viewer)
            # viewer.setTimestep(index)
        viewer(self.dm)

    def vtk(self, filename: str):
        &#34;&#34;&#34;
        Save mesh to the specified file
        &#34;&#34;&#34;

        viewer = PETSc.Viewer().createVTK(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
        viewer(self.dm)

    def generate_xdmf(self, filename: str):
        &#34;&#34;&#34;
        This method generates an xdmf schema for the specified file.

        The filename of the generated file will be the same as the hdf5 file
        but with the `xmf` extension.

        Parameters
        ----------
        filename :
            File name of the checkpointed hdf5 file for which the
            xdmf schema will be written.
        &#34;&#34;&#34;
        from underworld3.utilities import generateXdmf

        generateXdmf(filename)

    @property
    def vars(self):
        &#34;&#34;&#34;
        A list of variables recorded on the mesh.
        &#34;&#34;&#34;
        return self._vars

    def _get_coords_for_var(self, var):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;
        key = (self.isSimplex, var.degree, var.continuous)

        # if array already created, return.
        if key in self._coord_array:
            return self._coord_array[key]
        else:
            self._coord_array[key] = self._get_coords_for_basis(
                var.degree, var.continuous
            )
            return self._coord_array[key]

    def _get_coords_for_basis(self, degree, continuous):
        &#34;&#34;&#34;
        This function returns the vertex array for the
        provided variable. If the array does not already exist,
        it is first created and then returned.
        &#34;&#34;&#34;

        dmold = self.dm.getCoordinateDM()
        dmold.createDS()

        dmnew = dmold.clone()

        options = PETSc.Options()
        options[&#34;coordinterp_petscspace_degree&#34;] = degree
        options[&#34;coordinterp_petscdualspace_lagrange_continuity&#34;] = continuous
        options[&#34;coordinterp_petscdualspace_lagrange_node_endpoints&#34;] = False

        dmfe = PETSc.FE().createDefault(
            self.dim,
            self.cdim,
            self.isSimplex,
            self.qdegree,
            &#34;coordinterp_&#34;,
            PETSc.COMM_WORLD,
        )

        dmnew.setField(0, dmfe)
        dmnew.createDS()

        matInterp, vecScale = dmold.createInterpolation(dmnew)
        coordsOld = self.dm.getCoordinates()
        coordsNewL = dmnew.getLocalVec()
        coordsNewG = matInterp * coordsOld
        dmnew.globalToLocal(coordsNewG, coordsNewL)

        arr = coordsNewL.array
        arrcopy = arr.reshape(-1, self.cdim).copy()

        return arrcopy

    @timing.routine_timer_decorator
    def get_closest_cells(self, coords: numpy.ndarray) -&gt; numpy.ndarray:
        &#34;&#34;&#34;
        This method uses a kd-tree algorithm to find the closest
        cells to the provided coords. For a regular mesh, this should
        be exactly the owning cell, but if the mesh is deformed, this
        is not guaranteed.

        Parameters:
        -----------
        coords:
            An array of the coordinates for which we wish to determine the
            closest cells. This should be a 2-dimensional array of
            shape (n_coords,dim).

        Returns:
        --------
        closest_cells:
            An array of indices representing the cells closest to the provided
            coordinates. This will be a 1-dimensional array of
            shape (n_coords).
        &#34;&#34;&#34;
        # Create index if required
        if not self._index:
            from underworld3.swarm import Swarm, SwarmPICLayout

            # Create a temp swarm which we&#39;ll use to populate particles
            # at gauss points. These will then be used as basis for
            # kd-tree indexing back to owning cells.
            tempSwarm = Swarm(self)
            # 4^dim pop is used. This number may need to be considered
            # more carefully, or possibly should be coded to be set dynamically.
            tempSwarm.populate(fill_param=4, layout=SwarmPICLayout.GAUSS)
            with tempSwarm.access():
                # Build index on particle coords
                self._indexCoords = tempSwarm.particle_coordinates.data.copy()
                self._index = uw.kdtree.KDTree(self._indexCoords)
                self._index.build_index()
                # Grab mapping back to cell_ids.
                # Note that this is the numpy array that we eventually return from this
                # method. As such, we take measures to ensure that we use `numpy.int64` here
                # because we cast from this type in  `_function.evaluate` to construct
                # the PETSc cell-sf datasets, and if instead a `numpy.int32` is used it
                # will cause bugs that are difficult to find.
                self._indexMap = numpy.array(
                    tempSwarm.particle_cellid.data[:, 0], dtype=numpy.int64
                )

        closest_points, dist, found = self._index.find_closest_point(coords)

        if not numpy.allclose(found, True):
            raise RuntimeError(
                &#34;An error was encountered attempting to find the closest cells to the provided coordinates.&#34;
            )

        return self._indexMap[closest_points]

    def _get_mesh_centroids(self):
        &#34;&#34;&#34;
        Obtain and cache the mesh centroids using underworld swarm technology.
        This routine is called when the mesh is built / rebuilt
        &#34;&#34;&#34;

        from underworld3.swarm import Swarm, SwarmPICLayout

        tempSwarm = Swarm(self)
        tempSwarm.populate(fill_param=1, layout=SwarmPICLayout.GAUSS)

        with tempSwarm.access():
            # Build index on particle coords
            centroids = tempSwarm.data.copy()

        return centroids

    def get_min_radius(self) -&gt; float:
        &#34;&#34;&#34;
        This method returns the minimum distance from any cell centroid to a face.
        It wraps to the PETSc `DMPlexGetMinRadius` routine.
        &#34;&#34;&#34;

        ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
        ## does not obtain the minimum radius for the mesh.

        from underworld3.cython.petsc_discretisation import petsc_fvm_get_min_radius

        if (not hasattr(self, &#34;_min_radius&#34;)) or (self._min_radius == None):
            self._min_radius = petsc_fvm_get_min_radius(self)

        return self._min_radius

    # def get_boundary_subdm(self) -&gt; PETSc.DM:
    #     &#34;&#34;&#34;
    #     This method returns the boundary subdm that wraps DMPlexCreateSubmesh
    #     &#34;&#34;&#34;
    #     from underworld3.petsc_discretisation import petsc_create_surface_submesh
    #     return petsc_create_surface_submesh(self, &#34;Boundary&#34;, 666, )

    def stats(self, uw_function):
        &#34;&#34;&#34;
        Returns various norms on the mesh for the provided function.
          - size
          - mean
          - min
          - max
          - sum
          - L2 norm
          - rms

          NOTE: this currently assumes scalar variables !
        &#34;&#34;&#34;

        #       This uses a private work MeshVariable and the various norms defined there but
        #       could either be simplified to just use petsc vectors, or extended to
        #       compute integrals over the elements which is in line with uw1 and uw2

        from petsc4py.PETSc import NormType

        tmp = self._work_MeshVar

        with self.access(tmp):
            tmp.data[...] = uw.function.evaluate(uw_function, tmp.coords).reshape(-1, 1)

        vsize = self._work_MeshVar._gvec.getSize()
        vmean = tmp.mean()
        vmax = tmp.max()[1]
        vmin = tmp.min()[1]
        vsum = tmp.sum()
        vnorm2 = tmp.norm(NormType.NORM_2)
        vrms = vnorm2 / numpy.sqrt(vsize)

        return vsize, vmean, vmin, vmax, vsum, vnorm2, vrms

        ## Here we check the existence of the meshVariable and so on before defining a new one
        ## (and potentially losing the handle to the old one)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.utilities._api_tools.Stateful</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.mesh_instances"><code class="name">var <span class="ident">mesh_instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.CoordinateSystem"><code class="name">var <span class="ident">CoordinateSystem</span> : <a title="underworld3.coordinates.CoordinateSystem" href="coordinates.html#underworld3.coordinates.CoordinateSystem">CoordinateSystem</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def CoordinateSystem(self) -&gt; CoordinateSystem:
    return self._CoordinateSystem</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.N"><code class="name">var <span class="ident">N</span> : sympy.vector.coordsysrect.CoordSys3D</code></dt>
<dd>
<div class="desc"><p>The mesh coordinate system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def N(self) -&gt; sympy.vector.CoordSys3D:
    &#34;&#34;&#34;
    The mesh coordinate system.
    &#34;&#34;&#34;
    return self._N</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.X"><code class="name">var <span class="ident">X</span> : sympy.matrices.dense.MutableDenseMatrix</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def X(self) -&gt; sympy.Matrix:
    return self._CoordinateSystem.X</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.cdim"><code class="name">var <span class="ident">cdim</span> : int</code></dt>
<dd>
<div class="desc"><p>The mesh dimensionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cdim(self) -&gt; int:
    &#34;&#34;&#34;
    The mesh dimensionality.
    &#34;&#34;&#34;
    return self.dm.getCoordinateDim()</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.data"><code class="name">var <span class="ident">data</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>The array of mesh element vertex coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data(self) -&gt; numpy.ndarray:
    &#34;&#34;&#34;
    The array of mesh element vertex coordinates.
    &#34;&#34;&#34;
    # get flat array
    arr = self.dm.getCoordinatesLocal().array
    return arr.reshape(-1, self.cdim)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.dim"><code class="name">var <span class="ident">dim</span> : int</code></dt>
<dd>
<div class="desc"><p>The mesh dimensionality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dim(self) -&gt; int:
    &#34;&#34;&#34;
    The mesh dimensionality.
    &#34;&#34;&#34;
    return self.dm.getDimension()</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.lvec"><code class="name">var <span class="ident">lvec</span> : petsc4py.PETSc.Vec</code></dt>
<dd>
<div class="desc"><p>Returns a local Petsc vector containing the flattened array
of all the mesh variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lvec(self) -&gt; PETSc.Vec:
    &#34;&#34;&#34;
    Returns a local Petsc vector containing the flattened array
    of all the mesh variables.
    &#34;&#34;&#34;
    if self._stale_lvec:
        raise RuntimeError(
            &#34;Mesh `lvec` needs to be updated using the update_lvec()` method.&#34;
        )
    return self._lvec</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.r"><code class="name">var <span class="ident">r</span> : Tuple[sympy.vector.scalar.BaseScalar]</code></dt>
<dd>
<div class="desc"><p>The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def r(self) -&gt; Tuple[sympy.vector.BaseScalar]:
    &#34;&#34;&#34;
    The tuple of base scalar objects (N.x,N.y,N.z) for the mesh.
    &#34;&#34;&#34;
    return self._N.base_scalars()[0 : self.cdim]</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.rvec"><code class="name">var <span class="ident">rvec</span> : sympy.vector.vector.Vector</code></dt>
<dd>
<div class="desc"><p>The r vector, <code>r = N.x*N.i + N.y*N.j [+ N.z*N.k]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rvec(self) -&gt; sympy.vector.Vector:
    &#34;&#34;&#34;
    The r vector, `r = N.x*N.i + N.y*N.j [+ N.z*N.k]`.
    &#34;&#34;&#34;
    N = self.N

    r_vec = sympy.vector.Vector.zero

    N_s = N.base_scalars()
    N_v = N.base_vectors()
    for i in range(self.cdim):
        r_vec += N_s[i] * N_v[i]

    return r_vec</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.vars"><code class="name">var <span class="ident">vars</span></code></dt>
<dd>
<div class="desc"><p>A list of variables recorded on the mesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def vars(self):
    &#34;&#34;&#34;
    A list of variables recorded on the mesh.
    &#34;&#34;&#34;
    return self._vars</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.discretisation.Mesh.access"><code class="name flex">
<span>def <span class="ident">access</span></span>(<span>self, *writeable_vars: MeshVariable)</span>
</code></dt>
<dd>
<div class="desc"><p>This context manager makes the underlying mesh variables data available to
the user. The data should be accessed via the variables <code>data</code> handle.</p>
<p>As default, all data is read-only. To enable writeable data, the user should
specify which variable they wish to modify.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>writeable_vars</code></strong></dt>
<dd>The variables for which data write access is required.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python">&gt;&gt;&gt; import underworld3 as uw
&gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
&gt;&gt;&gt; with someMesh.deform_mesh():
...     someMesh.data[0] = [0.1,0.1]
&gt;&gt;&gt; someMesh.data[0]
array([ 0.1,  0.1])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def access(self, *writeable_vars: &#34;MeshVariable&#34;):
    &#34;&#34;&#34;
    This context manager makes the underlying mesh variables data available to
    the user. The data should be accessed via the variables `data` handle.

    As default, all data is read-only. To enable writeable data, the user should
    specify which variable they wish to modify.

    Parameters
    ----------
    writeable_vars
        The variables for which data write access is required.

    Example
    -------
    &gt;&gt;&gt; import underworld3 as uw
    &gt;&gt;&gt; someMesh = uw.discretisation.FeMesh_Cartesian()
    &gt;&gt;&gt; with someMesh.deform_mesh():
    ...     someMesh.data[0] = [0.1,0.1]
    &gt;&gt;&gt; someMesh.data[0]
    array([ 0.1,  0.1])
    &#34;&#34;&#34;

    import time

    timing._incrementDepth()
    stime = time.time()

    self._accessed = True
    deaccess_list = []
    for var in self.vars.values():
        # if already accessed within higher level context manager, continue.
        if var._is_accessed == True:
            continue

        # set flag so variable status can be known elsewhere
        var._is_accessed = True
        # add to de-access list to rewind this later
        deaccess_list.append(var)

        # create &amp; set vec
        var._set_vec(available=True)

        # grab numpy object, setting read only if necessary
        var._data = var.vec.array.reshape(-1, var.num_components)

        if var not in writeable_vars:
            var._old_data_flag = var._data.flags.writeable
            var._data.flags.writeable = False
        else:
            # increment variable state
            var._increment()

    class exit_manager:
        def __init__(self, mesh):
            self.mesh = mesh

        def __enter__(self):
            pass

        def __exit__(self, *args):
            for var in self.mesh.vars.values():
                # only de-access variables we have set access for.
                if var not in deaccess_list:
                    continue
                # set this back, although possibly not required.
                if var not in writeable_vars:
                    var._data.flags.writeable = var._old_data_flag
                # perform sync for any modified vars.

                if var in writeable_vars:
                    indexset, subdm = self.mesh.dm.createSubDM(var.field_id)

                    # sync ghost values
                    subdm.localToGlobal(var.vec, var._gvec, addv=False)
                    subdm.globalToLocal(var._gvec, var.vec, addv=False)

                    # subdm.destroy()
                    self.mesh._stale_lvec = True

                var._data = None
                var._set_vec(available=False)
                var._is_accessed = False

            timing._decrementDepth()
            timing.log_result(time.time() - stime, &#34;Mesh.access&#34;, 1)

    return exit_manager(self)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.deform_mesh"><code class="name flex">
<span>def <span class="ident">deform_mesh</span></span>(<span>self, new_coords: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will update the mesh coordinates and reset any cached coordinates in
the mesh and in equation systems that are registered on the mesh.</p>
<p>The coord array that is passed in should match the shape of self.data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deform_mesh(self, new_coords: numpy.ndarray):
    &#34;&#34;&#34;
    This method will update the mesh coordinates and reset any cached coordinates in
    the mesh and in equation systems that are registered on the mesh.

    The coord array that is passed in should match the shape of self.data
    &#34;&#34;&#34;

    coord_vec = self.dm.getCoordinatesLocal()
    coords = coord_vec.array.reshape(-1, self.cdim)
    coords[...] = new_coords[...]

    self.dm.setCoordinatesLocal(coord_vec)
    self.nuke_coords_and_rebuild()

    for eq_system in self._equation_systems_register:
        eq_system._rebuild_after_mesh_update()

    return</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.generate_xdmf"><code class="name flex">
<span>def <span class="ident">generate_xdmf</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This method generates an xdmf schema for the specified file.</p>
<p>The filename of the generated file will be the same as the hdf5 file
but with the <code>xmf</code> extension.</p>
<h2 id="parameters">Parameters</h2>
<p>filename :
File name of the checkpointed hdf5 file for which the
xdmf schema will be written.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_xdmf(self, filename: str):
    &#34;&#34;&#34;
    This method generates an xdmf schema for the specified file.

    The filename of the generated file will be the same as the hdf5 file
    but with the `xmf` extension.

    Parameters
    ----------
    filename :
        File name of the checkpointed hdf5 file for which the
        xdmf schema will be written.
    &#34;&#34;&#34;
    from underworld3.utilities import generateXdmf

    generateXdmf(filename)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.get_closest_cells"><code class="name flex">
<span>def <span class="ident">get_closest_cells</span></span>(<span>self, coords: numpy.ndarray) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>This method uses a kd-tree algorithm to find the closest
cells to the provided coords. For a regular mesh, this should
be exactly the owning cell, but if the mesh is deformed, this
is not guaranteed.</p>
<h2 id="parameters">Parameters:</h2>
<p>coords:
An array of the coordinates for which we wish to determine the
closest cells. This should be a 2-dimensional array of
shape (n_coords,dim).</p>
<h2 id="returns">Returns:</h2>
<p>closest_cells:
An array of indices representing the cells closest to the provided
coordinates. This will be a 1-dimensional array of
shape (n_coords).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def get_closest_cells(self, coords: numpy.ndarray) -&gt; numpy.ndarray:
    &#34;&#34;&#34;
    This method uses a kd-tree algorithm to find the closest
    cells to the provided coords. For a regular mesh, this should
    be exactly the owning cell, but if the mesh is deformed, this
    is not guaranteed.

    Parameters:
    -----------
    coords:
        An array of the coordinates for which we wish to determine the
        closest cells. This should be a 2-dimensional array of
        shape (n_coords,dim).

    Returns:
    --------
    closest_cells:
        An array of indices representing the cells closest to the provided
        coordinates. This will be a 1-dimensional array of
        shape (n_coords).
    &#34;&#34;&#34;
    # Create index if required
    if not self._index:
        from underworld3.swarm import Swarm, SwarmPICLayout

        # Create a temp swarm which we&#39;ll use to populate particles
        # at gauss points. These will then be used as basis for
        # kd-tree indexing back to owning cells.
        tempSwarm = Swarm(self)
        # 4^dim pop is used. This number may need to be considered
        # more carefully, or possibly should be coded to be set dynamically.
        tempSwarm.populate(fill_param=4, layout=SwarmPICLayout.GAUSS)
        with tempSwarm.access():
            # Build index on particle coords
            self._indexCoords = tempSwarm.particle_coordinates.data.copy()
            self._index = uw.kdtree.KDTree(self._indexCoords)
            self._index.build_index()
            # Grab mapping back to cell_ids.
            # Note that this is the numpy array that we eventually return from this
            # method. As such, we take measures to ensure that we use `numpy.int64` here
            # because we cast from this type in  `_function.evaluate` to construct
            # the PETSc cell-sf datasets, and if instead a `numpy.int32` is used it
            # will cause bugs that are difficult to find.
            self._indexMap = numpy.array(
                tempSwarm.particle_cellid.data[:, 0], dtype=numpy.int64
            )

    closest_points, dist, found = self._index.find_closest_point(coords)

    if not numpy.allclose(found, True):
        raise RuntimeError(
            &#34;An error was encountered attempting to find the closest cells to the provided coordinates.&#34;
        )

    return self._indexMap[closest_points]</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.get_min_radius"><code class="name flex">
<span>def <span class="ident">get_min_radius</span></span>(<span>self) -> float</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the minimum distance from any cell centroid to a face.
It wraps to the PETSc <code>DMPlexGetMinRadius</code> routine.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_min_radius(self) -&gt; float:
    &#34;&#34;&#34;
    This method returns the minimum distance from any cell centroid to a face.
    It wraps to the PETSc `DMPlexGetMinRadius` routine.
    &#34;&#34;&#34;

    ## Note: The petsc4py version of DMPlexComputeGeometryFVM does not compute all cells and
    ## does not obtain the minimum radius for the mesh.

    from underworld3.cython.petsc_discretisation import petsc_fvm_get_min_radius

    if (not hasattr(self, &#34;_min_radius&#34;)) or (self._min_radius == None):
        self._min_radius = petsc_fvm_get_min_radius(self)

    return self._min_radius</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.nuke_coords_and_rebuild"><code class="name flex">
<span>def <span class="ident">nuke_coords_and_rebuild</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nuke_coords_and_rebuild(self):

    # This is a reversion to the old version (3.15 compatible which seems to work in 3.16 too)

    self._coord_array = {}

    # let&#39;s go ahead and do an initial projection from linear (the default)
    # to linear. this really is a nothing operation, but a
    # side effect of this operation is that coordinate DM DMField is
    # converted to the required `PetscFE` type. this may become necessary
    # later where we call the interpolation routines to project from the linear
    # mesh coordinates to other mesh coordinates.

    options = PETSc.Options()
    options.setValue(
        &#34;meshproj_{}_petscspace_degree&#34;.format(self.mesh_instances), self.degree
    )

    self.petsc_fe = PETSc.FE().createDefault(
        self.dim,
        self.cdim,
        self.isSimplex,
        self.qdegree,
        &#34;meshproj_{}_&#34;.format(self.mesh_instances),
        PETSc.COMM_WORLD,
    )

    if self.degree != 1:

        # We have to be careful as a projection onto an equivalent PETScFE can cause problematic
        # issues with petsc that we see in parallel - in which case there is a fallback, pass no
        # PETScFE and let PETSc decide. Note that the petsc4py wrapped version does not allow this
        # (but it should !)

        self.dm.projectCoordinates(self.petsc_fe)

    else:

        uw.cython.petsc_discretisation.petsc_dm_project_coordinates(self.dm)

    # now set copy of this array into dictionary

    arr = self.dm.getCoordinatesLocal().array

    key = (
        self.isSimplex,
        self.degree,
        True,
    )  # True here assumes continuous basis for coordinates ...

    self._coord_array[key] = arr.reshape(-1, self.cdim).copy()

    # self._centroids = self._get_coords_for_basis(0, True)
    self._centroids = self._get_mesh_centroids()

    # invalidate the cell-search k-d tree and the mesh centroid data
    self._index = None

    return</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename: str, index: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save mesh data to the specified hdf5 file.</p>
<p>Users will generally create this file, and then
append mesh variable data to it via the variable
<code>save</code> method.</p>
<h2 id="parameters">Parameters</h2>
<p>filename :
The filename for the mesh checkpoint file.
index :
Not yet implemented. An optional index which might
correspond to the timestep (for example).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def save(self, filename: str, index: Optional[int] = None):
    &#34;&#34;&#34;
    Save mesh data to the specified hdf5 file.

    Users will generally create this file, and then
    append mesh variable data to it via the variable
    `save` method.

    Parameters
    ----------
    filename :
        The filename for the mesh checkpoint file.
    index :
        Not yet implemented. An optional index which might
        correspond to the timestep (for example).

    &#34;&#34;&#34;
    viewer = PETSc.ViewerHDF5().create(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
    if index:
        raise RuntimeError(&#34;Recording `index` not currently supported&#34;)
        ## JM:To enable timestep recording, the following needs to be called.
        ## I&#39;m unsure if the corresponding xdmf functionality is enabled via
        ## the PETSc xdmf script.
        # viewer.pushTimestepping(viewer)
        # viewer.setTimestep(index)
    viewer(self.dm)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.stats"><code class="name flex">
<span>def <span class="ident">stats</span></span>(<span>self, uw_function)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns various norms on the mesh for the provided function.
- size
- mean
- min
- max
- sum
- L2 norm
- rms</p>
<p>NOTE: this currently assumes scalar variables !</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self, uw_function):
    &#34;&#34;&#34;
    Returns various norms on the mesh for the provided function.
      - size
      - mean
      - min
      - max
      - sum
      - L2 norm
      - rms

      NOTE: this currently assumes scalar variables !
    &#34;&#34;&#34;

    #       This uses a private work MeshVariable and the various norms defined there but
    #       could either be simplified to just use petsc vectors, or extended to
    #       compute integrals over the elements which is in line with uw1 and uw2

    from petsc4py.PETSc import NormType

    tmp = self._work_MeshVar

    with self.access(tmp):
        tmp.data[...] = uw.function.evaluate(uw_function, tmp.coords).reshape(-1, 1)

    vsize = self._work_MeshVar._gvec.getSize()
    vmean = tmp.mean()
    vmax = tmp.max()[1]
    vmin = tmp.min()[1]
    vsum = tmp.sum()
    vnorm2 = tmp.norm(NormType.NORM_2)
    vrms = vnorm2 / numpy.sqrt(vsize)

    return vsize, vmean, vmin, vmax, vsum, vnorm2, vrms

    ## Here we check the existence of the meshVariable and so on before defining a new one
    ## (and potentially losing the handle to the old one)</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.update_lvec"><code class="name flex">
<span>def <span class="ident">update_lvec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method creates and/or updates the mesh variable local vector.
If the local vector is already up to date, this method will do nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def update_lvec(self):
    &#34;&#34;&#34;
    This method creates and/or updates the mesh variable local vector.
    If the local vector is already up to date, this method will do nothing.
    &#34;&#34;&#34;

    if self._stale_lvec:
        if not self._lvec:
            # self.dm.clearDS()
            # self.dm.createDS()
            # create the local vector (memory chunk) and attach to original dm
            self._lvec = self.dm.createLocalVec()
        # push avar arrays into the parent dm array
        a_global = self.dm.getGlobalVec()
        names, isets, dms = self.dm.createFieldDecomposition()

        with self.access():
            # traverse subdms, taking user generated data in the subdm
            # local vec, pushing it into a global sub vec
            for var, subiset, subdm in zip(self.vars.values(), isets, dms):
                lvec = var.vec
                subvec = a_global.getSubVector(subiset)
                subdm.localToGlobal(lvec, subvec, addv=False)
                a_global.restoreSubVector(subiset, subvec)

        self.dm.globalToLocal(a_global, self._lvec)
        self.dm.restoreGlobalVec(a_global)
        self._stale_lvec = False</code></pre>
</details>
</dd>
<dt id="underworld3.discretisation.Mesh.vtk"><code class="name flex">
<span>def <span class="ident">vtk</span></span>(<span>self, filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Save mesh to the specified file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vtk(self, filename: str):
    &#34;&#34;&#34;
    Save mesh to the specified file
    &#34;&#34;&#34;

    viewer = PETSc.Viewer().createVTK(filename, &#34;w&#34;, comm=PETSc.COMM_WORLD)
    viewer(self.dm)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3" href="index.html">underworld3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="underworld3.discretisation.MeshVariable" href="#underworld3.discretisation.MeshVariable">MeshVariable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.discretisation.Mesh" href="#underworld3.discretisation.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="underworld3.discretisation.Mesh.CoordinateSystem" href="#underworld3.discretisation.Mesh.CoordinateSystem">CoordinateSystem</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.N" href="#underworld3.discretisation.Mesh.N">N</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.X" href="#underworld3.discretisation.Mesh.X">X</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.access" href="#underworld3.discretisation.Mesh.access">access</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.cdim" href="#underworld3.discretisation.Mesh.cdim">cdim</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.data" href="#underworld3.discretisation.Mesh.data">data</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.deform_mesh" href="#underworld3.discretisation.Mesh.deform_mesh">deform_mesh</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.dim" href="#underworld3.discretisation.Mesh.dim">dim</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.generate_xdmf" href="#underworld3.discretisation.Mesh.generate_xdmf">generate_xdmf</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_closest_cells" href="#underworld3.discretisation.Mesh.get_closest_cells">get_closest_cells</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.get_min_radius" href="#underworld3.discretisation.Mesh.get_min_radius">get_min_radius</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.lvec" href="#underworld3.discretisation.Mesh.lvec">lvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.mesh_instances" href="#underworld3.discretisation.Mesh.mesh_instances">mesh_instances</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.nuke_coords_and_rebuild" href="#underworld3.discretisation.Mesh.nuke_coords_and_rebuild">nuke_coords_and_rebuild</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.r" href="#underworld3.discretisation.Mesh.r">r</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.rvec" href="#underworld3.discretisation.Mesh.rvec">rvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.save" href="#underworld3.discretisation.Mesh.save">save</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.stats" href="#underworld3.discretisation.Mesh.stats">stats</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.update_lvec" href="#underworld3.discretisation.Mesh.update_lvec">update_lvec</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.vars" href="#underworld3.discretisation.Mesh.vars">vars</a></code></li>
<li><code><a title="underworld3.discretisation.Mesh.vtk" href="#underworld3.discretisation.Mesh.vtk">vtk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>