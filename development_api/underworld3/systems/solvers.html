<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>underworld3.systems.solvers API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>underworld3.systems.solvers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sympy
from sympy import sympify
from sympy.vector import gradient, divergence
import numpy as np

from typing import Optional, Callable

from petsc4py import PETSc

import underworld3 as uw
from underworld3.systems import SNES_Scalar, SNES_Vector, SNES_Stokes, SNES_SaddlePoint
import underworld3.timing as timing


class SNES_Poisson(SNES_Scalar):
    r&#34;&#34;&#34;
    SNES-based poisson equation solver

    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        ## Keep track

        SNES_Poisson.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Poisson_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # Register the problem setup function
        self._setup_problem_description = self.poisson_problem_description

        # default values for properties
        self.f = sympy.Matrix.zeros(1, 1)

    ## This function is the one we will typically over-ride to build specific solvers.
    ## This example is a poisson-like problem with isotropic coefficients

    @timing.routine_timer_decorator
    def poisson_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # f1 residual term (weighted integration) - scalar function
        self._f0 = self.F0 - self.f

        # f1 residual term (integration by parts / gradients)
        # isotropic
        self._f1 = (
            self.F1 + self.constitutive_model.flux(self._L).T
        )  # self.k * (self._L)

        return

    @property
    def f(self):
        return self._f

    @f.setter
    def f(self, value):
        self.is_setup = False
        self._f = sympy.Matrix((value,))


class SNES_Darcy(SNES_Scalar):
    r&#34;&#34;&#34;
    Darcy docstring ...
    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable,
        v_Field: uw.discretisation.MeshVariable,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        ## Keep track

        SNES_Darcy.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Darcy_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # Register the problem setup function
        self._setup_problem_description = self.darcy_problem_description

        # default values for properties
        self._f = 0.0
        self._k = 1.0

        self._s = sympy.Matrix.zeros(rows=1, cols=self.mesh.dim)
        self._s[1] = -1.0

        self._v = v_Field

        ## Set up the projection operator that
        ## solves the flow rate

        self._v_projector = uw.systems.solvers.SNES_Vector_Projection(self.mesh, self.v)

        # If we add smoothing, it should be small relative to actual diffusion (self.viscosity)
        self._v_projector.smoothing = 0.0

    ## This function is the one we will typically over-ride to build specific solvers.
    ## This example is a poisson-like problem with isotropic coefficients

    @timing.routine_timer_decorator
    def darcy_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # f1 residual term (weighted integration)
        self._f0 = self.F0 - self.f

        # f1 residual term (integration by parts / gradients)
        self._f1 = self.F1 + self.darcy_flux

        # Flow calculation
        self._v_projector.uw_function = -self.darcy_flux

        return

    @property
    def f(self):
        return self._f

    @f.setter
    def f(self, value):
        self.is_setup = False
        self._f = sympy.Matrix((value,))

    @property
    def s(self):
        return self._s

    @s.setter
    def s(self, value):
        self.is_setup = False
        self._s = sympy.Matrix((value,))

    @property
    def darcy_flux(self):
        flux = self.constitutive_model.flux(self._L - self.s).T
        return flux

    @property
    def v(self):
        return self._v

    @v.setter
    def v(self, value):
        self._v_projector.is_setup = False
        self._v = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        timestep:
            value used to evaluate inertial contribution
        &#34;&#34;&#34;

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Solve pressure

        super().solve(zero_init_guess, _force_setup)

        # Now solve flow field

        self._v_projector.petsc_options[
            &#34;snes_type&#34;
        ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
        self._v_projector.petsc_options[&#34;snes_rtol&#34;] = 1.0e-5
        self._v_projector.petsc_options.delValue(&#34;ksp_monitor&#34;)
        self._v_projector.solve(zero_init_guess)

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):
        self._v_projector.uw_function = self.darcy_flux
        self._v_projector._setup_terms()
        super()._setup_terms()


## --------------------------------
## Stokes saddle point solver plus
## ancilliary functions - note that
## we need to update the description
## of the generic saddle pt solver
## to remove the Stokes-specific stuff
## --------------------------------


class SNES_Stokes(SNES_Stokes):
    r&#34;&#34;&#34;
    This class provides functionality for a discrete representation
    of the Stokes flow equations assuming an incompressibility
    (or near-incompressibility) constraint.

    $$\frac{\partial}{\partial x_j} \left( \frac{\eta}{2} \left[ \frac{\partial u_i}{\partial x_j}  +
            \frac{\partial u_j}{\partial x_i} \right]\right) - \frac{\partial p}{\partial x_i} = f_i$$

    $$\frac{\partial u_i}{\partial x_i} = 0$$

    ## Properties

      - The viscosity, \( \eta \) is provided by setting the `constitutive_model` property to
    one of the `uw.systems.constitutive_models` classes and populating the parameters.
    It is usually a constant or a function of position / time and may also be non-linear
    or anisotropic.

      - The bodyforce term, \( f_i \) is provided through the `bodyforce` property.

      - The Augmented Lagrangian approach to application of the incompressibility
    constraint is to penalise incompressibility in the Stokes equation by adding
    \( \lambda \nabla \cdot \mathbf{u} \) when the weak form of the equations is constructed.
    (this is in addition to the constraint equation, unlike in the classical penalty method).
    This is activated by setting the `penalty` property to a non-zero floating point value.

      - A preconditioner is usually required for the saddle point system and this is provided
    though the `saddle_preconditioner` property. A common choice is \( 1/ \eta \) or
    \( 1 / \eta + 1/ \lambda \) if a penalty is used


    ## Notes

      - The interpolation order of the `pressureField` variable is used to determine the integration order of
    the mixed finite element method and is usually lower than the order of the `velocityField` variable.

      - It is possible to set discontinuous pressure variables by setting the `p_continous` option to `False`
    (currently this is not implemented).

      - The `solver_name` parameter sets the namespace for PETSc options and should be unique and
    compatible with the PETSc naming conventions.
    &#34;&#34;&#34;

    instances = 0

    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        velocityField: uw.discretisation.MeshVariable,
        pressureField: uw.discretisation.MeshVariable,
        solver_name: Optional[str] = &#34;&#34;,
        verbose: Optional[str] = False,
        saddle_preconditioner=None,
    ):

        SNES_Stokes.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Stokes_{}_&#34;.format(self.instances)

        super().__init__(mesh, velocityField, pressureField, solver_name, verbose)

        # User-facing operations are matrices / vectors by preference

        # Depends on the geometry if DM coords are not cartesian
        if self.mesh.CoordinateSystem.CartesianDM:
            self._E = (self._L + self._L.transpose()) / 2
        elif self.mesh.CoordinateSystem.type == &#34;Cylindrical 2D Native&#34;:
            r = self.mesh.CoordinateSystem.N[0]
            vr = self._u.sym[0]
            vt = self._u.sym[1]
            self._E = self._L.copy()
            self._E[0, 0] = self._L[0, 0]  # don&#39;t need this one !
            self._E[1, 1] = self._L[1, 1] / r + vr / r
            self._E[0, 1] = (self._L[0, 1] / r + self._L[1, 0] - vt / r) / 2
            self._E[1, 0] = self._E[0, 1]

        else:
            # All the other ones ...
            pass

        self._E = self.mesh.vector.strain_tensor(self._u.sym)

        # scalar 2nd invariant (incompressible)
        self._Einv2 = sympy.sqrt((sympy.Matrix(self._E) ** 2).trace() / 2)
        self._penalty = 0.0
        self._constraints = sympy.Matrix(
            (self.div_u,)
        )  # by default, incompressibility constraint
        self._saddle_preconditioner = sympy.sympify(1)
        self._bodyforce = sympy.Matrix([0] * self.mesh.dim)

        self._setup_problem_description = self.stokes_problem_description

        # this attrib records if we need to re-setup
        self.is_setup = False

        return

    @timing.routine_timer_decorator
    def stokes_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms can be redefined here. We leave the
        # UF0, UF1, PF0 terms in place to allow injection of
        # additional terms. These are pre-defined to be zero

        # terms that become part of the weighted integral
        self._u_f0 = self.UF0 - self.bodyforce
        # Integration by parts into the stiffness matrix (constitutive terms)
        self._u_f1 = self.UF1 + self.stress + self.penalty * self.div_u * sympy.eye(dim)

        # forces in the constraint (pressure) equations
        self._p_f0 = self.PF0 + sympy.Matrix((self.constraints))

        return

    ## note ... this is probably over-simple
    ## due to isotropy. Once anisotropy is allowed, sympy
    ## is going to require us to work with NDim arrays in place of
    ## matrices ... but they need to go back to matrices for the
    ## pointwise function evaluation

    @property
    def strainrate(self):
        return sympy.Matrix(self._E)

    @property
    def stress_deviator(self):
        return self.constitutive_model.flux(self.strainrate)

    @property
    def stress(self):
        return self.stress_deviator - sympy.eye(self.mesh.dim) * (self.p.sym[0])

    @property
    def div_u(self):
        E = self.strainrate
        divergence = E.trace()
        return divergence

    @property
    def constraints(self):
        return self._constraints

    @constraints.setter
    def constraints(self, constraints_matrix):
        self._is_setup = False
        symval = sympify(constraints_matrix)
        self._constraints = symval

    @property
    def bodyforce(self):
        return self._bodyforce

    @bodyforce.setter
    def bodyforce(self, value):
        self.is_setup = False
        self._bodyforce = self.mesh.vector.to_matrix(value)

    @property
    def saddle_preconditioner(self):
        return self._saddle_preconditioner

    @saddle_preconditioner.setter
    def saddle_preconditioner(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._saddle_preconditioner = symval

    @property
    def penalty(self):
        return self._penalty

    @penalty.setter
    def penalty(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._penalty = symval

    @timing.routine_timer_decorator
    def estimate_dt(self):
        &#34;&#34;&#34;
        Calculates an appropriate advective timestep for the given
        mesh and velocity configuration.
        &#34;&#34;&#34;
        # we&#39;ll want to do this on an element by element basis
        # for more general mesh

        # first let&#39;s extract a max global velocity magnitude
        import math

        with self.mesh.access():
            vel = self.u.data
            magvel_squared = vel[:, 0] ** 2 + vel[:, 1] ** 2
            if self.mesh.dim == 3:
                magvel_squared += vel[:, 2] ** 2

            max_magvel = math.sqrt(magvel_squared.max())

        from mpi4py import MPI

        comm = MPI.COMM_WORLD
        max_magvel_glob = comm.allreduce(max_magvel, op=MPI.MAX)

        min_dx = self.mesh.get_min_radius()
        return min_dx / max_magvel_glob


## --------------------------------
## Project from pointwise functions
## nodal point unknowns
## --------------------------------


class SNES_Projection(SNES_Scalar):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES.

    Consitutive model for this solver is the identity tensor (purely for validation)

    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        SNES_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;SProj_{}_&#34;.format(self.instances)

        super().__init__(mesh, u_Field, solver_name, verbose)

        self._setup_problem_description = self.projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._uw_weighting_function = 1.0
        self._constitutive_model = uw.systems.constitutive_models.Constitutive_Model(
            self.mesh.dim, 1
        )

        return

    @timing.routine_timer_decorator
    def projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._f0 = (
            self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
        )

        # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

        self._f1 = self.F1 + self.smoothing * self._L

        return

    @property
    def uw_function(self):
        return self._uw_function

    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = sympy.Matrix([user_uw_function])

    @property
    def smoothing(self):
        return self._smoothing

    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function

    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function


## --------------------------------
## Project from pointwise vector
## functions to nodal point unknowns
##
## We can add boundary constraints in the usual way (parent class handles this)
## We can add smoothing (which takes the form of a viscosity term)
## We could consider an incompressibility constraint ... or remove null spaces
## --------------------------------


class SNES_Vector_Projection(SNES_Vector):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES

    Consitutive model for this solver is the identity tensor (purely for validation)
    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        SNES_Vector_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;VProj{}_&#34;.format(self.instances)

        super().__init__(mesh, u_Field, u_Field.degree, solver_name, verbose)

        self._setup_problem_description = self.projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._penalty = 0.0
        self._uw_weighting_function = 1.0
        self._constitutive_model = uw.systems.constitutive_models.Constitutive_Model(
            self.mesh.dim, self.mesh.dim
        )

        return

    @timing.routine_timer_decorator
    def projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._f0 = (
            self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
        )

        # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

        E = 0.5 * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T)  # ??
        self._f1 = (
            self.F1
            + self.smoothing * E
            + self.penalty
            * sympy.vector.divergence(self.u.fn)
            * sympy.eye(self.mesh.dim)
        )

        return

    @property
    def uw_function(self):
        return self._uw_function

    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = user_uw_function

    @property
    def smoothing(self):
        return self._smoothing

    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)

    @property
    def penalty(self):
        return self._penalty

    @penalty.setter
    def penalty(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._penalty = symval

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function

    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function


## --------------------------------
## Project from pointwise vector
## functions to nodal point unknowns
##
## We can add boundary constraints in the usual way (parent class handles this)
## We can add smoothing (which takes the form of a viscosity term)
## Here we add an incompressibility constraint
## --------------------------------


## Does not seem to be a well posed problem as currently written ...
## We will fall back to penalising the standard SNES_Vector
class SNES_Solenoidal_Vector_Projection(SNES_Stokes):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES


    instances = 0

    @timing.routine_timer_decorator
    def __init__(self,
                 mesh     : uw.discretisation.Mesh,
                 u_Field  : uw.discretisation.MeshVariable = None,
                 solver_name: str = &#34;&#34;,
                 verbose    = False):


        SNES_Solenoidal_Vector_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;iVProj{}_&#34;.format(self.instances)

        self._constraint_field = uw.discretisation.MeshVariable( mesh=mesh, num_components=1, name=&#34;VSP_p{}&#34;.format(self.instances), vtype=uw.VarType.SCALAR, degree=u_Field.degree-1 )

        super().__init__(mesh,
                         u_Field,
                         self._constraint_field,
                         True, # continuous constraint field
                         solver_name, verbose
                        )

        self._setup_problem_description = self.constrained_projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._uw_weighting_function = 1.0

        return


    @timing.routine_timer_decorator
    def constrained_projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._u_f0 = self.UF0 + (self.u.sym - self.uw_function) * self.uw_weighting_function

        # Integration by parts into the stiffness matrix
        self._u_f1 = self.UF1  + self.smoothing * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T) - self._constraint_field.fn * sympy.Matrix.eye(dim)

        # rhs in the constraint (pressure) equations
        self._p_f0 = self.PF0  + self.mesh.vector.divergence(self.u.sym)

        return

    @property
    def uw_function(self):
        return self._uw_function
    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = user_uw_function

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function
    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function

    @property
    def smoothing(self):
        return self._smoothing
    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)
    &#34;&#34;&#34;


#################################################
# Characteristics-based advection-diffusion
# solver based on SNES_Poisson and swarm-to-nodes
#
# Note that the solve() method has the swarm
# handler.
#################################################


class SNES_AdvectionDiffusion_SLCN(SNES_Poisson):

    &#34;&#34;&#34;Characteristics-based advection diffusion solver:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        V_Field: uw.discretisation.MeshVariable = None,
        theta: float = 0.5,
        solver_name: str = &#34;&#34;,
        restore_points_func: Callable = None,
        verbose=False,
    ):

        SNES_AdvectionDiffusion_SLCN.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;AdvDiff_slcn_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # These are unique to the advection solver
        self._V = V_Field

        self.delta_t = 1.0
        self.theta = theta

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.adv_diff_slcn_problem_description

        self.is_setup = False

        # Add the nodal point swarm which we&#39;ll use to track the characteristics

        # There seems to be an issue with points launched from proc. boundaries
        # and managing the deletion of points, so a small perturbation to the coordinate
        # might fix this.

        nswarm = uw.swarm.Swarm(self.mesh)
        name = f&#34;^{{[{self.instances}]}}&#34; + r&#34;T^{*}&#34;
        nT1 = uw.swarm.SwarmVariable(name, nswarm, 1)
        name = f&#34;^{{[{self.instances}]}}&#34; + r&#34;X0^{*}&#34;
        nX0 = uw.swarm.SwarmVariable(name, nswarm, nswarm.dim)

        nswarm.dm.finalizeFieldRegister()
        nswarm.dm.addNPoints(
            self._u.coords.shape[0] + 1
        )  # why + 1 ? That&#39;s the number of spots actually allocated
        cellid = nswarm.dm.getField(&#34;DMSwarm_cellid&#34;)
        coords = nswarm.dm.getField(&#34;DMSwarmPIC_coor&#34;).reshape((-1, nswarm.dim))
        coords[...] = self._u.coords[...]
        cellid[:] = self.mesh.get_closest_cells(coords)

        # Move slightly within the chosen cell to avoid edge effects
        centroid_coords = self.mesh._centroids[cellid]
        shift = 1.0e-4 * self.mesh.get_min_radius()
        coords[...] = (1.0 - shift) * coords[...] + shift * centroid_coords[...]

        nswarm.dm.restoreField(&#34;DMSwarmPIC_coor&#34;)
        nswarm.dm.restoreField(&#34;DMSwarm_cellid&#34;)
        nswarm.dm.migrate(remove_sent_points=True)

        self._nswarm = nswarm
        self._u_star = nT1
        self._X0 = nX0

        # if we want u_star to satisfy the bcs then this will need to be
        # a projection-mesh variable but it should be ok given these points
        # are designed to land on the mesh

        self._Lstar = self.mesh.vector.jacobian(self._u_star.sym)

        return

    def adv_diff_slcn_problem_description(self):

        N = self.mesh.N

        # f0 residual term
        self._f0 = self.F0 - self.f + (self.u.sym - self._u_star.sym) / self.delta_t

        # f1 residual term
        self._f1 = (
            self.F1
            + self.theta * self.constitutive_model.flux(self._L).T
            + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
        )

        return

    @property
    def u(self):
        return self._u

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        coords: np.ndarray = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # mid pt update scheme should be preferred by default, but it is possible to supply
        # coords to over-ride this (e.g. rigid body rotation example)

        # placeholder definitions can be removed later
        nswarm = self._nswarm
        t_soln = self._u
        v_soln = self._V
        nX0 = self._X0
        nT1 = self._u_star
        delta_t = timestep

        with nswarm.access(nX0):
            nX0.data[...] = nswarm.data[...]

        # replace this with built-in mid-point swarm advection (corrector term off)
        # and note the negative timestep

        if coords is None:  # Mid point method to find launch points (T*)
            nswarm.advection(
                self._V.sym,
                -timestep,
                order=2,
                corrector=False,
                restore_points_to_domain_func=self.restore_points_to_domain_func,
            )

        else:  # launch points (T*) provided by omniscience user
            with nswarm.access(nswarm.particle_coordinates):
                nswarm.data[...] = coords[...]

        # Sample the field at these locations

        with nswarm.access(nT1):
            nT1.data[...] = uw.function.evaluate(t_soln.sym[0], nswarm.data).reshape(
                -1, 1
            )

        # restore coords
        with nswarm.access(nswarm.particle_coordinates):
            nswarm.data[...] = nX0.data[...]

        # Over to you Poisson Solver

        super().solve(zero_init_guess, _force_setup)

        return


#################################################
# Swarm-based advection-diffusion
# solver based on SNES_Poisson and swarm-variable
# projection
#
#################################################


class SNES_AdvectionDiffusion_Swarm(SNES_Poisson):

    &#34;&#34;&#34;Characteristics-based advection diffusion solver:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        u_Star_fn=None,
        theta: float = 0.5,
        solver_name: str = &#34;&#34;,
        restore_points_func: Callable = None,
        projection: bool = True,
        verbose: bool = False,
    ):

        SNES_AdvectionDiffusion_Swarm.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;AdvDiff_swarm_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        self.delta_t = 1.0
        self.theta = theta
        self.projection = projection
        self._u_star_raw_fn = u_Star_fn

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.adv_diff_swarm_problem_description

        self.is_setup = False
        self.u_star_is_valid = False

        if projection:
            # set up a projection solver

            self._u_star_projected = uw.discretisation.MeshVariable(
                r&#34;u^{{*}}{}&#34;.format(self.instances), self.mesh, 1, degree=u_Field.degree
            )
            self._u_star_projector = uw.systems.solvers.SNES_Projection(
                self.mesh, self._u_star_projected
            )

            # If we add smoothing, it should be small relative to actual diffusion (self.k)
            self._u_star_projector.smoothing = 0.0
            self._u_star_projector.uw_function = self._u_star_raw_fn

        # if we want u_star to satisfy the bcs then this will need to be
        # a projection

        self._Lstar = self.mesh.vector.jacobian(self.u_star_fn)
        # sympy.derive_by_array(self.u_star_fn, self._X).reshape(self.mesh.dim)

        return

    def adv_diff_swarm_problem_description(self):

        N = self.mesh.N

        # f0 residual term
        self._f0 = self.F0 - self.f + (self.u.sym - self.u_star_fn) / self.delta_t

        # f1 residual term
        self._f1 = (
            self.F1
            + self.theta * self.constitutive_model.flux(self._L).T
            + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
        )

        return

    @property
    def u(self):
        return self._u

    @property
    def u_star_fn(self):
        if self.projection:
            return self._u_star_projected.sym
        else:
            return self._u_star_raw_fn

    @u_star_fn.setter
    def u_star_fn(self, u_star_fn):
        self.is_setup = False
        if self.projection:
            self._u_star_projector.is_setup = False
            self._u_star_projector.uw_function = u_star_fn

        self._u_star_raw_fn = u_star_fn

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Make sure we update the projection of the swarm variable if requested

        if self.projection:
            self._u_star_projector.solve(zero_init_guess)

        # Over to you Poisson Solver

        super().solve(zero_init_guess, _force_setup)

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):

        if self.projection:
            self._u_star_projector.bcs = self.bcs
            self._u_star_projector._setup_terms()

        super()._setup_terms()


#################################################
# Swarm-based advection-diffusion
# solver based on SNES_Poisson and swarm-variable
# projection
#
#################################################


class SNES_NavierStokes_Swarm(SNES_Stokes):

    &#34;&#34;&#34;Swarm-based Navier Stokes:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        velocityField: uw.discretisation.MeshVariable = None,
        pressureField: uw.discretisation.MeshVariable = None,
        velocityStar_fn=None,  # uw.function.UnderworldFunction = None,
        u_degree: Optional[int] = 2,
        p_degree: Optional[int] = None,
        p_continous: Optional[bool] = True,
        rho: Optional[float] = 0.0,
        viscosity: Optional[float] = 1.0,
        theta: Optional[float] = 0.5,
        penalty: Optional[float] = 0.0,
        solver_name: Optional[str] = &#34;&#34;,
        verbose: Optional[bool] = False,
        projection: Optional[bool] = False,
        saddle_preconditioner=None,
        restore_points_func: Callable = None,
    ):

        SNES_NavierStokes_Swarm.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;NStokes_swarm_{}_&#34;.format(self.instances)

        self.delta_t = 1.0
        self.theta = theta
        self.projection = projection
        self.rho = rho
        self.viscosity = viscosity
        self._u_star_raw_fn = velocityStar_fn

        if saddle_preconditioner is None:
            self._saddle_preconditioner = 1.0 / (
                self.viscosity + self.rho / self.delta_t
            )
        else:
            self._saddle_preconditioner = saddle_preconditioner

        ## Parent class will set up default values etc
        super().__init__(
            mesh,
            velocityField,
            pressureField,
            u_degree,
            p_degree,
            p_continous,
            solver_name,
            verbose,
            penalty,
        )

        if projection:
            # set up a projection solver
            self._u_star_projected = uw.discretisation.MeshVariable(
                &#34;uStar{}&#34;.format(self.instances),
                self.mesh,
                self.mesh.dim,
                degree=u_degree,
            )
            self._u_star_projector = uw.systems.solvers.SNES_Vector_Projection(
                self.mesh, self._u_star_projected
            )

            # If we add smoothing, it should be small relative to actual diffusion (self.viscosity)
            self._u_star_projector.smoothing = 0.0
            self._u_star_projector.uw_function = self._u_star_raw_fn

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.navier_stokes_swarm_problem_description

        self.is_setup = False
        self.first_solve = True

        self._Ustar = sympy.Array(
            (self.u_star_fn.to_matrix(self.mesh.N))[0 : self.mesh.dim]
        )
        self._Lstar = sympy.derive_by_array(self._Ustar, self._X).transpose()

        # User-facing operations are matrices / vectors by preference but
        # self._L / _Lstar is a sympy.Array object

        self._Estar = (sympy.Matrix(self._Lstar) + sympy.Matrix(self._Lstar).T) / 2
        self._Stress_star = (
            self.constitutive_model.flux(self._Estar)
            - sympy.eye(self.mesh.dim) * self.p.fn
        )

        return

    def navier_stokes_swarm_problem_description(self):

        N = self.mesh.N
        dim = self.mesh.dim

        # terms that become part of the weighted integral
        self._u_f0 = (
            self.UF0
            - 1.0 * self.bodyforce
            + self.rho * (self.u.fn - self.u_star_fn) / self.delta_t
        )

        # Integration by parts into the stiffness matrix
        self._u_f1 = (
            self.UF1
            + self.stress * self.theta
            + self._Stress_star * (1.0 - self.theta)
            + self.penalty * self.div_u * sympy.eye(dim)
        )

        # forces in the constraint (pressure) equations
        self._p_f0 = self.PF0 + self.div_u

        return

    @property
    def u(self):
        return self._u

    @property
    def u_star_fn(self):
        if self.projection:
            return self._u_star_projected.fn
        else:
            return self._u_star_raw_fn

    @u_star_fn.setter
    def u_star_fn(self, uw_function):
        self.is_setup = False
        if self.projection:
            self._u_star_projector.is_setup = False
            self._u_star_projector.uw_function = uw_function

        self._u_star_raw_fn = uw_function

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_u_star_projection: bool = False,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        timestep:
            value used to evaluate inertial contribution
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Make sure we update the projection of the swarm variable if requested
        # But, this can break down on the first solve if there are constraints and bcs
        # (we might want to use v_star for checkpointing though)

        if self.projection and (not self.first_solve or _force_u_star_projection):
            print(
                &#34;Solve Ustar projection, uwfn = {}&#34;.format(
                    self._u_star_projector.uw_function
                )
            )
            self._u_star_projector.petsc_options[
                &#34;snes_type&#34;
            ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
            # v_mag_fn = self._u_star_raw_fn.dot(self._u_star_raw_fn)
            # v_stats = self.mesh.stats(v_mag_fn)
            # v_rms = v_stats[6]
            # self._u_star_projector.petsc_options[&#34;snes_atol&#34;] = v_rms * 1.0e-2
            self._u_star_projector.solve(zero_init_guess=False)

        # Over to you Stokes Solver
        super().solve(zero_init_guess, _force_setup)
        self.first_solve = False

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):

        if self.projection:
            self._u_star_projector.bcs = self.bcs
            self._u_star_projector._setup_terms()

        super()._setup_terms()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN"><code class="flex name class">
<span>class <span class="ident">SNES_AdvectionDiffusion_SLCN</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, V_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, theta: float = 0.5, solver_name: str = '', restore_points_func: Callable = None, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Characteristics-based advection diffusion solver:</p>
<p>Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
a mid-point advection scheme (based on our particle swarm implementation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_AdvectionDiffusion_SLCN(SNES_Poisson):

    &#34;&#34;&#34;Characteristics-based advection diffusion solver:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        V_Field: uw.discretisation.MeshVariable = None,
        theta: float = 0.5,
        solver_name: str = &#34;&#34;,
        restore_points_func: Callable = None,
        verbose=False,
    ):

        SNES_AdvectionDiffusion_SLCN.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;AdvDiff_slcn_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # These are unique to the advection solver
        self._V = V_Field

        self.delta_t = 1.0
        self.theta = theta

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.adv_diff_slcn_problem_description

        self.is_setup = False

        # Add the nodal point swarm which we&#39;ll use to track the characteristics

        # There seems to be an issue with points launched from proc. boundaries
        # and managing the deletion of points, so a small perturbation to the coordinate
        # might fix this.

        nswarm = uw.swarm.Swarm(self.mesh)
        name = f&#34;^{{[{self.instances}]}}&#34; + r&#34;T^{*}&#34;
        nT1 = uw.swarm.SwarmVariable(name, nswarm, 1)
        name = f&#34;^{{[{self.instances}]}}&#34; + r&#34;X0^{*}&#34;
        nX0 = uw.swarm.SwarmVariable(name, nswarm, nswarm.dim)

        nswarm.dm.finalizeFieldRegister()
        nswarm.dm.addNPoints(
            self._u.coords.shape[0] + 1
        )  # why + 1 ? That&#39;s the number of spots actually allocated
        cellid = nswarm.dm.getField(&#34;DMSwarm_cellid&#34;)
        coords = nswarm.dm.getField(&#34;DMSwarmPIC_coor&#34;).reshape((-1, nswarm.dim))
        coords[...] = self._u.coords[...]
        cellid[:] = self.mesh.get_closest_cells(coords)

        # Move slightly within the chosen cell to avoid edge effects
        centroid_coords = self.mesh._centroids[cellid]
        shift = 1.0e-4 * self.mesh.get_min_radius()
        coords[...] = (1.0 - shift) * coords[...] + shift * centroid_coords[...]

        nswarm.dm.restoreField(&#34;DMSwarmPIC_coor&#34;)
        nswarm.dm.restoreField(&#34;DMSwarm_cellid&#34;)
        nswarm.dm.migrate(remove_sent_points=True)

        self._nswarm = nswarm
        self._u_star = nT1
        self._X0 = nX0

        # if we want u_star to satisfy the bcs then this will need to be
        # a projection-mesh variable but it should be ok given these points
        # are designed to land on the mesh

        self._Lstar = self.mesh.vector.jacobian(self._u_star.sym)

        return

    def adv_diff_slcn_problem_description(self):

        N = self.mesh.N

        # f0 residual term
        self._f0 = self.F0 - self.f + (self.u.sym - self._u_star.sym) / self.delta_t

        # f1 residual term
        self._f1 = (
            self.F1
            + self.theta * self.constitutive_model.flux(self._L).T
            + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
        )

        return

    @property
    def u(self):
        return self._u

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        coords: np.ndarray = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # mid pt update scheme should be preferred by default, but it is possible to supply
        # coords to over-ride this (e.g. rigid body rotation example)

        # placeholder definitions can be removed later
        nswarm = self._nswarm
        t_soln = self._u
        v_soln = self._V
        nX0 = self._X0
        nT1 = self._u_star
        delta_t = timestep

        with nswarm.access(nX0):
            nX0.data[...] = nswarm.data[...]

        # replace this with built-in mid-point swarm advection (corrector term off)
        # and note the negative timestep

        if coords is None:  # Mid point method to find launch points (T*)
            nswarm.advection(
                self._V.sym,
                -timestep,
                order=2,
                corrector=False,
                restore_points_to_domain_func=self.restore_points_to_domain_func,
            )

        else:  # launch points (T*) provided by omniscience user
            with nswarm.access(nswarm.particle_coordinates):
                nswarm.data[...] = coords[...]

        # Sample the field at these locations

        with nswarm.access(nT1):
            nT1.data[...] = uw.function.evaluate(t_soln.sym[0], nswarm.data).reshape(
                -1, 1
            )

        # restore coords
        with nswarm.access(nswarm.particle_coordinates):
            nswarm.data[...] = nX0.data[...]

        # Over to you Poisson Solver

        super().solve(zero_init_guess, _force_setup)

        return</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_Poisson" href="#underworld3.systems.solvers.SNES_Poisson">SNES_Poisson</a></li>
<li>underworld3.cython.generic_solvers.SNES_Scalar</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.delta_t"><code class="name">var <span class="ident">delta_t</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delta_t(self):
    return self._delta_t</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def theta(self):
    return self._theta</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.u"><code class="name">var <span class="ident">u</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u(self):
    return self._u</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.adv_diff_slcn_problem_description"><code class="name flex">
<span>def <span class="ident">adv_diff_slcn_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adv_diff_slcn_problem_description(self):

    N = self.mesh.N

    # f0 residual term
    self._f0 = self.F0 - self.f + (self.u.sym - self._u_star.sym) / self.delta_t

    # f1 residual term
    self._f1 = (
        self.F1
        + self.theta * self.constitutive_model.flux(self._L).T
        + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
    )

    return</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, zero_init_guess: bool = True, timestep: float = None, coords: numpy.ndarray = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates solution to constructed system.</p>
<h2 id="params">Params</h2>
<p>zero_init_guess:
If <code>True</code>, a zero initial guess will be used for the
system solution. Otherwise, the current values of <code>self.u</code> will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def solve(
    self,
    zero_init_guess: bool = True,
    timestep: float = None,
    coords: np.ndarray = None,
    _force_setup: bool = False,
):
    &#34;&#34;&#34;
    Generates solution to constructed system.

    Params
    ------
    zero_init_guess:
        If `True`, a zero initial guess will be used for the
        system solution. Otherwise, the current values of `self.u` will be used.
    &#34;&#34;&#34;

    if timestep is not None and timestep != self.delta_t:
        self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

    if (not self.is_setup) or _force_setup:
        self._setup_terms()

    # mid pt update scheme should be preferred by default, but it is possible to supply
    # coords to over-ride this (e.g. rigid body rotation example)

    # placeholder definitions can be removed later
    nswarm = self._nswarm
    t_soln = self._u
    v_soln = self._V
    nX0 = self._X0
    nT1 = self._u_star
    delta_t = timestep

    with nswarm.access(nX0):
        nX0.data[...] = nswarm.data[...]

    # replace this with built-in mid-point swarm advection (corrector term off)
    # and note the negative timestep

    if coords is None:  # Mid point method to find launch points (T*)
        nswarm.advection(
            self._V.sym,
            -timestep,
            order=2,
            corrector=False,
            restore_points_to_domain_func=self.restore_points_to_domain_func,
        )

    else:  # launch points (T*) provided by omniscience user
        with nswarm.access(nswarm.particle_coordinates):
            nswarm.data[...] = coords[...]

    # Sample the field at these locations

    with nswarm.access(nT1):
        nT1.data[...] = uw.function.evaluate(t_soln.sym[0], nswarm.data).reshape(
            -1, 1
        )

    # restore coords
    with nswarm.access(nswarm.particle_coordinates):
        nswarm.data[...] = nX0.data[...]

    # Over to you Poisson Solver

    super().solve(zero_init_guess, _force_setup)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm"><code class="flex name class">
<span>class <span class="ident">SNES_AdvectionDiffusion_Swarm</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, u_Star_fn=None, theta: float = 0.5, solver_name: str = '', restore_points_func: Callable = None, projection: bool = True, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Characteristics-based advection diffusion solver:</p>
<p>Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
a mid-point advection scheme (based on our particle swarm implementation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_AdvectionDiffusion_Swarm(SNES_Poisson):

    &#34;&#34;&#34;Characteristics-based advection diffusion solver:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        u_Star_fn=None,
        theta: float = 0.5,
        solver_name: str = &#34;&#34;,
        restore_points_func: Callable = None,
        projection: bool = True,
        verbose: bool = False,
    ):

        SNES_AdvectionDiffusion_Swarm.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;AdvDiff_swarm_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        self.delta_t = 1.0
        self.theta = theta
        self.projection = projection
        self._u_star_raw_fn = u_Star_fn

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.adv_diff_swarm_problem_description

        self.is_setup = False
        self.u_star_is_valid = False

        if projection:
            # set up a projection solver

            self._u_star_projected = uw.discretisation.MeshVariable(
                r&#34;u^{{*}}{}&#34;.format(self.instances), self.mesh, 1, degree=u_Field.degree
            )
            self._u_star_projector = uw.systems.solvers.SNES_Projection(
                self.mesh, self._u_star_projected
            )

            # If we add smoothing, it should be small relative to actual diffusion (self.k)
            self._u_star_projector.smoothing = 0.0
            self._u_star_projector.uw_function = self._u_star_raw_fn

        # if we want u_star to satisfy the bcs then this will need to be
        # a projection

        self._Lstar = self.mesh.vector.jacobian(self.u_star_fn)
        # sympy.derive_by_array(self.u_star_fn, self._X).reshape(self.mesh.dim)

        return

    def adv_diff_swarm_problem_description(self):

        N = self.mesh.N

        # f0 residual term
        self._f0 = self.F0 - self.f + (self.u.sym - self.u_star_fn) / self.delta_t

        # f1 residual term
        self._f1 = (
            self.F1
            + self.theta * self.constitutive_model.flux(self._L).T
            + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
        )

        return

    @property
    def u(self):
        return self._u

    @property
    def u_star_fn(self):
        if self.projection:
            return self._u_star_projected.sym
        else:
            return self._u_star_raw_fn

    @u_star_fn.setter
    def u_star_fn(self, u_star_fn):
        self.is_setup = False
        if self.projection:
            self._u_star_projector.is_setup = False
            self._u_star_projector.uw_function = u_star_fn

        self._u_star_raw_fn = u_star_fn

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Make sure we update the projection of the swarm variable if requested

        if self.projection:
            self._u_star_projector.solve(zero_init_guess)

        # Over to you Poisson Solver

        super().solve(zero_init_guess, _force_setup)

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):

        if self.projection:
            self._u_star_projector.bcs = self.bcs
            self._u_star_projector._setup_terms()

        super()._setup_terms()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_Poisson" href="#underworld3.systems.solvers.SNES_Poisson">SNES_Poisson</a></li>
<li>underworld3.cython.generic_solvers.SNES_Scalar</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.delta_t"><code class="name">var <span class="ident">delta_t</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delta_t(self):
    return self._delta_t</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def theta(self):
    return self._theta</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u"><code class="name">var <span class="ident">u</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u(self):
    return self._u</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u_star_fn"><code class="name">var <span class="ident">u_star_fn</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_star_fn(self):
    if self.projection:
        return self._u_star_projected.sym
    else:
        return self._u_star_raw_fn</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.adv_diff_swarm_problem_description"><code class="name flex">
<span>def <span class="ident">adv_diff_swarm_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adv_diff_swarm_problem_description(self):

    N = self.mesh.N

    # f0 residual term
    self._f0 = self.F0 - self.f + (self.u.sym - self.u_star_fn) / self.delta_t

    # f1 residual term
    self._f1 = (
        self.F1
        + self.theta * self.constitutive_model.flux(self._L).T
        + (1.0 - self.theta) * self.constitutive_model.flux(self._Lstar).T
    )

    return</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, zero_init_guess: bool = True, timestep: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates solution to constructed system.</p>
<h2 id="params">Params</h2>
<p>zero_init_guess:
If <code>True</code>, a zero initial guess will be used for the
system solution. Otherwise, the current values of <code>self.u</code> will be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def solve(
    self,
    zero_init_guess: bool = True,
    timestep: float = None,
    _force_setup: bool = False,
):
    &#34;&#34;&#34;
    Generates solution to constructed system.

    Params
    ------
    zero_init_guess:
        If `True`, a zero initial guess will be used for the
        system solution. Otherwise, the current values of `self.u` will be used.
    &#34;&#34;&#34;

    if timestep is not None and timestep != self.delta_t:
        self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

    if (not self.is_setup) or _force_setup:
        self._setup_terms()

    # Make sure we update the projection of the swarm variable if requested

    if self.projection:
        self._u_star_projector.solve(zero_init_guess)

    # Over to you Poisson Solver

    super().solve(zero_init_guess, _force_setup)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_Darcy"><code class="flex name class">
<span>class <span class="ident">SNES_Darcy</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950>, v_Field: <function MeshVariable at 0x7fd6d1e9a950>, solver_name: str = '', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Darcy docstring &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Darcy(SNES_Scalar):
    r&#34;&#34;&#34;
    Darcy docstring ...
    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable,
        v_Field: uw.discretisation.MeshVariable,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        ## Keep track

        SNES_Darcy.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Darcy_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # Register the problem setup function
        self._setup_problem_description = self.darcy_problem_description

        # default values for properties
        self._f = 0.0
        self._k = 1.0

        self._s = sympy.Matrix.zeros(rows=1, cols=self.mesh.dim)
        self._s[1] = -1.0

        self._v = v_Field

        ## Set up the projection operator that
        ## solves the flow rate

        self._v_projector = uw.systems.solvers.SNES_Vector_Projection(self.mesh, self.v)

        # If we add smoothing, it should be small relative to actual diffusion (self.viscosity)
        self._v_projector.smoothing = 0.0

    ## This function is the one we will typically over-ride to build specific solvers.
    ## This example is a poisson-like problem with isotropic coefficients

    @timing.routine_timer_decorator
    def darcy_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # f1 residual term (weighted integration)
        self._f0 = self.F0 - self.f

        # f1 residual term (integration by parts / gradients)
        self._f1 = self.F1 + self.darcy_flux

        # Flow calculation
        self._v_projector.uw_function = -self.darcy_flux

        return

    @property
    def f(self):
        return self._f

    @f.setter
    def f(self, value):
        self.is_setup = False
        self._f = sympy.Matrix((value,))

    @property
    def s(self):
        return self._s

    @s.setter
    def s(self, value):
        self.is_setup = False
        self._s = sympy.Matrix((value,))

    @property
    def darcy_flux(self):
        flux = self.constitutive_model.flux(self._L - self.s).T
        return flux

    @property
    def v(self):
        return self._v

    @v.setter
    def v(self, value):
        self._v_projector.is_setup = False
        self._v = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        timestep:
            value used to evaluate inertial contribution
        &#34;&#34;&#34;

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Solve pressure

        super().solve(zero_init_guess, _force_setup)

        # Now solve flow field

        self._v_projector.petsc_options[
            &#34;snes_type&#34;
        ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
        self._v_projector.petsc_options[&#34;snes_rtol&#34;] = 1.0e-5
        self._v_projector.petsc_options.delValue(&#34;ksp_monitor&#34;)
        self._v_projector.solve(zero_init_guess)

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):
        self._v_projector.uw_function = self.darcy_flux
        self._v_projector._setup_terms()
        super()._setup_terms()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.cython.generic_solvers.SNES_Scalar</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Darcy.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Darcy.darcy_flux"><code class="name">var <span class="ident">darcy_flux</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def darcy_flux(self):
    flux = self.constitutive_model.flux(self._L - self.s).T
    return flux</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Darcy.f"><code class="name">var <span class="ident">f</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def f(self):
    return self._f</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Darcy.s"><code class="name">var <span class="ident">s</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def s(self):
    return self._s</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Darcy.v"><code class="name">var <span class="ident">v</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def v(self):
    return self._v</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Darcy.darcy_problem_description"><code class="name flex">
<span>def <span class="ident">darcy_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def darcy_problem_description(self):

    dim = self.mesh.dim
    N = self.mesh.N

    # f1 residual term (weighted integration)
    self._f0 = self.F0 - self.f

    # f1 residual term (integration by parts / gradients)
    self._f1 = self.F1 + self.darcy_flux

    # Flow calculation
    self._v_projector.uw_function = -self.darcy_flux

    return</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Darcy.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, zero_init_guess: bool = True, timestep: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates solution to constructed system.</p>
<h2 id="params">Params</h2>
<p>zero_init_guess:
If <code>True</code>, a zero initial guess will be used for the
system solution. Otherwise, the current values of <code>self.u</code> will be used.
timestep:
value used to evaluate inertial contribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def solve(
    self,
    zero_init_guess: bool = True,
    timestep: float = None,
    _force_setup: bool = False,
):
    &#34;&#34;&#34;
    Generates solution to constructed system.

    Params
    ------
    zero_init_guess:
        If `True`, a zero initial guess will be used for the
        system solution. Otherwise, the current values of `self.u` will be used.
    timestep:
        value used to evaluate inertial contribution
    &#34;&#34;&#34;

    if (not self.is_setup) or _force_setup:
        self._setup_terms()

    # Solve pressure

    super().solve(zero_init_guess, _force_setup)

    # Now solve flow field

    self._v_projector.petsc_options[
        &#34;snes_type&#34;
    ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
    self._v_projector.petsc_options[&#34;snes_rtol&#34;] = 1.0e-5
    self._v_projector.petsc_options.delValue(&#34;ksp_monitor&#34;)
    self._v_projector.solve(zero_init_guess)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm"><code class="flex name class">
<span>class <span class="ident">SNES_NavierStokes_Swarm</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, velocityField: <function MeshVariable at 0x7fd6d1e9a950> = None, pressureField: <function MeshVariable at 0x7fd6d1e9a950> = None, velocityStar_fn=None, u_degree: Optional[int] = 2, p_degree: Optional[int] = None, p_continous: Optional[bool] = True, rho: Optional[float] = 0.0, viscosity: Optional[float] = 1.0, theta: Optional[float] = 0.5, penalty: Optional[float] = 0.0, solver_name: Optional[str] = '', verbose: Optional[bool] = False, projection: Optional[bool] = False, saddle_preconditioner=None, restore_points_func: Callable = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Swarm-based Navier Stokes:</p>
<p>Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
a mid-point advection scheme (based on our particle swarm implementation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_NavierStokes_Swarm(SNES_Stokes):

    &#34;&#34;&#34;Swarm-based Navier Stokes:

    Uses a theta timestepping approach with semi-Lagrange sample backwards in time using
    a mid-point advection scheme (based on our particle swarm implementation)
    &#34;&#34;&#34;

    instances = 0  # count how many of these there are in order to create unique private mesh variable ids

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        velocityField: uw.discretisation.MeshVariable = None,
        pressureField: uw.discretisation.MeshVariable = None,
        velocityStar_fn=None,  # uw.function.UnderworldFunction = None,
        u_degree: Optional[int] = 2,
        p_degree: Optional[int] = None,
        p_continous: Optional[bool] = True,
        rho: Optional[float] = 0.0,
        viscosity: Optional[float] = 1.0,
        theta: Optional[float] = 0.5,
        penalty: Optional[float] = 0.0,
        solver_name: Optional[str] = &#34;&#34;,
        verbose: Optional[bool] = False,
        projection: Optional[bool] = False,
        saddle_preconditioner=None,
        restore_points_func: Callable = None,
    ):

        SNES_NavierStokes_Swarm.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;NStokes_swarm_{}_&#34;.format(self.instances)

        self.delta_t = 1.0
        self.theta = theta
        self.projection = projection
        self.rho = rho
        self.viscosity = viscosity
        self._u_star_raw_fn = velocityStar_fn

        if saddle_preconditioner is None:
            self._saddle_preconditioner = 1.0 / (
                self.viscosity + self.rho / self.delta_t
            )
        else:
            self._saddle_preconditioner = saddle_preconditioner

        ## Parent class will set up default values etc
        super().__init__(
            mesh,
            velocityField,
            pressureField,
            u_degree,
            p_degree,
            p_continous,
            solver_name,
            verbose,
            penalty,
        )

        if projection:
            # set up a projection solver
            self._u_star_projected = uw.discretisation.MeshVariable(
                &#34;uStar{}&#34;.format(self.instances),
                self.mesh,
                self.mesh.dim,
                degree=u_degree,
            )
            self._u_star_projector = uw.systems.solvers.SNES_Vector_Projection(
                self.mesh, self._u_star_projected
            )

            # If we add smoothing, it should be small relative to actual diffusion (self.viscosity)
            self._u_star_projector.smoothing = 0.0
            self._u_star_projector.uw_function = self._u_star_raw_fn

        self.restore_points_to_domain_func = restore_points_func
        self._setup_problem_description = self.navier_stokes_swarm_problem_description

        self.is_setup = False
        self.first_solve = True

        self._Ustar = sympy.Array(
            (self.u_star_fn.to_matrix(self.mesh.N))[0 : self.mesh.dim]
        )
        self._Lstar = sympy.derive_by_array(self._Ustar, self._X).transpose()

        # User-facing operations are matrices / vectors by preference but
        # self._L / _Lstar is a sympy.Array object

        self._Estar = (sympy.Matrix(self._Lstar) + sympy.Matrix(self._Lstar).T) / 2
        self._Stress_star = (
            self.constitutive_model.flux(self._Estar)
            - sympy.eye(self.mesh.dim) * self.p.fn
        )

        return

    def navier_stokes_swarm_problem_description(self):

        N = self.mesh.N
        dim = self.mesh.dim

        # terms that become part of the weighted integral
        self._u_f0 = (
            self.UF0
            - 1.0 * self.bodyforce
            + self.rho * (self.u.fn - self.u_star_fn) / self.delta_t
        )

        # Integration by parts into the stiffness matrix
        self._u_f1 = (
            self.UF1
            + self.stress * self.theta
            + self._Stress_star * (1.0 - self.theta)
            + self.penalty * self.div_u * sympy.eye(dim)
        )

        # forces in the constraint (pressure) equations
        self._p_f0 = self.PF0 + self.div_u

        return

    @property
    def u(self):
        return self._u

    @property
    def u_star_fn(self):
        if self.projection:
            return self._u_star_projected.fn
        else:
            return self._u_star_raw_fn

    @u_star_fn.setter
    def u_star_fn(self, uw_function):
        self.is_setup = False
        if self.projection:
            self._u_star_projector.is_setup = False
            self._u_star_projector.uw_function = uw_function

        self._u_star_raw_fn = uw_function

    @property
    def delta_t(self):
        return self._delta_t

    @delta_t.setter
    def delta_t(self, value):
        self.is_setup = False
        self._delta_t = sympify(value)

    @property
    def theta(self):
        return self._theta

    @theta.setter
    def theta(self, value):
        self.is_setup = False
        self._theta = sympify(value)

    @timing.routine_timer_decorator
    def solve(
        self,
        zero_init_guess: bool = True,
        timestep: float = None,
        _force_u_star_projection: bool = False,
        _force_setup: bool = False,
    ):
        &#34;&#34;&#34;
        Generates solution to constructed system.

        Params
        ------
        zero_init_guess:
            If `True`, a zero initial guess will be used for the
            system solution. Otherwise, the current values of `self.u` will be used.
        timestep:
            value used to evaluate inertial contribution
        &#34;&#34;&#34;

        if timestep is not None and timestep != self.delta_t:
            self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

        if (not self.is_setup) or _force_setup:
            self._setup_terms()

        # Make sure we update the projection of the swarm variable if requested
        # But, this can break down on the first solve if there are constraints and bcs
        # (we might want to use v_star for checkpointing though)

        if self.projection and (not self.first_solve or _force_u_star_projection):
            print(
                &#34;Solve Ustar projection, uwfn = {}&#34;.format(
                    self._u_star_projector.uw_function
                )
            )
            self._u_star_projector.petsc_options[
                &#34;snes_type&#34;
            ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
            # v_mag_fn = self._u_star_raw_fn.dot(self._u_star_raw_fn)
            # v_stats = self.mesh.stats(v_mag_fn)
            # v_rms = v_stats[6]
            # self._u_star_projector.petsc_options[&#34;snes_atol&#34;] = v_rms * 1.0e-2
            self._u_star_projector.solve(zero_init_guess=False)

        # Over to you Stokes Solver
        super().solve(zero_init_guess, _force_setup)
        self.first_solve = False

        return

    @timing.routine_timer_decorator
    def _setup_terms(self):

        if self.projection:
            self._u_star_projector.bcs = self.bcs
            self._u_star_projector._setup_terms()

        super()._setup_terms()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_Stokes" href="#underworld3.systems.solvers.SNES_Stokes">SNES_Stokes</a></li>
<li>underworld3.cython.generic_solvers.SNES_Stokes</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.delta_t"><code class="name">var <span class="ident">delta_t</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delta_t(self):
    return self._delta_t</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.theta"><code class="name">var <span class="ident">theta</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def theta(self):
    return self._theta</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.u"><code class="name">var <span class="ident">u</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u(self):
    return self._u</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.u_star_fn"><code class="name">var <span class="ident">u_star_fn</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def u_star_fn(self):
    if self.projection:
        return self._u_star_projected.fn
    else:
        return self._u_star_raw_fn</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.navier_stokes_swarm_problem_description"><code class="name flex">
<span>def <span class="ident">navier_stokes_swarm_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def navier_stokes_swarm_problem_description(self):

    N = self.mesh.N
    dim = self.mesh.dim

    # terms that become part of the weighted integral
    self._u_f0 = (
        self.UF0
        - 1.0 * self.bodyforce
        + self.rho * (self.u.fn - self.u_star_fn) / self.delta_t
    )

    # Integration by parts into the stiffness matrix
    self._u_f1 = (
        self.UF1
        + self.stress * self.theta
        + self._Stress_star * (1.0 - self.theta)
        + self.penalty * self.div_u * sympy.eye(dim)
    )

    # forces in the constraint (pressure) equations
    self._p_f0 = self.PF0 + self.div_u

    return</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_NavierStokes_Swarm.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, zero_init_guess: bool = True, timestep: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates solution to constructed system.</p>
<h2 id="params">Params</h2>
<p>zero_init_guess:
If <code>True</code>, a zero initial guess will be used for the
system solution. Otherwise, the current values of <code>self.u</code> will be used.
timestep:
value used to evaluate inertial contribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def solve(
    self,
    zero_init_guess: bool = True,
    timestep: float = None,
    _force_u_star_projection: bool = False,
    _force_setup: bool = False,
):
    &#34;&#34;&#34;
    Generates solution to constructed system.

    Params
    ------
    zero_init_guess:
        If `True`, a zero initial guess will be used for the
        system solution. Otherwise, the current values of `self.u` will be used.
    timestep:
        value used to evaluate inertial contribution
    &#34;&#34;&#34;

    if timestep is not None and timestep != self.delta_t:
        self.delta_t = timestep  # this will force an initialisation because the functions need to be updated

    if (not self.is_setup) or _force_setup:
        self._setup_terms()

    # Make sure we update the projection of the swarm variable if requested
    # But, this can break down on the first solve if there are constraints and bcs
    # (we might want to use v_star for checkpointing though)

    if self.projection and (not self.first_solve or _force_u_star_projection):
        print(
            &#34;Solve Ustar projection, uwfn = {}&#34;.format(
                self._u_star_projector.uw_function
            )
        )
        self._u_star_projector.petsc_options[
            &#34;snes_type&#34;
        ] = &#34;newtontr&#34;  ## newtonls seems to be problematic when the previous guess is available
        # v_mag_fn = self._u_star_raw_fn.dot(self._u_star_raw_fn)
        # v_stats = self.mesh.stats(v_mag_fn)
        # v_rms = v_stats[6]
        # self._u_star_projector.petsc_options[&#34;snes_atol&#34;] = v_rms * 1.0e-2
        self._u_star_projector.solve(zero_init_guess=False)

    # Over to you Stokes Solver
    super().solve(zero_init_guess, _force_setup)
    self.first_solve = False

    return</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.systems.solvers.SNES_Stokes" href="#underworld3.systems.solvers.SNES_Stokes">SNES_Stokes</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.estimate_dt" href="#underworld3.systems.solvers.SNES_Stokes.estimate_dt">estimate_dt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="underworld3.systems.solvers.SNES_Poisson"><code class="flex name class">
<span>class <span class="ident">SNES_Poisson</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, solver_name: str = '', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>SNES-based poisson equation solver</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Poisson(SNES_Scalar):
    r&#34;&#34;&#34;
    SNES-based poisson equation solver

    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        ## Keep track

        SNES_Poisson.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Poisson_{}_&#34;.format(self.instances)

        ## Parent class will set up default values etc
        super().__init__(mesh, u_Field, solver_name, verbose)

        # Register the problem setup function
        self._setup_problem_description = self.poisson_problem_description

        # default values for properties
        self.f = sympy.Matrix.zeros(1, 1)

    ## This function is the one we will typically over-ride to build specific solvers.
    ## This example is a poisson-like problem with isotropic coefficients

    @timing.routine_timer_decorator
    def poisson_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # f1 residual term (weighted integration) - scalar function
        self._f0 = self.F0 - self.f

        # f1 residual term (integration by parts / gradients)
        # isotropic
        self._f1 = (
            self.F1 + self.constitutive_model.flux(self._L).T
        )  # self.k * (self._L)

        return

    @property
    def f(self):
        return self._f

    @f.setter
    def f(self, value):
        self.is_setup = False
        self._f = sympy.Matrix((value,))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.cython.generic_solvers.SNES_Scalar</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN">SNES_AdvectionDiffusion_SLCN</a></li>
<li><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm">SNES_AdvectionDiffusion_Swarm</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Poisson.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Poisson.f"><code class="name">var <span class="ident">f</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def f(self):
    return self._f</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Poisson.poisson_problem_description"><code class="name flex">
<span>def <span class="ident">poisson_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def poisson_problem_description(self):

    dim = self.mesh.dim
    N = self.mesh.N

    # f1 residual term (weighted integration) - scalar function
    self._f0 = self.F0 - self.f

    # f1 residual term (integration by parts / gradients)
    # isotropic
    self._f1 = (
        self.F1 + self.constitutive_model.flux(self._L).T
    )  # self.k * (self._L)

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_Projection"><code class="flex name class">
<span>class <span class="ident">SNES_Projection</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, solver_name: str = '', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Map underworld (pointwise) function to continuous
nodal point values in least-squares sense.</p>
<p>Solver can be given boundary conditions that
the continuous function needs to satisfy and
non-linear constraints will be handled by SNES.</p>
<p>Consitutive model for this solver is the identity tensor (purely for validation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Projection(SNES_Scalar):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES.

    Consitutive model for this solver is the identity tensor (purely for validation)

    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        SNES_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;SProj_{}_&#34;.format(self.instances)

        super().__init__(mesh, u_Field, solver_name, verbose)

        self._setup_problem_description = self.projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._uw_weighting_function = 1.0
        self._constitutive_model = uw.systems.constitutive_models.Constitutive_Model(
            self.mesh.dim, 1
        )

        return

    @timing.routine_timer_decorator
    def projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._f0 = (
            self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
        )

        # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

        self._f1 = self.F1 + self.smoothing * self._L

        return

    @property
    def uw_function(self):
        return self._uw_function

    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = sympy.Matrix([user_uw_function])

    @property
    def smoothing(self):
        return self._smoothing

    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function

    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.cython.generic_solvers.SNES_Scalar</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Projection.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Projection.smoothing"><code class="name">var <span class="ident">smoothing</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def smoothing(self):
    return self._smoothing</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Projection.uw_function"><code class="name">var <span class="ident">uw_function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uw_function(self):
    return self._uw_function</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Projection.uw_weighting_function"><code class="name">var <span class="ident">uw_weighting_function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uw_weighting_function(self):
    return self._uw_weighting_function</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Projection.projection_problem_description"><code class="name flex">
<span>def <span class="ident">projection_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def projection_problem_description(self):

    dim = self.mesh.dim
    N = self.mesh.N

    # residual terms - defines the problem:
    # solve for a best fit to the continuous mesh
    # variable given the values in self.function
    # F0 is left in place for the user to inject
    # non-linear constraints if required

    self._f0 = (
        self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
    )

    # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

    self._f1 = self.F1 + self.smoothing * self._L

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_Solenoidal_Vector_Projection"><code class="flex name class">
<span>class <span class="ident">SNES_Solenoidal_Vector_Projection</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, velocityField: <function MeshVariable at 0x7fd6d1e9a950>, pressureField: <function MeshVariable at 0x7fd6d1e9a950>, solver_name: Optional[str] = '', verbose: Optional[str] = False, saddle_preconditioner=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Map underworld (pointwise) function to continuous
nodal point values in least-squares sense.</p>
<p>Solver can be given boundary conditions that
the continuous function needs to satisfy and
non-linear constraints will be handled by SNES</p>
<p>instances = 0</p>
<p>@timing.routine_timer_decorator
def <strong>init</strong>(self,
mesh
: uw.discretisation.Mesh,
u_Field
: uw.discretisation.MeshVariable = None,
solver_name: str = "",
verbose
= False):</p>
<pre><code>SNES_Solenoidal_Vector_Projection.instances += 1

if solver_name == "":
    solver_name = "iVProj{}_".format(self.instances)

self._constraint_field = uw.discretisation.MeshVariable( mesh=mesh, num_components=1, name="VSP_p{}".format(self.instances), vtype=uw.VarType.SCALAR, degree=u_Field.degree-1 )

super().__init__(mesh,
                 u_Field,
                 self._constraint_field,
                 True, # continuous constraint field
                 solver_name, verbose
                )

self._setup_problem_description = self.constrained_projection_problem_description
self.is_setup = False
self._smoothing = 0.0
self._uw_weighting_function = 1.0

return
</code></pre>
<p>@timing.routine_timer_decorator
def constrained_projection_problem_description(self):</p>
<pre><code>dim = self.mesh.dim
N = self.mesh.N

# residual terms - defines the problem:
# solve for a best fit to the continuous mesh
# variable given the values in self.function
# F0 is left in place for the user to inject
# non-linear constraints if required

self._u_f0 = self.UF0 + (self.u.sym - self.uw_function) * self.uw_weighting_function

# Integration by parts into the stiffness matrix
self._u_f1 = self.UF1  + self.smoothing * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T) - self._constraint_field.fn * sympy.Matrix.eye(dim)

# rhs in the constraint (pressure) equations
self._p_f0 = self.PF0  + self.mesh.vector.divergence(self.u.sym)

return
</code></pre>
<p>@property
def uw_function(self):
return self._uw_function
@uw_function.setter
def uw_function(self, user_uw_function):
self.is_setup = False
self._uw_function = user_uw_function</p>
<p>@property
def uw_weighting_function(self):
return self._uw_weighting_function
@uw_weighting_function.setter
def uw_weighting_function(self, user_uw_function):
self.is_setup = False
self._uw_weighting_function = user_uw_function</p>
<p>@property
def smoothing(self):
return self._smoothing
@smoothing.setter
def smoothing(self, smoothing_factor):
self.is_setup = False
self._smoothing = sympify(smoothing_factor)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Solenoidal_Vector_Projection(SNES_Stokes):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES


    instances = 0

    @timing.routine_timer_decorator
    def __init__(self,
                 mesh     : uw.discretisation.Mesh,
                 u_Field  : uw.discretisation.MeshVariable = None,
                 solver_name: str = &#34;&#34;,
                 verbose    = False):


        SNES_Solenoidal_Vector_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;iVProj{}_&#34;.format(self.instances)

        self._constraint_field = uw.discretisation.MeshVariable( mesh=mesh, num_components=1, name=&#34;VSP_p{}&#34;.format(self.instances), vtype=uw.VarType.SCALAR, degree=u_Field.degree-1 )

        super().__init__(mesh,
                         u_Field,
                         self._constraint_field,
                         True, # continuous constraint field
                         solver_name, verbose
                        )

        self._setup_problem_description = self.constrained_projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._uw_weighting_function = 1.0

        return


    @timing.routine_timer_decorator
    def constrained_projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._u_f0 = self.UF0 + (self.u.sym - self.uw_function) * self.uw_weighting_function

        # Integration by parts into the stiffness matrix
        self._u_f1 = self.UF1  + self.smoothing * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T) - self._constraint_field.fn * sympy.Matrix.eye(dim)

        # rhs in the constraint (pressure) equations
        self._p_f0 = self.PF0  + self.mesh.vector.divergence(self.u.sym)

        return

    @property
    def uw_function(self):
        return self._uw_function
    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = user_uw_function

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function
    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function

    @property
    def smoothing(self):
        return self._smoothing
    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_Stokes" href="#underworld3.systems.solvers.SNES_Stokes">SNES_Stokes</a></li>
<li>underworld3.cython.generic_solvers.SNES_Stokes</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="underworld3.systems.solvers.SNES_Stokes" href="#underworld3.systems.solvers.SNES_Stokes">SNES_Stokes</a></b></code>:
<ul class="hlist">
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.estimate_dt" href="#underworld3.systems.solvers.SNES_Stokes.estimate_dt">estimate_dt</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes"><code class="flex name class">
<span>class <span class="ident">SNES_Stokes</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, velocityField: <function MeshVariable at 0x7fd6d1e9a950>, pressureField: <function MeshVariable at 0x7fd6d1e9a950>, solver_name: Optional[str] = '', verbose: Optional[str] = False, saddle_preconditioner=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides functionality for a discrete representation
of the Stokes flow equations assuming an incompressibility
(or near-incompressibility) constraint.</p>
<p><span><span class="MathJax_Preview">\frac{\partial}{\partial x_j} \left( \frac{\eta}{2} \left[ \frac{\partial u_i}{\partial x_j}
+
\frac{\partial u_j}{\partial x_i} \right]\right) - \frac{\partial p}{\partial x_i} = f_i</span><script type="math/tex; mode=display">\frac{\partial}{\partial x_j} \left( \frac{\eta}{2} \left[ \frac{\partial u_i}{\partial x_j}
+
\frac{\partial u_j}{\partial x_i} \right]\right) - \frac{\partial p}{\partial x_i} = f_i</script></span></p>
<p><span><span class="MathJax_Preview">\frac{\partial u_i}{\partial x_i} = 0</span><script type="math/tex; mode=display">\frac{\partial u_i}{\partial x_i} = 0</script></span></p>
<h2 id="properties">Properties</h2>
<ul>
<li>
<p>The viscosity, <span><span class="MathJax_Preview"> \eta </span><script type="math/tex"> \eta </script></span> is provided by setting the <code>constitutive_model</code> property to
one of the <code>uw.systems.constitutive_models</code> classes and populating the parameters.
It is usually a constant or a function of position / time and may also be non-linear
or anisotropic.</p>
</li>
<li>
<p>The bodyforce term, <span><span class="MathJax_Preview"> f_i </span><script type="math/tex"> f_i </script></span> is provided through the <code>bodyforce</code> property.</p>
</li>
<li>
<p>The Augmented Lagrangian approach to application of the incompressibility
constraint is to penalise incompressibility in the Stokes equation by adding
<span><span class="MathJax_Preview"> \lambda \nabla \cdot \mathbf{u} </span><script type="math/tex"> \lambda \nabla \cdot \mathbf{u} </script></span> when the weak form of the equations is constructed.
(this is in addition to the constraint equation, unlike in the classical penalty method).
This is activated by setting the <code>penalty</code> property to a non-zero floating point value.</p>
</li>
<li>
<p>A preconditioner is usually required for the saddle point system and this is provided
though the <code>saddle_preconditioner</code> property. A common choice is <span><span class="MathJax_Preview"> 1/ \eta </span><script type="math/tex"> 1/ \eta </script></span> or
<span><span class="MathJax_Preview"> 1 / \eta + 1/ \lambda </span><script type="math/tex"> 1 / \eta + 1/ \lambda </script></span> if a penalty is used</p>
</li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>
<p>The interpolation order of the <code>pressureField</code> variable is used to determine the integration order of
the mixed finite element method and is usually lower than the order of the <code>velocityField</code> variable.</p>
</li>
<li>
<p>It is possible to set discontinuous pressure variables by setting the <code>p_continous</code> option to <code>False</code>
(currently this is not implemented).</p>
</li>
<li>
<p>The <code>solver_name</code> parameter sets the namespace for PETSc options and should be unique and
compatible with the PETSc naming conventions.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Stokes(SNES_Stokes):
    r&#34;&#34;&#34;
    This class provides functionality for a discrete representation
    of the Stokes flow equations assuming an incompressibility
    (or near-incompressibility) constraint.

    $$\frac{\partial}{\partial x_j} \left( \frac{\eta}{2} \left[ \frac{\partial u_i}{\partial x_j}  +
            \frac{\partial u_j}{\partial x_i} \right]\right) - \frac{\partial p}{\partial x_i} = f_i$$

    $$\frac{\partial u_i}{\partial x_i} = 0$$

    ## Properties

      - The viscosity, \( \eta \) is provided by setting the `constitutive_model` property to
    one of the `uw.systems.constitutive_models` classes and populating the parameters.
    It is usually a constant or a function of position / time and may also be non-linear
    or anisotropic.

      - The bodyforce term, \( f_i \) is provided through the `bodyforce` property.

      - The Augmented Lagrangian approach to application of the incompressibility
    constraint is to penalise incompressibility in the Stokes equation by adding
    \( \lambda \nabla \cdot \mathbf{u} \) when the weak form of the equations is constructed.
    (this is in addition to the constraint equation, unlike in the classical penalty method).
    This is activated by setting the `penalty` property to a non-zero floating point value.

      - A preconditioner is usually required for the saddle point system and this is provided
    though the `saddle_preconditioner` property. A common choice is \( 1/ \eta \) or
    \( 1 / \eta + 1/ \lambda \) if a penalty is used


    ## Notes

      - The interpolation order of the `pressureField` variable is used to determine the integration order of
    the mixed finite element method and is usually lower than the order of the `velocityField` variable.

      - It is possible to set discontinuous pressure variables by setting the `p_continous` option to `False`
    (currently this is not implemented).

      - The `solver_name` parameter sets the namespace for PETSc options and should be unique and
    compatible with the PETSc naming conventions.
    &#34;&#34;&#34;

    instances = 0

    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        velocityField: uw.discretisation.MeshVariable,
        pressureField: uw.discretisation.MeshVariable,
        solver_name: Optional[str] = &#34;&#34;,
        verbose: Optional[str] = False,
        saddle_preconditioner=None,
    ):

        SNES_Stokes.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;Stokes_{}_&#34;.format(self.instances)

        super().__init__(mesh, velocityField, pressureField, solver_name, verbose)

        # User-facing operations are matrices / vectors by preference

        # Depends on the geometry if DM coords are not cartesian
        if self.mesh.CoordinateSystem.CartesianDM:
            self._E = (self._L + self._L.transpose()) / 2
        elif self.mesh.CoordinateSystem.type == &#34;Cylindrical 2D Native&#34;:
            r = self.mesh.CoordinateSystem.N[0]
            vr = self._u.sym[0]
            vt = self._u.sym[1]
            self._E = self._L.copy()
            self._E[0, 0] = self._L[0, 0]  # don&#39;t need this one !
            self._E[1, 1] = self._L[1, 1] / r + vr / r
            self._E[0, 1] = (self._L[0, 1] / r + self._L[1, 0] - vt / r) / 2
            self._E[1, 0] = self._E[0, 1]

        else:
            # All the other ones ...
            pass

        self._E = self.mesh.vector.strain_tensor(self._u.sym)

        # scalar 2nd invariant (incompressible)
        self._Einv2 = sympy.sqrt((sympy.Matrix(self._E) ** 2).trace() / 2)
        self._penalty = 0.0
        self._constraints = sympy.Matrix(
            (self.div_u,)
        )  # by default, incompressibility constraint
        self._saddle_preconditioner = sympy.sympify(1)
        self._bodyforce = sympy.Matrix([0] * self.mesh.dim)

        self._setup_problem_description = self.stokes_problem_description

        # this attrib records if we need to re-setup
        self.is_setup = False

        return

    @timing.routine_timer_decorator
    def stokes_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms can be redefined here. We leave the
        # UF0, UF1, PF0 terms in place to allow injection of
        # additional terms. These are pre-defined to be zero

        # terms that become part of the weighted integral
        self._u_f0 = self.UF0 - self.bodyforce
        # Integration by parts into the stiffness matrix (constitutive terms)
        self._u_f1 = self.UF1 + self.stress + self.penalty * self.div_u * sympy.eye(dim)

        # forces in the constraint (pressure) equations
        self._p_f0 = self.PF0 + sympy.Matrix((self.constraints))

        return

    ## note ... this is probably over-simple
    ## due to isotropy. Once anisotropy is allowed, sympy
    ## is going to require us to work with NDim arrays in place of
    ## matrices ... but they need to go back to matrices for the
    ## pointwise function evaluation

    @property
    def strainrate(self):
        return sympy.Matrix(self._E)

    @property
    def stress_deviator(self):
        return self.constitutive_model.flux(self.strainrate)

    @property
    def stress(self):
        return self.stress_deviator - sympy.eye(self.mesh.dim) * (self.p.sym[0])

    @property
    def div_u(self):
        E = self.strainrate
        divergence = E.trace()
        return divergence

    @property
    def constraints(self):
        return self._constraints

    @constraints.setter
    def constraints(self, constraints_matrix):
        self._is_setup = False
        symval = sympify(constraints_matrix)
        self._constraints = symval

    @property
    def bodyforce(self):
        return self._bodyforce

    @bodyforce.setter
    def bodyforce(self, value):
        self.is_setup = False
        self._bodyforce = self.mesh.vector.to_matrix(value)

    @property
    def saddle_preconditioner(self):
        return self._saddle_preconditioner

    @saddle_preconditioner.setter
    def saddle_preconditioner(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._saddle_preconditioner = symval

    @property
    def penalty(self):
        return self._penalty

    @penalty.setter
    def penalty(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._penalty = symval

    @timing.routine_timer_decorator
    def estimate_dt(self):
        &#34;&#34;&#34;
        Calculates an appropriate advective timestep for the given
        mesh and velocity configuration.
        &#34;&#34;&#34;
        # we&#39;ll want to do this on an element by element basis
        # for more general mesh

        # first let&#39;s extract a max global velocity magnitude
        import math

        with self.mesh.access():
            vel = self.u.data
            magvel_squared = vel[:, 0] ** 2 + vel[:, 1] ** 2
            if self.mesh.dim == 3:
                magvel_squared += vel[:, 2] ** 2

            max_magvel = math.sqrt(magvel_squared.max())

        from mpi4py import MPI

        comm = MPI.COMM_WORLD
        max_magvel_glob = comm.allreduce(max_magvel, op=MPI.MAX)

        min_dx = self.mesh.get_min_radius()
        return min_dx / max_magvel_glob</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.cython.generic_solvers.SNES_Stokes</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm">SNES_NavierStokes_Swarm</a></li>
<li><a title="underworld3.systems.solvers.SNES_Solenoidal_Vector_Projection" href="#underworld3.systems.solvers.SNES_Solenoidal_Vector_Projection">SNES_Solenoidal_Vector_Projection</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Stokes.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Stokes.bodyforce"><code class="name">var <span class="ident">bodyforce</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bodyforce(self):
    return self._bodyforce</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def constraints(self):
    return self._constraints</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.div_u"><code class="name">var <span class="ident">div_u</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def div_u(self):
    E = self.strainrate
    divergence = E.trace()
    return divergence</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.penalty"><code class="name">var <span class="ident">penalty</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def penalty(self):
    return self._penalty</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.saddle_preconditioner"><code class="name">var <span class="ident">saddle_preconditioner</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def saddle_preconditioner(self):
    return self._saddle_preconditioner</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.strainrate"><code class="name">var <span class="ident">strainrate</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def strainrate(self):
    return sympy.Matrix(self._E)</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.stress"><code class="name">var <span class="ident">stress</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stress(self):
    return self.stress_deviator - sympy.eye(self.mesh.dim) * (self.p.sym[0])</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.stress_deviator"><code class="name">var <span class="ident">stress_deviator</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stress_deviator(self):
    return self.constitutive_model.flux(self.strainrate)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Stokes.estimate_dt"><code class="name flex">
<span>def <span class="ident">estimate_dt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates an appropriate advective timestep for the given
mesh and velocity configuration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def estimate_dt(self):
    &#34;&#34;&#34;
    Calculates an appropriate advective timestep for the given
    mesh and velocity configuration.
    &#34;&#34;&#34;
    # we&#39;ll want to do this on an element by element basis
    # for more general mesh

    # first let&#39;s extract a max global velocity magnitude
    import math

    with self.mesh.access():
        vel = self.u.data
        magvel_squared = vel[:, 0] ** 2 + vel[:, 1] ** 2
        if self.mesh.dim == 3:
            magvel_squared += vel[:, 2] ** 2

        max_magvel = math.sqrt(magvel_squared.max())

    from mpi4py import MPI

    comm = MPI.COMM_WORLD
    max_magvel_glob = comm.allreduce(max_magvel, op=MPI.MAX)

    min_dx = self.mesh.get_min_radius()
    return min_dx / max_magvel_glob</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Stokes.stokes_problem_description"><code class="name flex">
<span>def <span class="ident">stokes_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def stokes_problem_description(self):

    dim = self.mesh.dim
    N = self.mesh.N

    # residual terms can be redefined here. We leave the
    # UF0, UF1, PF0 terms in place to allow injection of
    # additional terms. These are pre-defined to be zero

    # terms that become part of the weighted integral
    self._u_f0 = self.UF0 - self.bodyforce
    # Integration by parts into the stiffness matrix (constitutive terms)
    self._u_f1 = self.UF1 + self.stress + self.penalty * self.div_u * sympy.eye(dim)

    # forces in the constraint (pressure) equations
    self._p_f0 = self.PF0 + sympy.Matrix((self.constraints))

    return</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection"><code class="flex name class">
<span>class <span class="ident">SNES_Vector_Projection</span></span>
<span>(</span><span>mesh: <a title="underworld3.discretisation.Mesh" href="../discretisation.html#underworld3.discretisation.Mesh">Mesh</a>, u_Field: <function MeshVariable at 0x7fd6d1e9a950> = None, solver_name: str = '', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Map underworld (pointwise) function to continuous
nodal point values in least-squares sense.</p>
<p>Solver can be given boundary conditions that
the continuous function needs to satisfy and
non-linear constraints will be handled by SNES</p>
<p>Consitutive model for this solver is the identity tensor (purely for validation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SNES_Vector_Projection(SNES_Vector):
    &#34;&#34;&#34;
    Map underworld (pointwise) function to continuous
    nodal point values in least-squares sense.

    Solver can be given boundary conditions that
    the continuous function needs to satisfy and
    non-linear constraints will be handled by SNES

    Consitutive model for this solver is the identity tensor (purely for validation)
    &#34;&#34;&#34;

    instances = 0

    @timing.routine_timer_decorator
    def __init__(
        self,
        mesh: uw.discretisation.Mesh,
        u_Field: uw.discretisation.MeshVariable = None,
        solver_name: str = &#34;&#34;,
        verbose=False,
    ):

        SNES_Vector_Projection.instances += 1

        if solver_name == &#34;&#34;:
            solver_name = &#34;VProj{}_&#34;.format(self.instances)

        super().__init__(mesh, u_Field, u_Field.degree, solver_name, verbose)

        self._setup_problem_description = self.projection_problem_description
        self.is_setup = False
        self._smoothing = 0.0
        self._penalty = 0.0
        self._uw_weighting_function = 1.0
        self._constitutive_model = uw.systems.constitutive_models.Constitutive_Model(
            self.mesh.dim, self.mesh.dim
        )

        return

    @timing.routine_timer_decorator
    def projection_problem_description(self):

        dim = self.mesh.dim
        N = self.mesh.N

        # residual terms - defines the problem:
        # solve for a best fit to the continuous mesh
        # variable given the values in self.function
        # F0 is left in place for the user to inject
        # non-linear constraints if required

        self._f0 = (
            self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
        )

        # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

        E = 0.5 * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T)  # ??
        self._f1 = (
            self.F1
            + self.smoothing * E
            + self.penalty
            * sympy.vector.divergence(self.u.fn)
            * sympy.eye(self.mesh.dim)
        )

        return

    @property
    def uw_function(self):
        return self._uw_function

    @uw_function.setter
    def uw_function(self, user_uw_function):
        self.is_setup = False
        self._uw_function = user_uw_function

    @property
    def smoothing(self):
        return self._smoothing

    @smoothing.setter
    def smoothing(self, smoothing_factor):
        self.is_setup = False
        self._smoothing = sympify(smoothing_factor)

    @property
    def penalty(self):
        return self._penalty

    @penalty.setter
    def penalty(self, value):
        self.is_setup = False
        symval = sympify(value)
        self._penalty = symval

    @property
    def uw_weighting_function(self):
        return self._uw_weighting_function

    @uw_weighting_function.setter
    def uw_weighting_function(self, user_uw_function):
        self.is_setup = False
        self._uw_weighting_function = user_uw_function</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>underworld3.cython.generic_solvers.SNES_Vector</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.instances"><code class="name">var <span class="ident">instances</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.penalty"><code class="name">var <span class="ident">penalty</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def penalty(self):
    return self._penalty</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.smoothing"><code class="name">var <span class="ident">smoothing</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def smoothing(self):
    return self._smoothing</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.uw_function"><code class="name">var <span class="ident">uw_function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uw_function(self):
    return self._uw_function</code></pre>
</details>
</dd>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.uw_weighting_function"><code class="name">var <span class="ident">uw_weighting_function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def uw_weighting_function(self):
    return self._uw_weighting_function</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="underworld3.systems.solvers.SNES_Vector_Projection.projection_problem_description"><code class="name flex">
<span>def <span class="ident">projection_problem_description</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@timing.routine_timer_decorator
def projection_problem_description(self):

    dim = self.mesh.dim
    N = self.mesh.N

    # residual terms - defines the problem:
    # solve for a best fit to the continuous mesh
    # variable given the values in self.function
    # F0 is left in place for the user to inject
    # non-linear constraints if required

    self._f0 = (
        self.F0 + (self.u.sym - self.uw_function) * self.uw_weighting_function
    )

    # F1 is left in the users control ... e.g to add other gradient constraints to the stiffness matrix

    E = 0.5 * (sympy.Matrix(self._L) + sympy.Matrix(self._L).T)  # ??
    self._f1 = (
        self.F1
        + self.smoothing * E
        + self.penalty
        * sympy.vector.divergence(self.u.fn)
        * sympy.eye(self.mesh.dim)
    )

    return</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="underworld3.systems" href="index.html">underworld3.systems</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN">SNES_AdvectionDiffusion_SLCN</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.adv_diff_slcn_problem_description" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.adv_diff_slcn_problem_description">adv_diff_slcn_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.delta_t" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.delta_t">delta_t</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.instances" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.solve" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.solve">solve</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.theta" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.theta">theta</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.u" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_SLCN.u">u</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm">SNES_AdvectionDiffusion_Swarm</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.adv_diff_swarm_problem_description" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.adv_diff_swarm_problem_description">adv_diff_swarm_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.delta_t" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.delta_t">delta_t</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.instances" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.solve" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.solve">solve</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.theta" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.theta">theta</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u">u</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u_star_fn" href="#underworld3.systems.solvers.SNES_AdvectionDiffusion_Swarm.u_star_fn">u_star_fn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Darcy" href="#underworld3.systems.solvers.SNES_Darcy">SNES_Darcy</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.darcy_flux" href="#underworld3.systems.solvers.SNES_Darcy.darcy_flux">darcy_flux</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.darcy_problem_description" href="#underworld3.systems.solvers.SNES_Darcy.darcy_problem_description">darcy_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.f" href="#underworld3.systems.solvers.SNES_Darcy.f">f</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.instances" href="#underworld3.systems.solvers.SNES_Darcy.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.s" href="#underworld3.systems.solvers.SNES_Darcy.s">s</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.solve" href="#underworld3.systems.solvers.SNES_Darcy.solve">solve</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Darcy.v" href="#underworld3.systems.solvers.SNES_Darcy.v">v</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm">SNES_NavierStokes_Swarm</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.delta_t" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.delta_t">delta_t</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.instances" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.navier_stokes_swarm_problem_description" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.navier_stokes_swarm_problem_description">navier_stokes_swarm_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.solve" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.solve">solve</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.theta" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.theta">theta</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.u" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.u">u</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_NavierStokes_Swarm.u_star_fn" href="#underworld3.systems.solvers.SNES_NavierStokes_Swarm.u_star_fn">u_star_fn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Poisson" href="#underworld3.systems.solvers.SNES_Poisson">SNES_Poisson</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_Poisson.f" href="#underworld3.systems.solvers.SNES_Poisson.f">f</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Poisson.instances" href="#underworld3.systems.solvers.SNES_Poisson.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Poisson.poisson_problem_description" href="#underworld3.systems.solvers.SNES_Poisson.poisson_problem_description">poisson_problem_description</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Projection" href="#underworld3.systems.solvers.SNES_Projection">SNES_Projection</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_Projection.instances" href="#underworld3.systems.solvers.SNES_Projection.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Projection.projection_problem_description" href="#underworld3.systems.solvers.SNES_Projection.projection_problem_description">projection_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Projection.smoothing" href="#underworld3.systems.solvers.SNES_Projection.smoothing">smoothing</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Projection.uw_function" href="#underworld3.systems.solvers.SNES_Projection.uw_function">uw_function</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Projection.uw_weighting_function" href="#underworld3.systems.solvers.SNES_Projection.uw_weighting_function">uw_weighting_function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Solenoidal_Vector_Projection" href="#underworld3.systems.solvers.SNES_Solenoidal_Vector_Projection">SNES_Solenoidal_Vector_Projection</a></code></h4>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Stokes" href="#underworld3.systems.solvers.SNES_Stokes">SNES_Stokes</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.bodyforce" href="#underworld3.systems.solvers.SNES_Stokes.bodyforce">bodyforce</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.constraints" href="#underworld3.systems.solvers.SNES_Stokes.constraints">constraints</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.div_u" href="#underworld3.systems.solvers.SNES_Stokes.div_u">div_u</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.estimate_dt" href="#underworld3.systems.solvers.SNES_Stokes.estimate_dt">estimate_dt</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.instances" href="#underworld3.systems.solvers.SNES_Stokes.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.penalty" href="#underworld3.systems.solvers.SNES_Stokes.penalty">penalty</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.saddle_preconditioner" href="#underworld3.systems.solvers.SNES_Stokes.saddle_preconditioner">saddle_preconditioner</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.stokes_problem_description" href="#underworld3.systems.solvers.SNES_Stokes.stokes_problem_description">stokes_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.strainrate" href="#underworld3.systems.solvers.SNES_Stokes.strainrate">strainrate</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.stress" href="#underworld3.systems.solvers.SNES_Stokes.stress">stress</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Stokes.stress_deviator" href="#underworld3.systems.solvers.SNES_Stokes.stress_deviator">stress_deviator</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="underworld3.systems.solvers.SNES_Vector_Projection" href="#underworld3.systems.solvers.SNES_Vector_Projection">SNES_Vector_Projection</a></code></h4>
<ul class="">
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.instances" href="#underworld3.systems.solvers.SNES_Vector_Projection.instances">instances</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.penalty" href="#underworld3.systems.solvers.SNES_Vector_Projection.penalty">penalty</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.projection_problem_description" href="#underworld3.systems.solvers.SNES_Vector_Projection.projection_problem_description">projection_problem_description</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.smoothing" href="#underworld3.systems.solvers.SNES_Vector_Projection.smoothing">smoothing</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.uw_function" href="#underworld3.systems.solvers.SNES_Vector_Projection.uw_function">uw_function</a></code></li>
<li><code><a title="underworld3.systems.solvers.SNES_Vector_Projection.uw_weighting_function" href="#underworld3.systems.solvers.SNES_Vector_Projection.uw_weighting_function">uw_weighting_function</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>